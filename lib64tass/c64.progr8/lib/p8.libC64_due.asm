; 6502 assembly code for 'prova'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2022-09-24T16:11:45
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=BASICSAFE

.cpu  '6502'
.enc  'none'
P8ZP_SCRATCH_B1 = 2
P8ZP_SCRATCH_REG = 3
P8ZP_SCRATCH_W1 = 251    ; word
P8ZP_SCRATCH_W2 = 253    ; word
.weak
P8ESTACK_LO = $ce00
P8ESTACK_HI = $cf00
.endweak
; ---- basic program with sys call ----
* = $0801
	.word  (+), 2022
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint	; assembly code starts here
	jsr  c64.init_system
	jsr  c64.init_system_phase2
	jsr  main.start
	lda  #31
	sta  $01
	jmp  c64.cleanup_at_exit

; ---- block: 'main' ----
main	.proc
	;	src line: prova.p8:14

; non-zeropage variables

; subroutines in this block
	;	src line: prova.p8:16

start	.proc
; program startup initialization
	cld
	jsr  diskio.prog8_init_vars
	jsr  graphics.prog8_init_vars
+       tsx
	stx  prog8_lib.orig_stackpointer    ; required for sys.exit()
	ldx  #255       ; init estack ptr
	clv
	clc
; statements
	;	src line: prova.p8:16
	rts
; variables

; non-zeropage variables
	.pend
	.pend

; ---- block: 'prog8_interned_strings' ----
prog8_interned_strings	.proc
	;	src line: ~dummy~:0

; non-zeropage variables
string_0	; PETSCII:"\uf10d\uf11a\uf139\uf11b     \uf11a\uf13a\uf11b"
	.byte  $9c, $12, $df, $92, $20, $20, $20, $20, $20, $12, $e9, $92, $00
string_1	; PETSCII:"\uf10b\uf11a\u258e\uf139\uf11b   \uf11a\uf13a\uf130\uf11b"
	.byte  $9a, $12, $f4, $df, $92, $20, $20, $20, $12, $e9, $ea, $92, $00
string_2	; PETSCII:"\uf10f\uf11a\u258c \uf139\uf11b \uf11a\uf13a \uf11b\u258c"
	.byte  $9f, $12, $e1, $20, $df, $92, $20, $12, $e9, $20, $92, $e1, $00
string_3	; PETSCII:"\uf102 \uf132\uf11a\u2596\uf11b \uf11a\u2597\uf11b\uf132"
	.byte  $1e, $20, $f7, $12, $fb, $92, $20, $12, $ec, $92, $f7, $00
string_4	; PETSCII:"\uf10e \u2582\uf11a\u2598\uf11b \uf11a\u259d\uf11b\u2582"
	.byte  $9e, $20, $ef, $12, $fe, $92, $20, $12, $fc, $92, $ef, $00
string_5	; PETSCII:"\uf104 \uf11a \uf11b\uf13a\uf11b \uf139\uf11a \uf11b"
	.byte  $81, $20, $12, $20, $92, $e9, $92, $20, $df, $12, $20, $92, $00
string_6	; PETSCII:"\uf101\uf130\uf13a   \uf139\u258e\uf100"
	.byte  $1c, $ea, $e9, $20, $20, $20, $df, $f4, $05, $00
string_7	; PETSCII:"$"
	.byte  $24, $00

; subroutines in this block
	;	src line: library:/prog8lib/cx16logo.p8:23
	;	src line: library:/prog8lib/cx16logo.p8:24
	;	src line: library:/prog8lib/cx16logo.p8:25
	;	src line: library:/prog8lib/cx16logo.p8:26
	;	src line: library:/prog8lib/cx16logo.p8:27
	;	src line: library:/prog8lib/cx16logo.p8:28
	;	src line: library:/prog8lib/cx16logo.p8:29
	;	src line: library:/prog8lib/diskio.p8:12
	.pend

; ---- block: 'txt' ----
txt	.proc
	;	src line: library:/prog8lib/c64/textio.p8:7
	DEFAULT_WIDTH = $28
	DEFAULT_HEIGHT = $19

; non-zeropage variables
	chrout = $ffd2

; subroutines in this block
	;	src line: library:/prog8lib/c64/textio.p8:9
	;	src line: library:/prog8lib/c64/textio.p8:10
	;	src line: library:/prog8lib/c64/textio.p8:21

nl	.proc
; statements
	;	src line: library:/prog8lib/c64/textio.p8:22
	lda  #$8d
	jmp  txt.chrout
	;	src line: library:/prog8lib/c64/textio.p8:21
; variables

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:25

spc	.proc
; statements
	;	src line: library:/prog8lib/c64/textio.p8:26
	lda  #$20
	jmp  txt.chrout
	;	src line: library:/prog8lib/c64/textio.p8:25
; variables

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:29

column	.proc
	;	src line: library:/prog8lib/c64/textio.p8:31
        sec
        jsr  c64.PLOT
        tay
        clc
        jmp  c64.PLOT
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:40

fill_screen	.proc
	;	src line: library:/prog8lib/c64/textio.p8:44
		pha
		tya
		jsr  clear_screencolors
		pla
		jmp  clear_screenchars
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:55

clear_screenchars	.proc
	;	src line: library:/prog8lib/c64/textio.p8:58
		ldy  #250
-		sta  c64.Screen+250*0-1,y
		sta  c64.Screen+250*1-1,y
		sta  c64.Screen+250*2-1,y
		sta  c64.Screen+250*3-1,y
		dey
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:70

clear_screencolors	.proc
	;	src line: library:/prog8lib/c64/textio.p8:73
		ldy  #250
-		sta  c64.Colors+250*0-1,y
		sta  c64.Colors+250*1-1,y
		sta  c64.Colors+250*2-1,y
		sta  c64.Colors+250*3-1,y
		dey
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:97

scroll_left	.proc
	;	src line: library:/prog8lib/c64/textio.p8:102
		stx  P8ZP_SCRATCH_REG
		bcc _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 1,x
            sta  c64.Screen + 40*row + 0,x
            lda  c64.Colors + 40*row + 1,x
            sta  c64.Colors + 40*row + 0,x
        .next
		inx
		dey
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 1,x
            sta  c64.Screen + 40*row + 0,x
        .next
		inx
		dey
		bpl  -

		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:138

scroll_right	.proc
	;	src line: library:/prog8lib/c64/textio.p8:142
		stx  P8ZP_SCRATCH_REG
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 0,x
            sta  c64.Screen + 40*row + 1,x
            lda  c64.Colors + 40*row + 0,x
            sta  c64.Colors + 40*row + 1,x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 0,x
            sta  c64.Screen + 40*row + 1,x
        .next
		dex
		bpl  -

		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:174

scroll_up	.proc
	;	src line: library:/prog8lib/c64/textio.p8:178
		stx  P8ZP_SCRATCH_REG
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row-1),x
            lda  c64.Colors + 40*row,x
            sta  c64.Colors + 40*(row-1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row-1),x
        .next
		dex
		bpl  -

		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:210

scroll_down	.proc
	;	src line: library:/prog8lib/c64/textio.p8:214
		stx  P8ZP_SCRATCH_REG
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  c64.Colors + 40*row,x
            sta  c64.Colors + 40*(row+1),x
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row+1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row+1),x
        .next
		dex
		bpl  -

		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:246

	;	src line: library:/prog8lib/c64/textio.p8:248

print	.proc
	;	src line: library:/prog8lib/c64/textio.p8:253
		sta  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		ldy  #0
-		lda  (P8ZP_SCRATCH_B1),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:266

print_ub0	.proc
	;	src line: library:/prog8lib/c64/textio.p8:268
		stx  P8ZP_SCRATCH_REG
		jsr  conv.ubyte2decimal
		pha
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:283

print_ub	.proc
	;	src line: library:/prog8lib/c64/textio.p8:285
		stx  P8ZP_SCRATCH_REG
		jsr  conv.ubyte2decimal
_print_byte_digits
		pha
		cpy  #'0'
		beq  +
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		jmp  _ones
+       pla
        cmp  #'0'
        beq  _ones
        jsr  c64.CHROUT
_ones   txa
		jsr  c64.CHROUT
		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:308

print_b	.proc
	;	src line: library:/prog8lib/c64/textio.p8:310
		stx  P8ZP_SCRATCH_REG
		pha
		cmp  #0
		bpl  +
		lda  #'-'
		jsr  c64.CHROUT
+		pla
		jsr  conv.byte2decimal
		jmp  print_ub._print_byte_digits
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:323

print_ubhex	.proc
	;	src line: library:/prog8lib/c64/textio.p8:325
		stx  P8ZP_SCRATCH_REG
		bcc  +
		pha
		lda  #'$'
		jsr  c64.CHROUT
		pla
+		jsr  conv.ubyte2hex
		jsr  c64.CHROUT
		tya
		jsr  c64.CHROUT
		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:341

print_ubbin	.proc
	;	src line: library:/prog8lib/c64/textio.p8:343
		stx  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'%'
		jsr  c64.CHROUT
+		ldy  #8
-		lda  #'0'
		asl  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'1'
+		jsr  c64.CHROUT
		dey
		bne  -
		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:362

print_uwbin	.proc
	;	src line: library:/prog8lib/c64/textio.p8:364
		pha
		tya
		jsr  print_ubbin
		pla
		clc
		jmp  print_ubbin
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:374

print_uwhex	.proc
	;	src line: library:/prog8lib/c64/textio.p8:377
		pha
		tya
		jsr  print_ubhex
		pla
		clc
		jmp  print_ubhex
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:387

print_uw0	.proc
	;	src line: library:/prog8lib/c64/textio.p8:389
	    stx  P8ZP_SCRATCH_REG
		jsr  conv.uword2decimal
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
        beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:403

print_uw	.proc
	;	src line: library:/prog8lib/c64/textio.p8:405
	    stx  P8ZP_SCRATCH_REG
		jsr  conv.uword2decimal
		ldx  P8ZP_SCRATCH_REG
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
		beq  _allzero
		cmp  #'0'
		bne  _gotdigit
		iny
		bne  -

_gotdigit
		jsr  c64.CHROUT
		iny
		lda  conv.uword2decimal.decTenThousands,y
		bne  _gotdigit
		rts
_allzero
        lda  #'0'
        jmp  c64.CHROUT
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:429

print_w	.proc
	;	src line: library:/prog8lib/c64/textio.p8:431
		cpy  #0
		bpl  +
		pha
		lda  #'-'
		jsr  c64.CHROUT
		tya
		eor  #255
		tay
		pla
		eor  #255
		clc
		adc  #1
		bcc  +
		iny
+		jmp  print_uw
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:450

input_chars	.proc
	;	src line: library:/prog8lib/c64/textio.p8:454
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0				; char counter = 0
-		jsr  c64.CHRIN
		cmp  #$0d			; return (ascii 13) pressed?
		beq  +				; yes, end.
		sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
		iny
		bne  -
+		lda  #0
		sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:471

setchr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:473
		pha
		tya
		asl  a
		tay
		lda  _screenrows+1,y
		sta  _mod+2
		txa
		clc
		adc  _screenrows,y
		sta  _mod+1
		bcc  +
		inc  _mod+2
+		pla
_mod		sta  $ffff		; modified
		rts

_screenrows	.word  $0400 + range(0, 1000, 40)
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:494

getchr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:496
		pha
		tya
		asl  a
		tay
		lda  setchr._screenrows+1,y
		sta  _mod+2
		pla
		clc
		adc  setchr._screenrows,y
		sta  _mod+1
		bcc  _mod
		inc  _mod+2
_mod		lda  $ffff		; modified
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:514

setclr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:516
		pha
		tya
		asl  a
		tay
		lda  _colorrows+1,y
		sta  _mod+2
		txa
		clc
		adc  _colorrows,y
		sta  _mod+1
		bcc  +
		inc  _mod+2
+		pla
_mod		sta  $ffff		; modified
		rts

_colorrows	.word  $d800 + range(0, 1000, 40)
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:537

getclr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:539
		pha
		tya
		asl  a
		tay
		lda  setclr._colorrows+1,y
		sta  _mod+2
		pla
		clc
		adc  setclr._colorrows,y
		sta  _mod+1
		bcc  _mod
		inc  _mod+2
_mod		lda  $ffff		; modified
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:583

plot	.proc
	;	src line: library:/prog8lib/c64/textio.p8:585
		stx  P8ZP_SCRATCH_REG
		tax
		clc
		jsr  c64.PLOT
		ldx  P8ZP_SCRATCH_REG
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:595

width	.proc
	;	src line: library:/prog8lib/c64/textio.p8:597
        jsr  c64.SCREEN
        txa
        rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:604

height	.proc
	;	src line: library:/prog8lib/c64/textio.p8:606
        jsr  c64.SCREEN
        tya
        rts
	.pend
	.pend

; ---- block: 'c64' ----
c64	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:4
	TIME_HI = $a0
	TIME_MID = $a1
	TIME_LO = $a2
	STATUS = $90
	STKEY = $91
	SFDX = $cb
	COLOR = $0286
	HIBASE = $0288
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	SPRPTR0 = $07f8
	SPRPTR1 = $07f9
	SPRPTR2 = $07fa
	SPRPTR3 = $07fb
	SPRPTR4 = $07fc
	SPRPTR5 = $07fd
	SPRPTR6 = $07fe
	SPRPTR7 = $07ff
	SPRPTR = $07f8
	SP0X = $d000
	SP0Y = $d001
	SP1X = $d002
	SP1Y = $d003
	SP2X = $d004
	SP2Y = $d005
	SP3X = $d006
	SP3Y = $d007
	SP4X = $d008
	SP4Y = $d009
	SP5X = $d00a
	SP5Y = $d00b
	SP6X = $d00c
	SP6Y = $d00d
	SP7X = $d00e
	SP7Y = $d00f
	SPXY = $d000
	SPXYW = $d000
	MSIGX = $d010
	SCROLY = $d011
	RASTER = $d012
	LPENX = $d013
	LPENY = $d014
	SPENA = $d015
	SCROLX = $d016
	YXPAND = $d017
	VMCSB = $d018
	VICIRQ = $d019
	IREQMASK = $d01a
	SPBGPR = $d01b
	SPMC = $d01c
	XXPAND = $d01d
	SPSPCL = $d01e
	SPBGCL = $d01f
	EXTCOL = $d020
	BGCOL0 = $d021
	BGCOL1 = $d022
	BGCOL2 = $d023
	BGCOL4 = $d024
	SPMC0 = $d025
	SPMC1 = $d026
	SP0COL = $d027
	SP1COL = $d028
	SP2COL = $d029
	SP3COL = $d02a
	SP4COL = $d02b
	SP5COL = $d02c
	SP6COL = $d02d
	SP7COL = $d02e
	SPCOL = $d027
	CIA1PRA = $dc00
	CIA1PRB = $dc01
	CIA1DDRA = $dc02
	CIA1DDRB = $dc03
	CIA1TAL = $dc04
	CIA1TAH = $dc05
	CIA1TBL = $dc06
	CIA1TBH = $dc07
	CIA1TOD10 = $dc08
	CIA1TODSEC = $dc09
	CIA1TODMMIN = $dc0a
	CIA1TODHR = $dc0b
	CIA1SDR = $dc0c
	CIA1ICR = $dc0d
	CIA1CRA = $dc0e
	CIA1CRB = $dc0f
	CIA2PRA = $dd00
	CIA2PRB = $dd01
	CIA2DDRA = $dd02
	CIA2DDRB = $dd03
	CIA2TAL = $dd04
	CIA2TAH = $dd05
	CIA2TBL = $dd06
	CIA2TBH = $dd07
	CIA2TOD10 = $dd08
	CIA2TODSEC = $dd09
	CIA2TODMIN = $dd0a
	CIA2TODHR = $dd0b
	CIA2SDR = $dd0c
	CIA2ICR = $dd0d
	CIA2CRA = $dd0e
	CIA2CRB = $dd0f
	FREQLO1 = $d400
	FREQHI1 = $d401
	FREQ1 = $d400
	PWLO1 = $d402
	PWHI1 = $d403
	PW1 = $d402
	CR1 = $d404
	AD1 = $d405
	SR1 = $d406
	FREQLO2 = $d407
	FREQHI2 = $d408
	FREQ2 = $d407
	PWLO2 = $d409
	PWHI2 = $d40a
	PW2 = $d409
	CR2 = $d40b
	AD2 = $d40c
	SR2 = $d40d
	FREQLO3 = $d40e
	FREQHI3 = $d40f
	FREQ3 = $d40e
	PWLO3 = $d410
	PWHI3 = $d411
	PW3 = $d410
	CR3 = $d412
	AD3 = $d413
	SR3 = $d414
	FCLO = $d415
	FCHI = $d416
	FC = $d415
	RESFILT = $d417
	MVOL = $d418
	POTX = $d419
	POTY = $d41a
	OSC3 = $d41b
	ENV3 = $d41c
	Screen = $0400
	Colors = $d800

; non-zeropage variables
	STROUT = $ab1e
	CLEARSCR = $e544
	HOMECRSR = $e566
	IRQDFRT = $ea31
	IRQDFEND = $ea81
	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3

; subroutines in this block
	;	src line: library:/prog8lib/c64/syslib.p8:5
	;	src line: library:/prog8lib/c64/syslib.p8:6
	;	src line: library:/prog8lib/c64/syslib.p8:7
	;	src line: library:/prog8lib/c64/syslib.p8:8
	;	src line: library:/prog8lib/c64/syslib.p8:9
	;	src line: library:/prog8lib/c64/syslib.p8:10
	;	src line: library:/prog8lib/c64/syslib.p8:12
	;	src line: library:/prog8lib/c64/syslib.p8:13
	;	src line: library:/prog8lib/c64/syslib.p8:14
	;	src line: library:/prog8lib/c64/syslib.p8:15
	;	src line: library:/prog8lib/c64/syslib.p8:16
	;	src line: library:/prog8lib/c64/syslib.p8:17
	;	src line: library:/prog8lib/c64/syslib.p8:18
	;	src line: library:/prog8lib/c64/syslib.p8:19
	;	src line: library:/prog8lib/c64/syslib.p8:22
	;	src line: library:/prog8lib/c64/syslib.p8:23
	;	src line: library:/prog8lib/c64/syslib.p8:26
	;	src line: library:/prog8lib/c64/syslib.p8:27
	;	src line: library:/prog8lib/c64/syslib.p8:28
	;	src line: library:/prog8lib/c64/syslib.p8:29
	;	src line: library:/prog8lib/c64/syslib.p8:30
	;	src line: library:/prog8lib/c64/syslib.p8:31
	;	src line: library:/prog8lib/c64/syslib.p8:32
	;	src line: library:/prog8lib/c64/syslib.p8:33
	;	src line: library:/prog8lib/c64/syslib.p8:34
	;	src line: library:/prog8lib/c64/syslib.p8:39
	;	src line: library:/prog8lib/c64/syslib.p8:40
	;	src line: library:/prog8lib/c64/syslib.p8:41
	;	src line: library:/prog8lib/c64/syslib.p8:42
	;	src line: library:/prog8lib/c64/syslib.p8:43
	;	src line: library:/prog8lib/c64/syslib.p8:44
	;	src line: library:/prog8lib/c64/syslib.p8:45
	;	src line: library:/prog8lib/c64/syslib.p8:46
	;	src line: library:/prog8lib/c64/syslib.p8:47
	;	src line: library:/prog8lib/c64/syslib.p8:48
	;	src line: library:/prog8lib/c64/syslib.p8:49
	;	src line: library:/prog8lib/c64/syslib.p8:50
	;	src line: library:/prog8lib/c64/syslib.p8:51
	;	src line: library:/prog8lib/c64/syslib.p8:52
	;	src line: library:/prog8lib/c64/syslib.p8:53
	;	src line: library:/prog8lib/c64/syslib.p8:54
	;	src line: library:/prog8lib/c64/syslib.p8:55
	;	src line: library:/prog8lib/c64/syslib.p8:56
	;	src line: library:/prog8lib/c64/syslib.p8:58
	;	src line: library:/prog8lib/c64/syslib.p8:59
	;	src line: library:/prog8lib/c64/syslib.p8:60
	;	src line: library:/prog8lib/c64/syslib.p8:61
	;	src line: library:/prog8lib/c64/syslib.p8:62
	;	src line: library:/prog8lib/c64/syslib.p8:63
	;	src line: library:/prog8lib/c64/syslib.p8:64
	;	src line: library:/prog8lib/c64/syslib.p8:65
	;	src line: library:/prog8lib/c64/syslib.p8:66
	;	src line: library:/prog8lib/c64/syslib.p8:67
	;	src line: library:/prog8lib/c64/syslib.p8:68
	;	src line: library:/prog8lib/c64/syslib.p8:69
	;	src line: library:/prog8lib/c64/syslib.p8:70
	;	src line: library:/prog8lib/c64/syslib.p8:71
	;	src line: library:/prog8lib/c64/syslib.p8:72
	;	src line: library:/prog8lib/c64/syslib.p8:73
	;	src line: library:/prog8lib/c64/syslib.p8:75
	;	src line: library:/prog8lib/c64/syslib.p8:76
	;	src line: library:/prog8lib/c64/syslib.p8:77
	;	src line: library:/prog8lib/c64/syslib.p8:78
	;	src line: library:/prog8lib/c64/syslib.p8:79
	;	src line: library:/prog8lib/c64/syslib.p8:80
	;	src line: library:/prog8lib/c64/syslib.p8:81
	;	src line: library:/prog8lib/c64/syslib.p8:82
	;	src line: library:/prog8lib/c64/syslib.p8:83
	;	src line: library:/prog8lib/c64/syslib.p8:84
	;	src line: library:/prog8lib/c64/syslib.p8:85
	;	src line: library:/prog8lib/c64/syslib.p8:86
	;	src line: library:/prog8lib/c64/syslib.p8:87
	;	src line: library:/prog8lib/c64/syslib.p8:88
	;	src line: library:/prog8lib/c64/syslib.p8:89
	;	src line: library:/prog8lib/c64/syslib.p8:90
	;	src line: library:/prog8lib/c64/syslib.p8:97
	;	src line: library:/prog8lib/c64/syslib.p8:98
	;	src line: library:/prog8lib/c64/syslib.p8:99
	;	src line: library:/prog8lib/c64/syslib.p8:100
	;	src line: library:/prog8lib/c64/syslib.p8:101
	;	src line: library:/prog8lib/c64/syslib.p8:102
	;	src line: library:/prog8lib/c64/syslib.p8:103
	;	src line: library:/prog8lib/c64/syslib.p8:104
	;	src line: library:/prog8lib/c64/syslib.p8:105
	;	src line: library:/prog8lib/c64/syslib.p8:106
	;	src line: library:/prog8lib/c64/syslib.p8:107
	;	src line: library:/prog8lib/c64/syslib.p8:108
	;	src line: library:/prog8lib/c64/syslib.p8:109
	;	src line: library:/prog8lib/c64/syslib.p8:110
	;	src line: library:/prog8lib/c64/syslib.p8:111
	;	src line: library:/prog8lib/c64/syslib.p8:112
	;	src line: library:/prog8lib/c64/syslib.p8:114
	;	src line: library:/prog8lib/c64/syslib.p8:115
	;	src line: library:/prog8lib/c64/syslib.p8:116
	;	src line: library:/prog8lib/c64/syslib.p8:117
	;	src line: library:/prog8lib/c64/syslib.p8:118
	;	src line: library:/prog8lib/c64/syslib.p8:119
	;	src line: library:/prog8lib/c64/syslib.p8:120
	;	src line: library:/prog8lib/c64/syslib.p8:121
	;	src line: library:/prog8lib/c64/syslib.p8:122
	;	src line: library:/prog8lib/c64/syslib.p8:123
	;	src line: library:/prog8lib/c64/syslib.p8:124
	;	src line: library:/prog8lib/c64/syslib.p8:125
	;	src line: library:/prog8lib/c64/syslib.p8:126
	;	src line: library:/prog8lib/c64/syslib.p8:127
	;	src line: library:/prog8lib/c64/syslib.p8:128
	;	src line: library:/prog8lib/c64/syslib.p8:129
	;	src line: library:/prog8lib/c64/syslib.p8:135
	;	src line: library:/prog8lib/c64/syslib.p8:136
	;	src line: library:/prog8lib/c64/syslib.p8:137
	;	src line: library:/prog8lib/c64/syslib.p8:138
	;	src line: library:/prog8lib/c64/syslib.p8:139
	;	src line: library:/prog8lib/c64/syslib.p8:140
	;	src line: library:/prog8lib/c64/syslib.p8:141
	;	src line: library:/prog8lib/c64/syslib.p8:142
	;	src line: library:/prog8lib/c64/syslib.p8:143
	;	src line: library:/prog8lib/c64/syslib.p8:144
	;	src line: library:/prog8lib/c64/syslib.p8:145
	;	src line: library:/prog8lib/c64/syslib.p8:146
	;	src line: library:/prog8lib/c64/syslib.p8:147
	;	src line: library:/prog8lib/c64/syslib.p8:148
	;	src line: library:/prog8lib/c64/syslib.p8:149
	;	src line: library:/prog8lib/c64/syslib.p8:150
	;	src line: library:/prog8lib/c64/syslib.p8:151
	;	src line: library:/prog8lib/c64/syslib.p8:152
	;	src line: library:/prog8lib/c64/syslib.p8:153
	;	src line: library:/prog8lib/c64/syslib.p8:154
	;	src line: library:/prog8lib/c64/syslib.p8:155
	;	src line: library:/prog8lib/c64/syslib.p8:156
	;	src line: library:/prog8lib/c64/syslib.p8:157
	;	src line: library:/prog8lib/c64/syslib.p8:158
	;	src line: library:/prog8lib/c64/syslib.p8:159
	;	src line: library:/prog8lib/c64/syslib.p8:160
	;	src line: library:/prog8lib/c64/syslib.p8:161
	;	src line: library:/prog8lib/c64/syslib.p8:162
	;	src line: library:/prog8lib/c64/syslib.p8:163
	;	src line: library:/prog8lib/c64/syslib.p8:164
	;	src line: library:/prog8lib/c64/syslib.p8:165
	;	src line: library:/prog8lib/c64/syslib.p8:166
	;	src line: library:/prog8lib/c64/syslib.p8:167
	;	src line: library:/prog8lib/c64/syslib.p8:168
	;	src line: library:/prog8lib/c64/syslib.p8:169
	;	src line: library:/prog8lib/c64/syslib.p8:170
	;	src line: library:/prog8lib/c64/syslib.p8:177

	;	src line: library:/prog8lib/c64/syslib.p8:178

	;	src line: library:/prog8lib/c64/syslib.p8:179

	;	src line: library:/prog8lib/c64/syslib.p8:180

	;	src line: library:/prog8lib/c64/syslib.p8:181

	;	src line: library:/prog8lib/c64/syslib.p8:182

	;	src line: library:/prog8lib/c64/syslib.p8:183

	;	src line: library:/prog8lib/c64/syslib.p8:184

	;	src line: library:/prog8lib/c64/syslib.p8:185

	;	src line: library:/prog8lib/c64/syslib.p8:186

	;	src line: library:/prog8lib/c64/syslib.p8:187

	;	src line: library:/prog8lib/c64/syslib.p8:188

	;	src line: library:/prog8lib/c64/syslib.p8:189

	;	src line: library:/prog8lib/c64/syslib.p8:190

	;	src line: library:/prog8lib/c64/syslib.p8:191

	;	src line: library:/prog8lib/c64/syslib.p8:192

	;	src line: library:/prog8lib/c64/syslib.p8:193

	;	src line: library:/prog8lib/c64/syslib.p8:194

	;	src line: library:/prog8lib/c64/syslib.p8:195

	;	src line: library:/prog8lib/c64/syslib.p8:196

	;	src line: library:/prog8lib/c64/syslib.p8:197

	;	src line: library:/prog8lib/c64/syslib.p8:198

	;	src line: library:/prog8lib/c64/syslib.p8:199

	;	src line: library:/prog8lib/c64/syslib.p8:200

	;	src line: library:/prog8lib/c64/syslib.p8:201

	;	src line: library:/prog8lib/c64/syslib.p8:202

	;	src line: library:/prog8lib/c64/syslib.p8:203

	;	src line: library:/prog8lib/c64/syslib.p8:204

	;	src line: library:/prog8lib/c64/syslib.p8:205

	;	src line: library:/prog8lib/c64/syslib.p8:206

	;	src line: library:/prog8lib/c64/syslib.p8:207

	;	src line: library:/prog8lib/c64/syslib.p8:208

	;	src line: library:/prog8lib/c64/syslib.p8:209

	;	src line: library:/prog8lib/c64/syslib.p8:210

	;	src line: library:/prog8lib/c64/syslib.p8:211

	;	src line: library:/prog8lib/c64/syslib.p8:212

	;	src line: library:/prog8lib/c64/syslib.p8:213

	;	src line: library:/prog8lib/c64/syslib.p8:214

	;	src line: library:/prog8lib/c64/syslib.p8:215

	;	src line: library:/prog8lib/c64/syslib.p8:216

	;	src line: library:/prog8lib/c64/syslib.p8:217

	;	src line: library:/prog8lib/c64/syslib.p8:218

	;	src line: library:/prog8lib/c64/syslib.p8:219

	;	src line: library:/prog8lib/c64/syslib.p8:220

	;	src line: library:/prog8lib/c64/syslib.p8:226

STOP2	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:228
        txa
        pha
        jsr  c64.STOP
        beq  +
        pla
        tax
        lda  #0
        rts
+       pla
        tax
        lda  #1
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:244

RDTIM16	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:246
        stx  P8ZP_SCRATCH_REG
        jsr  c64.RDTIM
        pha
        txa
        tay
        pla
        ldx  P8ZP_SCRATCH_REG
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:262

init_system	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:269
        sei
        cld
        lda  #%00101111
        sta  $00
        lda  #%00100111
        sta  $01
        jsr  c64.IOINIT
        jsr  c64.RESTOR
        jsr  c64.CINT
        lda  #6
        sta  c64.EXTCOL
        lda  #7
        sta  c64.COLOR
        lda  #0
        sta  c64.BGCOL0
        jsr  disable_runstop_and_charsetswitch
        clc
        clv
        cli
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:293

init_system_phase2	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:294
        rts     ; no phase 2 steps on the C64
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:299

cleanup_at_exit	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:301
        jmp  c64.enable_runstop_and_charsetswitch
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:306

disable_runstop_and_charsetswitch	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:307
        lda  #$80
        sta  657    ; disable charset switching
        lda  #239
        sta  808    ; disable run/stop key
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:316

enable_runstop_and_charsetswitch	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:317
        lda  #0
        sta  657    ; enable charset switching
        lda  #237
        sta  808    ; enable run/stop key
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:326

set_irq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:327
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        adc  #0
	        sta  _use_kernal
		sei
		lda  #<_irq_handler
		sta  c64.CINV
		lda  #>_irq_handler
		sta  c64.CINV+1
		cli
		rts
_irq_handler    jsr  _irq_handler_init
_modified	jsr  $ffff                      ; modified
		jsr  _irq_handler_end
		lda  _use_kernal
		bne  +
		lda  #$ff
		sta  c64.VICIRQ			; acknowledge raster irq
		lda  c64.CIA1ICR		; acknowledge CIA1 interrupt
		; end irq processing - don't use kernal's irq handling
		pla
		tay
		pla
		tax
		pla
		rti
+		jmp  c64.IRQDFRT		; continue with normal kernal irq routine

_use_kernal     .byte  0

_irq_handler_init
		; save all zp scratch registers and the X register as these might be clobbered by the irq routine
		stx  IRQ_X_REG
		lda  P8ZP_SCRATCH_B1
		sta  IRQ_SCRATCH_ZPB1
		lda  P8ZP_SCRATCH_REG
		sta  IRQ_SCRATCH_ZPREG
		lda  P8ZP_SCRATCH_W1
		sta  IRQ_SCRATCH_ZPWORD1
		lda  P8ZP_SCRATCH_W1+1
		sta  IRQ_SCRATCH_ZPWORD1+1
		lda  P8ZP_SCRATCH_W2
		sta  IRQ_SCRATCH_ZPWORD2
		lda  P8ZP_SCRATCH_W2+1
		sta  IRQ_SCRATCH_ZPWORD2+1
		; stack protector; make sure we don't clobber the top of the evaluation stack
		dex
		dex
		dex
		dex
		dex
		dex
		cld
		rts

_irq_handler_end
		; restore all zp scratch registers and the X register
		lda  IRQ_SCRATCH_ZPB1
		sta  P8ZP_SCRATCH_B1
		lda  IRQ_SCRATCH_ZPREG
		sta  P8ZP_SCRATCH_REG
		lda  IRQ_SCRATCH_ZPWORD1
		sta  P8ZP_SCRATCH_W1
		lda  IRQ_SCRATCH_ZPWORD1+1
		sta  P8ZP_SCRATCH_W1+1
		lda  IRQ_SCRATCH_ZPWORD2
		sta  P8ZP_SCRATCH_W2
		lda  IRQ_SCRATCH_ZPWORD2+1
		sta  P8ZP_SCRATCH_W2+1
		ldx  IRQ_X_REG
		rts

IRQ_X_REG		.byte  0
IRQ_SCRATCH_ZPB1	.byte  0
IRQ_SCRATCH_ZPREG	.byte  0
IRQ_SCRATCH_ZPWORD1	.word  0
IRQ_SCRATCH_ZPWORD2	.word  0
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:410

restore_irq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:411
		sei
		lda  #<c64.IRQDFRT
		sta  c64.CINV
		lda  #>c64.IRQDFRT
		sta  c64.CINV+1
		lda  #0
		sta  c64.IREQMASK	; disable raster irq
		lda  #%10000001
		sta  c64.CIA1ICR	; restore CIA1 irq
		cli
		rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:426

set_rasterirq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:427
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        adc  #0
	        sta  set_irq._use_kernal
		lda  cx16.r0
		ldy  cx16.r0+1
		sei
		jsr  _setup_raster_irq
		lda  #<_raster_irq_handler
		sta  c64.CINV
		lda  #>_raster_irq_handler
		sta  c64.CINV+1
		cli
		rts

_raster_irq_handler
		jsr  set_irq._irq_handler_init
_modified	jsr  $ffff              ; modified
		jsr  set_irq._irq_handler_end
                lda  #$ff
                sta  c64.VICIRQ			; acknowledge raster irq
		lda  set_irq._use_kernal
		bne  +
		; end irq processing - don't use kernal's irq handling
		pla
		tay
		pla
		tax
		pla
		rti
+		jmp  c64.IRQDFRT                ; continue with kernal irq routine

_setup_raster_irq
		pha
		lda  #%01111111
		sta  c64.CIA1ICR    ; "switch off" interrupts signals from cia-1
		sta  c64.CIA2ICR    ; "switch off" interrupts signals from cia-2
		and  c64.SCROLY
		sta  c64.SCROLY     ; clear most significant bit of raster position
		lda  c64.CIA1ICR    ; ack previous irq
		lda  c64.CIA2ICR    ; ack previous irq
		pla
		sta  c64.RASTER     ; set the raster line number where interrupt should occur
		cpy  #0
		beq  +
		lda  c64.SCROLY
		ora  #%10000000
		sta  c64.SCROLY     ; set most significant bit of raster position
+		lda  #%00000001
		sta  c64.IREQMASK   ;enable raster interrupt signals from vic
		rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:487
	target = $40

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/c64/syslib.p8:490
	;	src line: library:/prog8lib/c64/syslib.p8:493

reset_system	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:495
            sei
            lda  #14
            sta  $01        ; bank the kernal in
            jmp  (c64.RESET_VEC)
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:514

waitvsync	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:517
-           bit  c64.SCROLY
            bpl  -
-           bit  c64.SCROLY
            bmi  -
            rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:526
	;	src line: library:/prog8lib/c64/syslib.p8:535

internal_stringcopy	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:537
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:546

memcopy	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:549
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1        ; source in ZP
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2        ; target in ZP
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            ; decrease source and target pointers so we can simply index by Y
            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            lda  P8ZP_SCRATCH_W2
            bne  +
            dec  P8ZP_SCRATCH_W2+1
+           dec  P8ZP_SCRATCH_W2

-           lda  (P8ZP_SCRATCH_W1),y
            sta  (P8ZP_SCRATCH_W2),y
            dey
            bne  -
            rts

_longcopy
            sta  P8ZP_SCRATCH_B1        ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            sta  (P8ZP_SCRATCH_W2),y
            iny
            bne  -
            inc  P8ZP_SCRATCH_W1+1
            inc  P8ZP_SCRATCH_W2+1
            dex
            bne  -
            ldy  P8ZP_SCRATCH_B1
            bne  _copyshort
            rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:602

memset	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:603
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:614

memsetw	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:615
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:628
	;	src line: library:/prog8lib/c64/syslib.p8:635
	;	src line: library:/prog8lib/c64/syslib.p8:641
	;	src line: library:/prog8lib/c64/syslib.p8:647
	;	src line: library:/prog8lib/c64/syslib.p8:653
	;	src line: library:/prog8lib/c64/syslib.p8:659
	;	src line: library:/prog8lib/c64/syslib.p8:672
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:681
	r0 = $cf00
	r1 = $cf02
	r2 = $cf04
	r3 = $cf06
	r4 = $cf08
	r5 = $cf0a
	r6 = $cf0c
	r7 = $cf0e
	r8 = $cf10
	r9 = $cf12
	r10 = $cf14
	r11 = $cf16
	r12 = $cf18
	r13 = $cf1a
	r14 = $cf1c
	r15 = $cf1e
	r0s = $cf00
	r1s = $cf02
	r2s = $cf04
	r3s = $cf06
	r4s = $cf08
	r5s = $cf0a
	r6s = $cf0c
	r7s = $cf0e
	r8s = $cf10
	r9s = $cf12
	r10s = $cf14
	r11s = $cf16
	r12s = $cf18
	r13s = $cf1a
	r14s = $cf1c
	r15s = $cf1e
	r0L = $cf00
	r1L = $cf02
	r2L = $cf04
	r3L = $cf06
	r4L = $cf08
	r5L = $cf0a
	r6L = $cf0c
	r7L = $cf0e
	r8L = $cf10
	r9L = $cf12
	r10L = $cf14
	r11L = $cf16
	r12L = $cf18
	r13L = $cf1a
	r14L = $cf1c
	r15L = $cf1e
	r0H = $cf01
	r1H = $cf03
	r2H = $cf05
	r3H = $cf07
	r4H = $cf09
	r5H = $cf0b
	r6H = $cf0d
	r7H = $cf0f
	r8H = $cf11
	r9H = $cf13
	r10H = $cf15
	r11H = $cf17
	r12H = $cf19
	r13H = $cf1b
	r14H = $cf1d
	r15H = $cf1f
	r0sL = $cf00
	r1sL = $cf02
	r2sL = $cf04
	r3sL = $cf06
	r4sL = $cf08
	r5sL = $cf0a
	r6sL = $cf0c
	r7sL = $cf0e
	r8sL = $cf10
	r9sL = $cf12
	r10sL = $cf14
	r11sL = $cf16
	r12sL = $cf18
	r13sL = $cf1a
	r14sL = $cf1c
	r15sL = $cf1e
	r0sH = $cf01
	r1sH = $cf03
	r2sH = $cf05
	r3sH = $cf07
	r4sH = $cf09
	r5sH = $cf0b
	r6sH = $cf0d
	r7sH = $cf0f
	r8sH = $cf11
	r9sH = $cf13
	r10sH = $cf15
	r11sH = $cf17
	r12sH = $cf19
	r13sH = $cf1b
	r14sH = $cf1d
	r15sH = $cf1f

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/c64/syslib.p8:689
	;	src line: library:/prog8lib/c64/syslib.p8:690
	;	src line: library:/prog8lib/c64/syslib.p8:691
	;	src line: library:/prog8lib/c64/syslib.p8:692
	;	src line: library:/prog8lib/c64/syslib.p8:693
	;	src line: library:/prog8lib/c64/syslib.p8:694
	;	src line: library:/prog8lib/c64/syslib.p8:695
	;	src line: library:/prog8lib/c64/syslib.p8:696
	;	src line: library:/prog8lib/c64/syslib.p8:697
	;	src line: library:/prog8lib/c64/syslib.p8:698
	;	src line: library:/prog8lib/c64/syslib.p8:699
	;	src line: library:/prog8lib/c64/syslib.p8:700
	;	src line: library:/prog8lib/c64/syslib.p8:701
	;	src line: library:/prog8lib/c64/syslib.p8:702
	;	src line: library:/prog8lib/c64/syslib.p8:703
	;	src line: library:/prog8lib/c64/syslib.p8:704
	;	src line: library:/prog8lib/c64/syslib.p8:706
	;	src line: library:/prog8lib/c64/syslib.p8:707
	;	src line: library:/prog8lib/c64/syslib.p8:708
	;	src line: library:/prog8lib/c64/syslib.p8:709
	;	src line: library:/prog8lib/c64/syslib.p8:710
	;	src line: library:/prog8lib/c64/syslib.p8:711
	;	src line: library:/prog8lib/c64/syslib.p8:712
	;	src line: library:/prog8lib/c64/syslib.p8:713
	;	src line: library:/prog8lib/c64/syslib.p8:714
	;	src line: library:/prog8lib/c64/syslib.p8:715
	;	src line: library:/prog8lib/c64/syslib.p8:716
	;	src line: library:/prog8lib/c64/syslib.p8:717
	;	src line: library:/prog8lib/c64/syslib.p8:718
	;	src line: library:/prog8lib/c64/syslib.p8:719
	;	src line: library:/prog8lib/c64/syslib.p8:720
	;	src line: library:/prog8lib/c64/syslib.p8:721
	;	src line: library:/prog8lib/c64/syslib.p8:723
	;	src line: library:/prog8lib/c64/syslib.p8:724
	;	src line: library:/prog8lib/c64/syslib.p8:725
	;	src line: library:/prog8lib/c64/syslib.p8:726
	;	src line: library:/prog8lib/c64/syslib.p8:727
	;	src line: library:/prog8lib/c64/syslib.p8:728
	;	src line: library:/prog8lib/c64/syslib.p8:729
	;	src line: library:/prog8lib/c64/syslib.p8:730
	;	src line: library:/prog8lib/c64/syslib.p8:731
	;	src line: library:/prog8lib/c64/syslib.p8:732
	;	src line: library:/prog8lib/c64/syslib.p8:733
	;	src line: library:/prog8lib/c64/syslib.p8:734
	;	src line: library:/prog8lib/c64/syslib.p8:735
	;	src line: library:/prog8lib/c64/syslib.p8:736
	;	src line: library:/prog8lib/c64/syslib.p8:737
	;	src line: library:/prog8lib/c64/syslib.p8:738
	;	src line: library:/prog8lib/c64/syslib.p8:740
	;	src line: library:/prog8lib/c64/syslib.p8:741
	;	src line: library:/prog8lib/c64/syslib.p8:742
	;	src line: library:/prog8lib/c64/syslib.p8:743
	;	src line: library:/prog8lib/c64/syslib.p8:744
	;	src line: library:/prog8lib/c64/syslib.p8:745
	;	src line: library:/prog8lib/c64/syslib.p8:746
	;	src line: library:/prog8lib/c64/syslib.p8:747
	;	src line: library:/prog8lib/c64/syslib.p8:748
	;	src line: library:/prog8lib/c64/syslib.p8:749
	;	src line: library:/prog8lib/c64/syslib.p8:750
	;	src line: library:/prog8lib/c64/syslib.p8:751
	;	src line: library:/prog8lib/c64/syslib.p8:752
	;	src line: library:/prog8lib/c64/syslib.p8:753
	;	src line: library:/prog8lib/c64/syslib.p8:754
	;	src line: library:/prog8lib/c64/syslib.p8:755
	;	src line: library:/prog8lib/c64/syslib.p8:757
	;	src line: library:/prog8lib/c64/syslib.p8:758
	;	src line: library:/prog8lib/c64/syslib.p8:759
	;	src line: library:/prog8lib/c64/syslib.p8:760
	;	src line: library:/prog8lib/c64/syslib.p8:761
	;	src line: library:/prog8lib/c64/syslib.p8:762
	;	src line: library:/prog8lib/c64/syslib.p8:763
	;	src line: library:/prog8lib/c64/syslib.p8:764
	;	src line: library:/prog8lib/c64/syslib.p8:765
	;	src line: library:/prog8lib/c64/syslib.p8:766
	;	src line: library:/prog8lib/c64/syslib.p8:767
	;	src line: library:/prog8lib/c64/syslib.p8:768
	;	src line: library:/prog8lib/c64/syslib.p8:769
	;	src line: library:/prog8lib/c64/syslib.p8:770
	;	src line: library:/prog8lib/c64/syslib.p8:771
	;	src line: library:/prog8lib/c64/syslib.p8:772
	;	src line: library:/prog8lib/c64/syslib.p8:774
	;	src line: library:/prog8lib/c64/syslib.p8:775
	;	src line: library:/prog8lib/c64/syslib.p8:776
	;	src line: library:/prog8lib/c64/syslib.p8:777
	;	src line: library:/prog8lib/c64/syslib.p8:778
	;	src line: library:/prog8lib/c64/syslib.p8:779
	;	src line: library:/prog8lib/c64/syslib.p8:780
	;	src line: library:/prog8lib/c64/syslib.p8:781
	;	src line: library:/prog8lib/c64/syslib.p8:782
	;	src line: library:/prog8lib/c64/syslib.p8:783
	;	src line: library:/prog8lib/c64/syslib.p8:784
	;	src line: library:/prog8lib/c64/syslib.p8:785
	;	src line: library:/prog8lib/c64/syslib.p8:786
	;	src line: library:/prog8lib/c64/syslib.p8:787
	;	src line: library:/prog8lib/c64/syslib.p8:788
	;	src line: library:/prog8lib/c64/syslib.p8:789
	.pend

; ---- block: 'conv' ----
conv	.proc
	;	src line: library:/prog8lib/conv.p8:3

; non-zeropage variables
string_out	; PETSCII:"????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00

; subroutines in this block
	;	src line: library:/prog8lib/conv.p8:7
	;	src line: library:/prog8lib/conv.p8:9

str_ub0	.proc
	;	src line: library:/prog8lib/conv.p8:11
            stx  P8ZP_SCRATCH_REG
            jsr  conv.ubyte2decimal
            sty  string_out
            sta  string_out+1
            stx  string_out+2
            lda  #0
            sta  string_out+3
            ldx  P8ZP_SCRATCH_REG
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:24

str_ub	.proc
	;	src line: library:/prog8lib/conv.p8:26
		stx  P8ZP_SCRATCH_REG
		ldy  #0
		sty  P8ZP_SCRATCH_B1
		jsr  conv.ubyte2decimal
_output_byte_digits
                ; hundreds?
		cpy  #'0'
		beq  +
		pha
		tya
		ldy  P8ZP_SCRATCH_B1
		sta  string_out,y
		pla
		inc  P8ZP_SCRATCH_B1
		; tens?
+		ldy  P8ZP_SCRATCH_B1
                cmp  #'0'
		beq  +
		sta  string_out,y
		iny
+               ; ones.
                txa
                sta  string_out,y
                iny
                lda  #0
                sta  string_out,y
                ldx  P8ZP_SCRATCH_REG
                rts
	.pend
	;	src line: library:/prog8lib/conv.p8:58

str_b	.proc
	;	src line: library:/prog8lib/conv.p8:60
            stx  P8ZP_SCRATCH_REG
            ldy  #0
            sty  P8ZP_SCRATCH_B1
            cmp  #0
            bpl  +
            pha
            lda  #'-'
            sta  string_out
            inc  P8ZP_SCRATCH_B1
            pla
+	    jsr  conv.byte2decimal
            bra  str_ub._output_byte_digits
	.pend
	;	src line: library:/prog8lib/conv.p8:76

str_ubhex	.proc
	;	src line: library:/prog8lib/conv.p8:78
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            lda  #0
            sta  string_out+2
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:88

str_ubbin	.proc
	;	src line: library:/prog8lib/conv.p8:90
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:107

str_uwbin	.proc
	;	src line: library:/prog8lib/conv.p8:109
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out+8,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:128

str_uwhex	.proc
	;	src line: library:/prog8lib/conv.p8:130
            pha
            tya
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            pla
            jsr  conv.ubyte2hex
            sta  string_out+2
            sty  string_out+3
            lda  #0
            sta  string_out+4
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:146

str_uw0	.proc
	;	src line: library:/prog8lib/conv.p8:148
	    stx  P8ZP_SCRATCH_REG
	    jsr  conv.uword2decimal
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            sta  string_out,y
            beq  +
            iny
            bne  -
+           ldx  P8ZP_SCRATCH_REG
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:162

str_uw	.proc
	;	src line: library:/prog8lib/conv.p8:164
	    stx  P8ZP_SCRATCH_REG
	    jsr  conv.uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   sta  string_out,x
            inx
            iny
            lda  conv.uword2decimal.decTenThousands,y
            bne  _gotdigit
_end        lda  #0
            sta  string_out,x
            ldx  P8ZP_SCRATCH_REG
            rts

_allzero    lda  #'0'
            sta  string_out,x
            inx
            bne  _end
	.pend
	;	src line: library:/prog8lib/conv.p8:193

str_w	.proc
	;	src line: library:/prog8lib/conv.p8:195
	    cpy  #0
	    bpl  str_uw
	    stx  P8ZP_SCRATCH_REG
	    pha
	    lda  #'-'
	    sta  string_out
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+	    jsr  conv.uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	;	src line: ~dummy~:0
  rts
	.pend
	;	src line: library:/prog8lib/conv.p8:220





















                                        any2uword	.proc
                                            ;	src line: library:/prog8lib/conv.p8:226
                                            pha
                                            sta  P8ZP_SCRATCH_W1
                                            sty  P8ZP_SCRATCH_W1+1
                                            ldy  #0
                                            lda  (P8ZP_SCRATCH_W1),y
                                            ldy  P8ZP_SCRATCH_W1+1
                                            cmp  #'$'
                                            beq  _hex
                                            cmp  #'%'
                                            beq  _bin
                                            pla
                                            jsr  str2uword
                                            jmp  _result
                                        _hex	pla
                                            jsr  hex2uword
                                            jmp  _result
                                        _bin	pla
                                            jsr  bin2uword
                                        _result
                                                pha
                                                lda  cx16.r15
                                                sta  P8ZP_SCRATCH_B1        ; result value
                                                pla
                                                sta  cx16.r15
                                                sty  cx16.r15+1
                                                lda  P8ZP_SCRATCH_B1
                                                rts
                                            .pend
 

                                            str2uword	.proc
                                                ;	src line: library:/prog8lib/conv.p8:282
                                            _result = P8ZP_SCRATCH_W1
                                                        sta  P8ZP_SCRATCH_W2
                                                        sty  P8ZP_SCRATCH_W2+1
                                                    ldy  #0
                                                    sty  _result
                                                    sty  _result+1
                                                    sty  cx16.r15+1
                                            _loop
                                                    lda  (P8ZP_SCRATCH_W2),y
                                                    sec
                                                    sbc  #48
                                                    bpl  _digit
                                            _done
                                                    sty  cx16.r15
                                                    lda  _result
                                                    ldy  _result+1
                                                    rts
                                            _digit
                                                    cmp  #10
                                                    bcs  _done
                                                    ; add digit to result
                                                    pha
                                                    jsr  _result_times_10
                                                    pla
                                                    clc
                                                    adc  _result
                                                    sta  _result
                                                    bcc  +
                                                    inc  _result+1
                                            +		iny
                                                    bne  _loop
                                                    ; never reached

                                            _result_times_10     ; (W*4 + W)*2
                                                    lda  _result+1
                                                    sta  P8ZP_SCRATCH_REG
                                                    lda  _result
                                                    asl  a
                                                    rol  P8ZP_SCRATCH_REG
                                                    asl  a
                                                    rol  P8ZP_SCRATCH_REG
                                                    clc
                                                    adc  _result
                                                    sta  _result
                                                    lda  P8ZP_SCRATCH_REG
                                                    adc  _result+1
                                                    asl  _result
                                                    rol  a
                                                    sta  _result+1
                                                    rts
                                                .pend
                                                ;	src line: library:/prog8lib/conv.p8:336

                                                str2word	.proc
                                                    ;	src line: library:/prog8lib/conv.p8:341
                                                _result = P8ZP_SCRATCH_W1
                                                        sta  P8ZP_SCRATCH_W2
                                                        sty  P8ZP_SCRATCH_W2+1
                                                        ldy  #0
                                                        sty  _result
                                                        sty  _result+1
                                                        sty  _negative
                                                        sty  cx16.r15+1
                                                        lda  (P8ZP_SCRATCH_W2),y
                                                        cmp  #'+'
                                                        bne  +
                                                        iny
                                                +		cmp  #'-'
                                                        bne  _parse
                                                        inc  _negative
                                                        iny
                                                _parse		lda  (P8ZP_SCRATCH_W2),y
                                                        sec
                                                        sbc  #48
                                                        bpl  _digit
                                                _done
                                                        sty  cx16.r15
                                                        lda  _negative
                                                        beq  +
                                                        sec
                                                        lda  #0
                                                        sbc  _result
                                                        sta  _result
                                                        lda  #0
                                                        sbc  _result+1
                                                        sta  _result+1
                                                +		lda  _result
                                                        ldy  _result+1
                                                        rts
                                                _digit
                                                        cmp  #10
                                                        bcs  _done
                                                        ; add digit to result
                                                        pha
                                                        jsr  str2uword._result_times_10
                                                        pla
                                                        clc
                                                        adc  _result
                                                        sta  _result
                                                        bcc  +
                                                        inc  _result+1
                                                +		iny
                                                        bne  _parse
                                                        ; never reached
                                                _negative	.byte  0
                                                    .pend
	;	src line: library:/prog8lib/conv.p8:395

                                    hex2uword	.proc
                                        ;	src line: library:/prog8lib/conv.p8:400
                                        sta  P8ZP_SCRATCH_W2
                                        sty  P8ZP_SCRATCH_W2+1
                                        ldy  #0
                                        sty  P8ZP_SCRATCH_W1
                                        sty  P8ZP_SCRATCH_W1+1
                                        sty  cx16.r15+1
                                        lda  (P8ZP_SCRATCH_W2),y
                                        beq  _stop
                                        cmp  #'$'
                                        bne  _loop
                                        iny
                                    _loop
                                        lda  #0
                                        sta  P8ZP_SCRATCH_B1
                                        lda  (P8ZP_SCRATCH_W2),y
                                        beq  _stop
                                        cmp  #7                 ; screencode letters A-F are 1-6
                                        bcc  _add_letter
                                        and  #127
                                        cmp  #97
                                        bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
                                        cmp  #'g'
                                        bcs  _stop
                                        cmp  #'a'
                                        bcs  _add_letter
                                        cmp  #'0'
                                        bcc  _stop
                                        cmp  #'9'+1
                                        bcs  _stop
                                    _calc
                                        asl  P8ZP_SCRATCH_W1
                                        rol  P8ZP_SCRATCH_W1+1
                                        asl  P8ZP_SCRATCH_W1
                                        rol  P8ZP_SCRATCH_W1+1
                                        asl  P8ZP_SCRATCH_W1
                                        rol  P8ZP_SCRATCH_W1+1
                                        asl  P8ZP_SCRATCH_W1
                                        rol  P8ZP_SCRATCH_W1+1
                                        and  #$0f
                                        clc
                                        adc  P8ZP_SCRATCH_B1
                                        ora  P8ZP_SCRATCH_W1
                                        sta  P8ZP_SCRATCH_W1
                                        iny
                                        bne  _loop
                                    _stop
                                        sty  cx16.r15
                                        lda  P8ZP_SCRATCH_W1
                                        ldy  P8ZP_SCRATCH_W1+1
                                        rts
                                    _add_letter
                                        pha
                                        lda  #9
                                        sta  P8ZP_SCRATCH_B1
                                        pla
                                        jmp  _calc
                                    _try_iso
                                            cmp  #103
                                            bcs  _stop
                                            and  #63
                                            bne  _add_letter
                                        .pend
                                        ;	src line: library:/prog8lib/conv.p8:465

                                    bin2uword	.proc
                                        ;	src line: library:/prog8lib/conv.p8:469
                                        sta  P8ZP_SCRATCH_W2
                                        sty  P8ZP_SCRATCH_W2+1
                                        ldy  #0
                                        sty  P8ZP_SCRATCH_W1
                                        sty  P8ZP_SCRATCH_W1+1
                                        sty  cx16.r15+1
                                        lda  (P8ZP_SCRATCH_W2),y
                                        beq  _stop
                                        cmp  #'%'
                                        bne  _loop
                                        iny
                                    _loop
                                        lda  (P8ZP_SCRATCH_W2),y
                                        cmp  #'0'
                                        bcc  _stop
                                        cmp  #'2'
                                        bcs  _stop
                                    _first  asl  P8ZP_SCRATCH_W1
                                        rol  P8ZP_SCRATCH_W1+1
                                        and  #1
                                        ora  P8ZP_SCRATCH_W1
                                        sta  P8ZP_SCRATCH_W1
                                        iny
                                        bne  _loop
                                    _stop
                                        sty  cx16.r15
                                        lda  P8ZP_SCRATCH_W1
                                        ldy  P8ZP_SCRATCH_W1+1
                                        rts
                                        .pend
                                        ;	src line: library:/prog8lib/conv.p8:505

ubyte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:507
		ldy  #uword2decimal.ASCII_0_OFFSET
		bne  uword2decimal.hex_try200
		rts
	.pend
	;	src line: library:/prog8lib/conv.p8:514

uword2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:520
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?f=2&t=11341&start=15

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2³ @110/111
    beq    _useZero               ;2³ @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2³ @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2³ @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2³ @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

decTenThousands   	.byte  0
decThousands    	.byte  0
decHundreds		.byte  0
decTens			.byte  0
decOnes   		.byte  0
			.byte  0		; zero-terminate the decimal output string
	.pend
	;	src line: library:/prog8lib/conv.p8:689

byte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:692
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  ubyte2decimal
	.pend
	;	src line: library:/prog8lib/conv.p8:702

ubyte2hex	.proc
	;	src line: library:/prog8lib/conv.p8:704
		stx  P8ZP_SCRATCH_REG
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		ldx  P8ZP_SCRATCH_REG
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
	.pend
	;	src line: library:/prog8lib/conv.p8:724

uword2hex	.proc
	;	src line: library:/prog8lib/conv.p8:726
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
output		.text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
	.pend
	.pend

; ---- block: 'cx16logo' ----
cx16logo	.proc
	;	src line: library:/prog8lib/cx16logo.p8:5

; non-zeropage variables
logo_lines	.word  prog8_interned_strings.string_0, prog8_interned_strings.string_1, prog8_interned_strings.string_2, prog8_interned_strings.string_3, prog8_interned_strings.string_4, prog8_interned_strings.string_5, prog8_interned_strings.string_6

; subroutines in this block
	;	src line: library:/prog8lib/cx16logo.p8:22
	.pend

; ---- block: 'diskio' ----
diskio	.proc
	;	src line: library:/prog8lib/diskio.p8:7
first_byte 	= 10 	; zp UBYTE
list_skip_disk_name 	= 6 	; zp UBYTE
list_pattern 	= 155 	; zp UWORD
list_blocks 	= 158 	; zp UWORD
iteration_in_progress 	= 14 	; zp UBYTE
have_first_byte 	= 146 	; zp UBYTE

; non-zeropage variables
list_filename	; PETSCII:"??????????????????????????????????????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $00

; subroutines in this block
	;	src line: library:/prog8lib/diskio.p8:106
	;	src line: library:/prog8lib/diskio.p8:107
	;	src line: library:/prog8lib/diskio.p8:108
	;	src line: library:/prog8lib/diskio.p8:109
	;	src line: library:/prog8lib/diskio.p8:110
	;	src line: library:/prog8lib/diskio.p8:111
	;	src line: library:/prog8lib/diskio.p8:112
	;	src line: library:/prog8lib/diskio.p8:142

lf_start_list	.proc
pattern_ptr 	= 165 	; zp UWORD
drivenumber 	= 150 	; zp UBYTE
; statements
	;	src line: library:/prog8lib/diskio.p8:142
	;	src line: library:/prog8lib/diskio.p8:142
	;	src line: library:/prog8lib/diskio.p8:145
	jsr  lf_end_list
	;	src line: library:/prog8lib/diskio.p8:146
	lda  pattern_ptr
	ldy  pattern_ptr+1
	sta  list_pattern
	sty  list_pattern+1
	
	;	src line: library:/prog8lib/diskio.p8:147
	lda  #1
	sta  list_skip_disk_name
	;	src line: library:/prog8lib/diskio.p8:148
	sta  iteration_in_progress
	;	src line: library:/prog8lib/diskio.p8:150
	stx  prog8_regsaveX
	ldy  #>prog8_interned_strings.string_7
	ldx  #<prog8_interned_strings.string_7
	lda  #1
	jsr  c64.SETNAM
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:151
	stx  prog8_regsaveX
	ldy  #0
	ldx  drivenumber
	lda  #12
	jsr  c64.SETLFS
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:152
	stx  prog8_regsaveX
	jsr  c64.OPEN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:153
	bcs  io_error
	;	src line: library:/prog8lib/diskio.p8:155
	stx  prog8_regsaveX
	ldx  #12
	jsr  c64.CHKIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:156
	bcs  io_error
	;	src line: library:/prog8lib/diskio.p8:159
	lda  #4
	sta  prog8_label_37_counter
prog8_label_36_repeat
	;	src line: library:/prog8lib/diskio.p8:160
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	ldx  prog8_regsaveX
	dec  prog8_label_37_counter
	bne  prog8_label_36_repeat
	;	src line: library:/prog8lib/diskio.p8:163
	jsr  c64.READST
	cmp  #0
	bne  prog8_label_38_if_end
	;	src line: library:/prog8lib/diskio.p8:164
	lda  #1
	rts
prog8_label_38_if_end
	;	src line: library:/prog8lib/diskio.p8:166
io_error
	;	src line: library:/prog8lib/diskio.p8:167
	jsr  lf_end_list
	;	src line: library:/prog8lib/diskio.p8:168
	lda  #0
	rts
; variables
prog8_label_37_counter    .byte  0
prog8_regsaveX     .byte  0

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/diskio.p8:171

lf_next_entry	.proc
blocks_msb 	= 249 	; zp UBYTE
blocks_lsb 	= 176 	; zp UBYTE
nameptr 	= 190 	; zp UWORD
char 	= 177 	; zp UBYTE
; statements
	;	src line: library:/prog8lib/diskio.p8:184
	;	src line: library:/prog8lib/diskio.p8:183
	;	src line: library:/prog8lib/diskio.p8:182
	;	src line: library:/prog8lib/diskio.p8:199
	;	src line: library:/prog8lib/diskio.p8:176
	lda  iteration_in_progress
	bne  prog8_label_39_if_end
	;	src line: library:/prog8lib/diskio.p8:177
	lda  #0
	rts
prog8_label_39_if_end
	;	src line: library:/prog8lib/diskio.p8:179
prog8_label_21_repeat
	;	src line: library:/prog8lib/diskio.p8:180
	stx  prog8_regsaveX
	ldx  #12
	jsr  c64.CHKIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:182
	lda  #<list_filename
	ldy  #>list_filename
	sta  nameptr
	sty  nameptr+1
	
	;	src line: library:/prog8lib/diskio.p8:183
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	sta  blocks_lsb
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:184
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	sta  blocks_msb
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:186
	jsr  c64.READST
	cmp  #0
	bne  close_end
	;	src line: library:/prog8lib/diskio.p8:189
	lda  blocks_lsb
	ldy  blocks_msb
	sta  list_blocks
	sty  list_blocks+1
	;	src line: library:/prog8lib/diskio.p8:192
prog8_label_14_whileloop
	;	src line: library:/prog8lib/diskio.p8:192
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	ldx  prog8_regsaveX
	cmp  #$22
	beq  prog8_label_15_afterwhile
	;	src line: library:/prog8lib/diskio.p8:193
	jsr  c64.READST
	cmp  #0
	bne  close_end
	;	src line: library:/prog8lib/diskio.p8:192
	jmp  prog8_label_14_whileloop
	;	src line: library:/prog8lib/diskio.p8:192
prog8_label_15_afterwhile
	;	src line: library:/prog8lib/diskio.p8:198
prog8_label_18_repeat
	;	src line: library:/prog8lib/diskio.p8:199
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	sta  char
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:200
	lda  char
	beq  prog8_label_16_after
	;	src line: library:/prog8lib/diskio.p8:202
	lda  char
	cmp  #34
	beq  prog8_label_17_after
	;	src line: library:/prog8lib/diskio.p8:204
	lda  char
	ldy  #0
	sta  (nameptr),y
	;	src line: library:/prog8lib/diskio.p8:205
	inc  nameptr
	bne  +
	inc  nameptr+1
+
	;	src line: library:/prog8lib/diskio.p8:198
	jmp  prog8_label_18_repeat
	;	src line: library:/prog8lib/diskio.p8:203
prog8_label_17_after
	;	src line: library:/prog8lib/diskio.p8:201
prog8_label_16_after
	;	src line: library:/prog8lib/diskio.p8:208
	lda  #0
	ldy  #0
	sta  (nameptr),y
	;	src line: library:/prog8lib/diskio.p8:210
prog8_label_19_whileloop
	;	src line: library:/prog8lib/diskio.p8:210
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	ldx  prog8_regsaveX
	cmp  #0
	beq  prog8_label_20_afterwhile
	;	src line: library:/prog8lib/diskio.p8:210
	jmp  prog8_label_19_whileloop
	;	src line: library:/prog8lib/diskio.p8:210
prog8_label_20_afterwhile
	;	src line: library:/prog8lib/diskio.p8:214
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:215
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:217
	lda  list_skip_disk_name
	bne  prog8_label_40_if_end
	;	src line: library:/prog8lib/diskio.p8:218
	lda  list_pattern
	ora  list_pattern+1
	bne  prog8_label_41_if_end
	;	src line: library:/prog8lib/diskio.p8:219
	lda  #1
	rts
prog8_label_41_if_end
	;	src line: library:/prog8lib/diskio.p8:220
	lda  list_pattern
	sta  cx16.r0
	lda  list_pattern+1
	sta  cx16.r0+1
	
	ldy  #>list_filename
	lda  #<list_filename
	jsr  string.pattern_match
	cmp  #0
	beq  prog8_label_42_if_end
	;	src line: library:/prog8lib/diskio.p8:221
	lda  #1
	rts
prog8_label_42_if_end
prog8_label_40_if_end
	;	src line: library:/prog8lib/diskio.p8:223
	lda  #0
	sta  list_skip_disk_name
	;	src line: library:/prog8lib/diskio.p8:179
	jmp  prog8_label_21_repeat
	;	src line: library:/prog8lib/diskio.p8:226
close_end
	;	src line: library:/prog8lib/diskio.p8:227
	jsr  lf_end_list
	;	src line: library:/prog8lib/diskio.p8:228
	lda  #0
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/diskio.p8:231

lf_end_list	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:233
	lda  iteration_in_progress
	beq  prog8_label_43_if_end
	;	src line: library:/prog8lib/diskio.p8:234
	stx  prog8_regsaveX
	jsr  c64.CLRCHN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:235
	stx  prog8_regsaveX
	lda  #12
	jsr  c64.CLOSE
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:236
	lda  #0
	sta  iteration_in_progress
prog8_label_43_if_end
	;	src line: library:/prog8lib/diskio.p8:231
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/diskio.p8:243

f_open	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:243
	;	src line: library:/prog8lib/diskio.p8:243
	;	src line: library:/prog8lib/diskio.p8:246
	jsr  f_close
	;	src line: library:/prog8lib/diskio.p8:248
	stx  prog8_regsaveX
	ldy  filenameptr+1
	lda  filenameptr
	jsr  string.length
	tya
	pha
	ldy  filenameptr+1
	lda  filenameptr
	pha
	tya
	tay
	pla
	tax
	pla
	jsr  c64.SETNAM
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:249
	stx  prog8_regsaveX
	ldy  #0
	ldx  drivenumber
	lda  #11
	jsr  c64.SETLFS
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:250
	stx  prog8_regsaveX
	jsr  c64.OPEN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:251
	bcs  prog8_label_44_branch_else
	;	src line: library:/prog8lib/diskio.p8:252
	jsr  c64.READST
	cmp  #0
	bne  prog8_label_45_if_end
	;	src line: library:/prog8lib/diskio.p8:253
	lda  #1
	sta  iteration_in_progress
	;	src line: library:/prog8lib/diskio.p8:254
	lda  #0
	sta  have_first_byte
	;	src line: library:/prog8lib/diskio.p8:255
	stx  prog8_regsaveX
	ldx  #11
	jsr  c64.CHKIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:256
	bcs  prog8_label_46_branch_else
	;	src line: library:/prog8lib/diskio.p8:257
	stx  prog8_regsaveX
	jsr  c64.CHRIN
	sta  first_byte
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:258
	jsr  c64.READST
	cmp  #0
	bne  prog8_label_47_if_end
	;	src line: library:/prog8lib/diskio.p8:259
	lda  #1
	sta  have_first_byte
	;	src line: library:/prog8lib/diskio.p8:260
	lda  #1
	rts
prog8_label_47_if_end
prog8_label_46_branch_else
prog8_label_45_if_end
prog8_label_44_branch_else
	;	src line: library:/prog8lib/diskio.p8:265
	jsr  f_close
	;	src line: library:/prog8lib/diskio.p8:266
	lda  #0
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
filenameptr	.word  0
drivenumber	.byte  0
	.pend
	;	src line: library:/prog8lib/diskio.p8:269

f_read	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:269
	;	src line: library:/prog8lib/diskio.p8:269
	;	src line: library:/prog8lib/diskio.p8:274
	lda  iteration_in_progress
	sta  P8ESTACK_LO,x
	dex
	jsr  prog8_lib.equalzero_b
	lda  num_bytes
	sta  P8ESTACK_LO,x
	lda  num_bytes+1
	sta  P8ESTACK_HI,x
	dex
	jsr  prog8_lib.equalzero_w
	jsr  prog8_lib.bitor_b
	inx
	lda  P8ESTACK_LO,x
	beq  prog8_label_48_if_end
	;	src line: library:/prog8lib/diskio.p8:275
	ldy  #>0
	lda  #<0
	rts
prog8_label_48_if_end
	;	src line: library:/prog8lib/diskio.p8:277
	lda  #0
	sta  list_blocks
	sta  list_blocks+1
	
	;	src line: library:/prog8lib/diskio.p8:278
	lda  have_first_byte
	beq  prog8_label_49_if_end
	;	src line: library:/prog8lib/diskio.p8:279
	lda  #0
	sta  have_first_byte
	;	src line: library:/prog8lib/diskio.p8:280
	lda  first_byte
	ldy  bufferpointer
	sty  P8ZP_SCRATCH_W2
	ldy  bufferpointer+1
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sta  (P8ZP_SCRATCH_W2),y
	;	src line: library:/prog8lib/diskio.p8:281
	inc  bufferpointer
	bne  +
	inc  bufferpointer+1
+
	;	src line: library:/prog8lib/diskio.p8:282
	inc  list_blocks
	bne  +
	inc  list_blocks+1
+
	;	src line: library:/prog8lib/diskio.p8:283
	lda  num_bytes
	bne  +
	dec  num_bytes+1
+       dec  num_bytes 
prog8_label_49_if_end
	;	src line: library:/prog8lib/diskio.p8:286
	stx  prog8_regsaveX
	ldx  #11
	jsr  c64.CHKIN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:288
            lda  bufferpointer
            sta  m_in_buffer+1
            lda  bufferpointer+1
            sta  m_in_buffer+2
	;	src line: library:/prog8lib/diskio.p8:294
	ldy  num_bytes+1
	lda  num_bytes
	sta  prog8_label_52_counter
	sty  prog8_label_52_counter+1
prog8_label_51_repeat    lda  prog8_label_52_counter
	bne  +
	lda  prog8_label_52_counter+1
	beq  prog8_label_50_repeatend
	lda  prog8_label_52_counter
	bne  +
	dec  prog8_label_52_counter+1
+               dec  prog8_label_52_counter
	;	src line: library:/prog8lib/diskio.p8:295
                jsr  c64.CHRIN
                sta  cx16.r5
m_in_buffer     sta  $ffff
                inc  m_in_buffer+1
                bne  +
                inc  m_in_buffer+2
+               inc  list_blocks
                bne  +
                inc  list_blocks+1
+
	;	src line: library:/prog8lib/diskio.p8:308
	lda  cx16.r5
	cmp  #<13
	bne  prog8_label_53_if_end
	lda  cx16.r5+1
	cmp  #>13
	bne  prog8_label_53_if_end
	;	src line: library:/prog8lib/diskio.p8:309
	jsr  c64.READST
	sta  first_byte
	;	src line: library:/prog8lib/diskio.p8:310
	and  #$40
	beq  prog8_label_54_if_end
	;	src line: library:/prog8lib/diskio.p8:311
	jsr  f_close
	;	src line: library:/prog8lib/diskio.p8:312
	lda  list_blocks
	bne  +
	dec  list_blocks+1
+       dec  list_blocks 
prog8_label_54_if_end
	;	src line: library:/prog8lib/diskio.p8:314
	lda  first_byte
	beq  prog8_label_55_if_end
	;	src line: library:/prog8lib/diskio.p8:315
	ldy  list_blocks+1
	lda  list_blocks
	rts
prog8_label_55_if_end
prog8_label_53_if_end
	jmp  prog8_label_51_repeat
prog8_label_50_repeatend
	;	src line: library:/prog8lib/diskio.p8:318
	ldy  list_blocks+1
	lda  list_blocks
	rts
; variables
prog8_label_52_counter    .word  0
prog8_regsaveX     .byte  0

; non-zeropage variables
num_bytes	.word  0
bufferpointer	.word  0
	.pend
	;	src line: library:/prog8lib/diskio.p8:342

f_readline	.proc
	;	src line: library:/prog8lib/diskio.p8:348
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldx  #11
            jsr  c64.CHKIN              ; use channel 11 again for input
            ldy  #0
            lda  have_first_byte
            beq  _loop
            lda  #0
            sta  have_first_byte
            lda  first_byte
            sta  (P8ZP_SCRATCH_W1),y
            iny
_loop       jsr  c64.CHRIN
            sta  (P8ZP_SCRATCH_W1),y
            beq  _end
            iny
            cmp  #$0a
            beq  _line_end
            cmp  #$0d
            bne  _loop
_line_end   dey     ; get rid of the trailing end-of-line char
            lda  #0
            sta  (P8ZP_SCRATCH_W1),y
_end        rts
	.pend
	;	src line: library:/prog8lib/diskio.p8:377

f_close	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:379
	lda  iteration_in_progress
	beq  prog8_label_56_if_end
	;	src line: library:/prog8lib/diskio.p8:380
	stx  prog8_regsaveX
	jsr  c64.CLRCHN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:381
	stx  prog8_regsaveX
	lda  #11
	jsr  c64.CLOSE
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:382
	lda  #0
	sta  iteration_in_progress
prog8_label_56_if_end
	;	src line: library:/prog8lib/diskio.p8:377
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/diskio.p8:417

f_close_w	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:419
	stx  prog8_regsaveX
	jsr  c64.CLRCHN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:420
	stx  prog8_regsaveX
	lda  #14
	jsr  c64.CLOSE
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:417
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/diskio.p8:497

load	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:497
	;	src line: library:/prog8lib/diskio.p8:497
	;	src line: library:/prog8lib/diskio.p8:497
	;	src line: library:/prog8lib/diskio.p8:498
	lda  drivenumber
	sta  diskio.load_headerless_cx16.drivenumber
	
	lda  filenameptr
	ldy  filenameptr+1
	sta  diskio.load_headerless_cx16.filenameptr
	sty  diskio.load_headerless_cx16.filenameptr+1
	
	lda  address_override
	ldy  address_override+1
	sta  diskio.load_headerless_cx16.address_override
	sty  diskio.load_headerless_cx16.address_override+1
	
	lda  #0
	sta  diskio.load_headerless_cx16.headerless
	jmp  load_headerless_cx16
; variables

; non-zeropage variables
address_override	.word  0
filenameptr	.word  0
drivenumber	.byte  0
	.pend
	;	src line: library:/prog8lib/diskio.p8:527

load_headerless_cx16	.proc
; statements
	;	src line: library:/prog8lib/diskio.p8:527
	;	src line: library:/prog8lib/diskio.p8:527
	;	src line: library:/prog8lib/diskio.p8:527
	;	src line: library:/prog8lib/diskio.p8:527
	;	src line: library:/prog8lib/diskio.p8:528
	stx  prog8_regsaveX
	ldy  filenameptr+1
	lda  filenameptr
	jsr  string.length
	tya
	pha
	ldy  filenameptr+1
	lda  filenameptr
	pha
	tya
	tay
	pla
	tax
	pla
	jsr  c64.SETNAM
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:529
	;	src line: library:/prog8lib/diskio.p8:529
	lda  #1
	sta  secondary
	;	src line: library:/prog8lib/diskio.p8:530
	lda  #0
	sta  cx16.r1
	sta  cx16.r1+1
	
	;	src line: library:/prog8lib/diskio.p8:531
	lda  address_override
	ora  address_override+1
	beq  prog8_label_57_if_end
	;	src line: library:/prog8lib/diskio.p8:532
	lda  #0
	sta  secondary
prog8_label_57_if_end
	;	src line: library:/prog8lib/diskio.p8:533
	lda  headerless
	beq  prog8_label_58_if_end
	;	src line: library:/prog8lib/diskio.p8:534
	lda  secondary
	ora  #2
	sta  secondary
prog8_label_58_if_end
	;	src line: library:/prog8lib/diskio.p8:535
	stx  prog8_regsaveX
	ldy  secondary
	ldx  drivenumber
	lda  #1
	jsr  c64.SETLFS
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:536
            stx  P8ZP_SCRATCH_REG
            lda  #0
            ldx  address_override
            ldy  address_override+1
            jsr  c64.LOAD
            bcs  +
            stx  cx16.r1
            sty  cx16.r1+1
+           ldx  P8ZP_SCRATCH_REG
	;	src line: library:/prog8lib/diskio.p8:548
	stx  prog8_regsaveX
	jsr  c64.CLRCHN
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:549
	stx  prog8_regsaveX
	lda  #1
	jsr  c64.CLOSE
	ldx  prog8_regsaveX
	;	src line: library:/prog8lib/diskio.p8:550
	lda  cx16.r1
	ldy  cx16.r1+1
	rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
headerless	.byte  0
address_override	.word  0
filenameptr	.word  0
drivenumber	.byte  0
secondary	.byte  0
	.pend
prog8_init_vars	.block
	;	src line: library:/prog8lib/diskio.p8:106
	lda  #0
	sta  list_skip_disk_name
	;	src line: library:/prog8lib/diskio.p8:107
	sta  list_pattern
	sta  list_pattern+1
	
	;	src line: library:/prog8lib/diskio.p8:108
	lda  #0
	sta  list_blocks
	sta  list_blocks+1
	
	;	src line: library:/prog8lib/diskio.p8:109
	lda  #0
	sta  iteration_in_progress
	;	src line: library:/prog8lib/diskio.p8:110
	sta  first_byte
	;	src line: library:/prog8lib/diskio.p8:111
	sta  have_first_byte
	rts
	.bend
	.pend

; ---- block: 'string' ----
string	.proc
	;	src line: library:/prog8lib/string.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/string.p8:5

length	.proc
	;	src line: library:/prog8lib/string.p8:10
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:22

left	.proc
	;	src line: library:/prog8lib/string.p8:27
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		ldy  cx16.r0
		sty  P8ZP_SCRATCH_W1
		ldy  cx16.r0+1
		sty  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		tay
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:53

right	.proc
	;	src line: library:/prog8lib/string.p8:58
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                sta  P8ZP_SCRATCH_B1
                lda  cx16.r0
                ldy  cx16.r0+1
                jsr  string.length
                tya
                sec
                sbc  P8ZP_SCRATCH_B1
                clc
                adc  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:92

slice	.proc
	;	src line: library:/prog8lib/string.p8:98
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		sta  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1

		; adjust src location
		clc
		lda  P8ZP_SCRATCH_W1
		adc  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		beq  _startloop
-		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/string.p8:130

find	.proc
	;	src line: library:/prog8lib/string.p8:133
                ; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
                sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		ldy  cx16.r0+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  P8ZP_SCRATCH_B1
		beq  _found
		iny
		bne  -
_notfound	lda  #0
                clc
		rts
_found		tya
                sec
                rts
	.pend
	;	src line: library:/prog8lib/string.p8:156

copy	.proc
	;	src line: library:/prog8lib/string.p8:161
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	;	src line: library:/prog8lib/string.p8:170

compare	.proc
	;	src line: library:/prog8lib/string.p8:175
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend
	;	src line: library:/prog8lib/string.p8:184

lower	.proc
	;	src line: library:/prog8lib/string.p8:188
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	;	src line: library:/prog8lib/string.p8:207

upper	.proc
	;	src line: library:/prog8lib/string.p8:209
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	;	src line: library:/prog8lib/string.p8:247

pattern_match	.proc
	;	src line: library:/prog8lib/string.p8:248
; pattern matching of a string.
; Input:  cx16.r0:  A NUL-terminated, <255-length pattern
;              AY:  A NUL-terminated, <255-length string
;
; Output: A = 1 if the string matches the pattern, A = 0 if not.
;
; Notes:  Clobbers A, X, Y. Each * in the pattern uses 4 bytes of stack.
;
; see http://6502.org/source/strings/patmatch.htm

str = P8ZP_SCRATCH_W1

	stx  P8ZP_SCRATCH_REG
	sta  str
	sty  str+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	adc  #0
	ldx  P8ZP_SCRATCH_REG
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (str),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (str),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (str),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend
	.pend

; ---- block: 'math' ----
math	.proc
	;	src line: library:/prog8lib/math.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/math.p8:4
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	http://codebase64.org/doku.php?id=base:6502_6510_maths
;


math_store_reg	.byte  0		; temporary storage


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
		sta  P8ZP_SCRATCH_B1         ; num1
		sty  P8ZP_SCRATCH_REG        ; num2
		lda  #0
		beq  _enterloop
_doAdd		clc
		adc  P8ZP_SCRATCH_B1
_loop		asl  P8ZP_SCRATCH_B1
_enterloop	lsr  P8ZP_SCRATCH_REG
		bcs  _doAdd
		bne  _loop
		rts
		.pend


multiply_bytes_into_word	.proc
	; -- multiply 2 bytes A and Y, result as word in A/Y (unsigned)
		sta  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		stx  math_store_reg
		lda  #0
		ldx  #8
		lsr  P8ZP_SCRATCH_B1
-		bcc  +
		clc
		adc  P8ZP_SCRATCH_REG
+		ror  a
		ror  P8ZP_SCRATCH_B1
		dex
		bne  -
		tay
		lda  P8ZP_SCRATCH_B1
		ldx  math_store_reg
		rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
	;      input: A/Y = first 16-bit number, P8ZP_SCRATCH_W1 in ZP = second 16-bit number
	;      output: multiply_words.result  4-bytes/32-bits product, LSB order (low-to-high)
	;      clobbers: A

		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		stx  P8ZP_SCRATCH_REG

mult16		lda  #0
		sta  result+2	; clear upper bits of product
		sta  result+3
		ldx  #16			; for all 16 bits...
-	 	lsr  P8ZP_SCRATCH_W1+1	; divide multiplier by 2
		ror  P8ZP_SCRATCH_W1
		bcc  +
		lda  result+2	; get upper half of product and add multiplicand
		clc
		adc  P8ZP_SCRATCH_W2
		sta  result+2
		lda  result+3
		adc  P8ZP_SCRATCH_W2+1
+ 		ror  a				; rotate partial product
		sta  result+3
		ror  result+2
		ror  result+1
		ror  result
		dex
		bne  -
		ldx  P8ZP_SCRATCH_REG
		rts

result		.byte  0,0,0,0
		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
_remainder	.byte  0
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1
		stx  math_store_reg

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		ldx  math_store_reg
		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident


dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		stx  P8ZP_SCRATCH_REG
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		ldx  P8ZP_SCRATCH_REG
		rts
_divisor	.word 0
		.pend


randseed	.proc
	; -- reset the random seeds for the byte and word random generators
	;    arguments: uword seed in A/Y   clobbers A
	;    (default starting values are:  A=$2c Y=$9e)
		sta  randword._seed
		sty  randword._seed+1
		clc
		adc  #14
		sta  randbyte._seed
		rts
		.pend


randbyte        .proc
	; -- 8 bit pseudo random number generator into A (by just reusing randword)
		jmp  randword
		.pend

randword	.proc
	; -- 16 bit pseudo random number generator into AY

		; rand64k       ;Factors of 65535: 3 5 17 257
		lda sr1+1
		asl a
		asl a
		eor sr1+1
		asl a
		eor sr1+1
		asl a
		asl a
		eor sr1+1
		asl a
		rol sr1         ;shift this left, "random" bit comes from low
		rol sr1+1
		; rand32k       ;Factors of 32767: 7 31 151 are independent and can be combined
		lda sr2+1
		asl a
		eor sr2+1
		asl a
		asl a
		ror sr2         ;shift this right, random bit comes from high - nicer when eor with sr1
		rol sr2+1
		lda sr1+1         ;can be left out
		eor sr2+1         ;if you dont use
		tay               ;y as suggested
		lda sr1           ;mix up lowbytes of SR1
		eor sr2           ;and SR2 to combine both
		rts

sr1     	.word $a55a
sr2     	.word $7653

		.pend


; ----------- optimized multiplications (stack) : ---------
stack_mul_byte_3	.proc
		; X + X*2
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_3	.proc
		; W*2 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend


stack_mul_byte_5	.proc
		; X*4 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_5	.proc
		; W*4 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend


stack_mul_byte_6	.proc
		; (X*2 + X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_6	.proc
		; (W*2 + W)*2
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_7	.proc
		; X*8 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_7	.proc
		; W*8 - W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_9	.proc
		; X*8 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_9	.proc
		; W*8 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_10	.proc
		; (X*4 + X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_10	.proc
		; (W*4 + W)*2
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_11	.proc
		; (X*2 + X)*4 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_11 is skipped (too much code)

stack_mul_byte_12	.proc
		; (X*2 + X)*4
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_12	.proc
		; (W*2 + W)*4
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_13	.proc
		; (X*2 + X)*4 + X
		lda  P8ESTACK_LO+1,x
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_13 is skipped (too much code)

stack_mul_byte_14	.proc
		; (X*8 - X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ESTACK_LO+1,x
                asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_14 is skipped (too much code)

stack_mul_byte_15	.proc
		; X*16 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_15	.proc
		; W*16 - W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_20	.proc
		; (X*4 + X)*4
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_20	.proc
		; (W*4 + W)*4
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_25	.proc
		; (X*2 + X)*8 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_25	.proc
		; W = (W*2 + W) *8 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_40	.proc
		lda  P8ESTACK_LO+1,x
		and  #7
		tay
		lda  mul_byte_40._forties,y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_40	.proc
		; (W*4 + W)*8
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_50	.proc
		lda  P8ESTACK_LO+1,x
		and  #7
		tay
		lda  mul_byte_50._fifties, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_50	.proc
		; W = W * 25 * 2
		jsr  stack_mul_word_25
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_80	.proc
		lda  P8ESTACK_LO+1,x
		and  #3
		tay
		lda  mul_byte_80._eighties, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_80	.proc
		; W = W * 40 * 2
		jsr  stack_mul_word_40
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_100	.proc
		lda  P8ESTACK_LO+1,x
		and  #3
		tay
		lda  mul_byte_100._hundreds, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_100	.proc
		; W = W * 25 * 4
		jsr  stack_mul_word_25
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_word_320	.proc
		; stackW = stackLo * 256 + stackLo * 64	 (stackHi doesn't matter)
		ldy  P8ESTACK_LO+1,x
		lda  #0
		sta  P8ESTACK_HI+1,x
		tya
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		sta  P8ESTACK_LO+1,x
		tya
		clc
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_word_640	.proc
		; stackW = (stackLo * 2 * 320)    (stackHi doesn't matter)
		asl  P8ESTACK_LO+1,x
		jmp  stack_mul_word_320
		.pend


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; bit shifts.
; anything below 3 is done inline. anything above 7 is done via other optimizations.

shift_left_w_7	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x

		asl  a
		rol  P8ZP_SCRATCH_B1
_shift6		asl  a
		rol  P8ZP_SCRATCH_B1
_shift5		asl  a
		rol  P8ZP_SCRATCH_B1
_shift4		asl  a
		rol  P8ZP_SCRATCH_B1
_shift3		asl  a
		rol  P8ZP_SCRATCH_B1
		asl  a
		rol  P8ZP_SCRATCH_B1
		asl  a
		rol  P8ZP_SCRATCH_B1

		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_B1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

shift_left_w_6	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift6
		.pend

shift_left_w_5	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift5
		.pend

shift_left_w_4	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift4
		.pend

shift_left_w_3	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift3
		.pend


shift_left_w	.proc
		; -- variable number of shifts left
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw	.proc
		; -- uword variable number of shifts right
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		lsr  P8ESTACK_HI+1,x
		ror  P8ESTACK_LO+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw_7	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x

		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift6		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift5		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift4		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift3		lsr  a
		ror  P8ZP_SCRATCH_B1
		lsr  a
		ror  P8ZP_SCRATCH_B1
		lsr  a
		ror  P8ZP_SCRATCH_B1

		sta  P8ESTACK_HI+1,x
		lda  P8ZP_SCRATCH_B1
		sta  P8ESTACK_LO+1,x
		rts
		.pend

shift_right_uw_6	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift6
		.pend

shift_right_uw_5	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift5
		.pend

shift_right_uw_4	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift4
		.pend

shift_right_uw_3	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift3
		.pend


shift_right_w_7		.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1

		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1

		lda  P8ZP_SCRATCH_W1+1
_shift6		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift5		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift4		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift3		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1

		lda  P8ZP_SCRATCH_W1
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W1+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

shift_right_w_6	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift6
		.pend

shift_right_w_5	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift5
		.pend

shift_right_w_4	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift4
		.pend

shift_right_w_3	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift3
		.pend


shift_right_w	.proc
		; -- signed word variable number of shifts right
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		lda  P8ESTACK_HI+1,x
		asl  a
		ror  P8ESTACK_HI+1,x
		ror  P8ESTACK_LO+1,x
		dey
		bne  _shift
		rts
		.pend


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y (assume >0)
		cmp  #0
		bmi  _negative
-		lsr  a
		dey
		bne  -
		rts
_negative	lsr  a
		ora  #$80
		dey
		bne  _negative
		rts
		.pend


square          .proc
; -- calculate square root of signed word in AY, result in AY
; routine by Lee Davsion, source: http://6502.org/source/integers/square.htm
; using this routine is about twice as fast as doing a regular multiplication.
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh
	stx  P8ZP_SCRATCH_REG

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	ldx  P8ZP_SCRATCH_REG
	rts

		.pend
	;	src line: library:/prog8lib/math.p8:6

sin8u	.proc
	;	src line: library:/prog8lib/math.p8:7
		tay
		lda  _sinecos8u,y
		rts
_sinecos8u	.byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:15

cos8u	.proc
	;	src line: library:/prog8lib/math.p8:16
		tay
		lda  sin8u._sinecos8u+64,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:23

sin8	.proc
	;	src line: library:/prog8lib/math.p8:24
		tay
		lda  _sinecos8,y
		rts
_sinecos8	.char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:32

cos8	.proc
	;	src line: library:/prog8lib/math.p8:33
		tay
		lda  sin8._sinecos8+64,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:40

sinr8u	.proc
	;	src line: library:/prog8lib/math.p8:41
		tay
		lda  _sinecosR8u,y
		rts
_sinecosR8u	.byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:49

cosr8u	.proc
	;	src line: library:/prog8lib/math.p8:50
		tay
		lda  sinr8u._sinecosR8u+45,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:57

sinr8	.proc
	;	src line: library:/prog8lib/math.p8:58
		tay
		lda  _sinecosR8,y
		rts
_sinecosR8	.char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:66

cosr8	.proc
	;	src line: library:/prog8lib/math.p8:67
		tay
		lda  sinr8._sinecosR8+45,y
		rts
	.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	;	src line: library:/prog8lib/prog8_lib.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/prog8_lib.p8:4
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.


orig_stackpointer	.byte  0	; stores the Stack pointer register at program start

read_byte_from_address_on_stack	.proc
	; -- read the byte from the memory address on the top of the stack, return in A (stack remains unchanged)
		lda  P8ESTACK_LO+1,x
		ldy  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend


write_byte_to_address_on_stack	.proc
	; -- write the byte in A to the memory address on the top of the stack (stack remains unchanged)
		ldy  P8ESTACK_LO+1,x
		sty  P8ZP_SCRATCH_W2
		ldy  P8ESTACK_HI+1,x
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend



neg_b		.proc
		lda  #0
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

neg_w		.proc
		sec
		lda  #0
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  #0
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

inv_word	.proc
		lda  P8ESTACK_LO+1,x
		eor  #255
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+1,x
		eor  #255
		sta  P8ESTACK_HI+1,x
		rts
		.pend

bitand_b	.proc
		; -- bitwise and (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		and  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitor_b		.proc
		; -- bitwise or (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		ora  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitxor_b	.proc
		; -- bitwise xor (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		eor  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitand_w	.proc
		; -- bitwise and (of 2 words)
		lda  P8ESTACK_LO+2,x
		and  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		and  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend

bitor_w		.proc
		; -- bitwise or (of 2 words)
		lda  P8ESTACK_LO+2,x
		ora  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		ora  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend

bitxor_w	.proc
		; -- bitwise xor (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		eor  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		eor  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend


add_w		.proc
	; -- push word+word / uword+uword
		inx
		clc
		lda  P8ESTACK_LO,x
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI,x
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

sub_w		.proc
	; -- push word-word
		inx
		sec
		lda  P8ESTACK_LO+1,x
		sbc  P8ESTACK_LO,x
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

mul_byte	.proc
	; -- b*b->b (signed and unsigned)
		inx
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_LO+1,x
		jsr  math.multiply_bytes
		sta  P8ESTACK_LO+1,x
		rts
		.pend

mul_word	.proc
		inx
		lda  P8ESTACK_LO,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO+1,x
		ldy  P8ESTACK_HI+1,x
		jsr  math.multiply_words
		lda  math.multiply_words.result
		sta  P8ESTACK_LO+1,x
		lda  math.multiply_words.result+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

idiv_b		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		inx
		lda  P8ESTACK_LO,x
		eor  P8ESTACK_LO+1,x
		php			; save sign of result
		lda  P8ESTACK_LO,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num1 positive
+		tay
		inx
		lda  P8ESTACK_LO,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num2 positive
+		jsr  math.divmod_ub_asm
		sta  _remainder
		tya
		plp			; get sign of result
		bpl  +
		eor  #$ff
		sec
		adc  #0			; negate result
+		sta  P8ESTACK_LO,x
		dex
		rts
_remainder	.byte  0
		.pend

idiv_ub		.proc
		inx
		ldy  P8ESTACK_LO,x
		lda  P8ESTACK_LO+1,x
		jsr  math.divmod_ub_asm
		tya
		sta  P8ESTACK_LO+1,x
		rts
		.pend

idiv_w		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		lda  P8ESTACK_HI+2,x
		eor  P8ESTACK_HI+1,x
		php				; save sign of result
		lda  P8ESTACK_HI+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		inx
		lda  P8ESTACK_HI+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		sta  P8ESTACK_LO+1,x
		tya
		sta  P8ESTACK_HI+1,x
		plp
		bpl  +
		jmp  neg_w		; negate result
+		rts
		.pend

idiv_uw		.proc
		inx
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		sta  P8ESTACK_LO+1,x
		tya
		sta  P8ESTACK_HI+1,x
		rts
		.pend

remainder_ub	.proc
		inx
		ldy  P8ESTACK_LO,x	; right operand
		lda  P8ESTACK_LO+1,x  ; left operand
		jsr  math.divmod_ub_asm
		sta  P8ESTACK_LO+1,x
		rts
		.pend

remainder_uw	.proc
		inx
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		lda  P8ZP_SCRATCH_W2
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W2+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

equal_w		.proc
	; -- are the two words on the stack identical?
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bne  equal_b._equal_b_false
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bne  equal_b._equal_b_false
		beq  equal_b._equal_b_true
		.pend

notequal_b	.proc
	; -- are the two bytes on the stack different?
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		beq  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		.pend

notequal_w	.proc
	; -- are the two words on the stack different?
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		beq  notequal_b
		bne  equal_b._equal_b_true
		.pend

less_ub		.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

less_b		.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		sec
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_uw		.proc
		lda  P8ESTACK_HI+2,x
		cmp  P8ESTACK_HI+1,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_w		.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+2,x
		sbc  P8ESTACK_HI+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

equal_b		.proc
	; -- are the two bytes on the stack identical?
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bne  _equal_b_false
_equal_b_true	lda  #1
_equal_b_store	inx
		sta  P8ESTACK_LO+1,x
		rts
_equal_b_false	lda  #0
		beq  _equal_b_store
		.pend

lesseq_ub	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

lesseq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		clc
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

lesseq_uw	.proc
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

lesseq_w	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI+2,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_ub	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		beq  equal_b._equal_b_false
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greater_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		clc
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_uw	.proc
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

greater_w	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI+2,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

greatereq_ub	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		sec
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greatereq_uw	.proc
		lda  P8ESTACK_HI+2,x
		cmp  P8ESTACK_HI+1,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_w	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+2,x
		sbc  P8ESTACK_HI+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_false
		bpl  equal_b._equal_b_true
		.pend


shiftleft_b	.proc
		inx
		ldy  P8ESTACK_LO,x
		bne  +
		rts
+		lda  P8ESTACK_LO+1,x
-		asl  a
		dey
		bne  -
		sta  P8ESTACK_LO+1,x
		rts
		.pend

shiftright_b	.proc
		inx
		ldy  P8ESTACK_LO,x
		bne  +
		rts
+		lda  P8ESTACK_LO+1,x
-		lsr  a
		dey
		bne  -
		sta  P8ESTACK_LO+1,x
		rts
		.pend


equalzero_b	.proc
		lda  P8ESTACK_LO+1,x
		beq  _true
		bne  _false
_true		lda  #1
		sta  P8ESTACK_LO+1,x
		rts
_false		lda  #0
		sta  P8ESTACK_LO+1,x
		rts
		.pend

equalzero_w	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

notequalzero_b	.proc
		lda  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

notequalzero_w	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lesszero_b	.proc
		lda  P8ESTACK_LO+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

lesszero_w	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

greaterzero_ub	.proc
		lda  P8ESTACK_LO+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sb	.proc
		lda  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bpl  equalzero_b._true
		bmi  equalzero_b._false
		.pend

greaterzero_uw	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sw	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._false
		ora  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lessequalzero_sb	.proc
		lda  P8ESTACK_LO+1,x
		bmi  equalzero_b._true
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

lessequalzero_sw	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._true
		ora  P8ESTACK_LO+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

greaterequalzero_sb	.proc
		lda  P8ESTACK_LO+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

greaterequalzero_sw	.proc
		lda  P8ESTACK_HI+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  _save_reg
		ldy  #0
		ldx  _save_reg
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
_save_reg	.byte  0
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _mod1+1                    ; self-modify
		sty  _mod1b+1                   ; self-modify
		sta  _mod2+1                    ; self-modify
		sty  _mod2b+1                   ; self-modify
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
_mod1           lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
_mod1b		lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
_mod2           lda  #0                         ; self-modified
                sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  _mod2b
		inc  P8ZP_SCRATCH_W1+1
_mod2b          lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol_array_ub	.proc
		; -- rol a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend


ror_array_ub	.proc
		; -- ror a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror2_array_ub	.proc
		; -- ror2 (8-bit ror) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

rol2_array_ub	.proc
		; -- rol2 (8-bit rol) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror_array_uw	.proc
		; -- ror a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		plp
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol_array_uw	.proc
		; -- rol a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		plp
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol2_array_uw	.proc
		; -- rol2 (16-bit rol) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		asl  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		dey
		lda  (P8ZP_SCRATCH_W1),y
		adc  #0
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

ror2_array_uw	.proc
		; -- ror2 (16-bit ror) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		ora  #$80
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
_arg_s1		.word  0
_arg_s2		.word  0
		.pend


strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  (P8ZP_SCRATCH_W2),y
		bne  _return_minusone
		beq  _return
+		cmp  (P8ZP_SCRATCH_W2),y
		bcc  _return_minusone
		bne  _return_one
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		inc  P8ZP_SCRATCH_W2
		bne  _loop
		inc  P8ZP_SCRATCH_W2+1
		bne  _loop
_return_one
		lda  #1
_return		rts
_return_minusone
		lda  #-1
		rts
		.pend


sign_extend_stack_byte	.proc
	; -- sign extend the (signed) byte on the stack to full 16 bits
		lda  P8ESTACK_LO+1,x
		ora  #$7f
		bmi  +
		lda  #0
+		sta  P8ESTACK_HI+1,x
		rts
		.pend

strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_wordarray	.proc
	; -- check if a value exists in a word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend
	;	src line: library:/prog8lib/prog8_lib.p8:5
; ---- builtin functions


func_any_b_stack	.proc
		jsr  func_any_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_all_b_stack	.proc
		jsr  func_all_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_any_b_into_A	.proc
		; -- any(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  _got_any
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #0
		rts
_got_any	lda  #1
		rts
		.pend


func_all_b_into_A	.proc
		; -- all(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _got_not_all
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
_got_not_all	rts
		.pend

func_any_w_into_A	.proc
		asl  a
		jmp  func_any_b_into_A
		.pend

func_any_w_stack	.proc
		asl  a
		jsr  func_any_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_all_w_into_A	.proc
		; -- all(warray),  array in P8ZP_SCRATCH_W1, num bytes in A
		asl  a			; times 2 because of word
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		bne  ++
		lda  #0
		rts
+		iny
+		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
		rts
		.pend

func_all_w_stack	.proc
		jsr  func_all_w_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

abs_b_stack	.proc
	; -- push abs(A) on stack (as unsigned word)
		jsr  abs_b_into_AY
		sta  P8ESTACK_LO,x
		stz  P8ESTACK_HI,x
		dex
		rts
		.pend

abs_b_into_AY	.proc
	; -- AY = abs(A)  (abs always returns unsigned word)
		ldy  #0
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_stack	.proc
	; -- push abs(AY) on stack (as word)
		jsr  abs_w_into_AY
		sta  P8ESTACK_LO,x
		tya
		sta  P8ESTACK_HI,x
		dex
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_b_stack	.proc
		jsr  func_sign_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_ub_stack	.proc
		jsr  func_sign_ub_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_uw_stack	.proc
		jsr  func_sign_uw_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		beq  _possibly_zero
		bmi  _neg
_pos		lda  #1
		rts
_neg		lda  #-1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend


func_sign_w_stack	.proc
		jsr  func_sign_w_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sqrt16_stack	.proc
		jsr  func_sqrt16_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sqrt16_into_A	.proc
		; integer square root from  http://6502org.wikidot.com/software-math-sqrt
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		txa
		pha
		lda  #0
		sta  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_REG
		ldx  #8
-		sec
		lda  P8ZP_SCRATCH_W1+1
		sbc  #$40
		tay
		lda  P8ZP_SCRATCH_REG
		sbc  P8ZP_SCRATCH_B1
		bcc  +
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		asl  P8ZP_SCRATCH_W1
		rol  P8ZP_SCRATCH_W1+1
		rol  P8ZP_SCRATCH_REG
		asl  P8ZP_SCRATCH_W1
		rol  P8ZP_SCRATCH_W1+1
		rol  P8ZP_SCRATCH_REG
		dex
		bne  -
		pla
		tax
		lda  P8ZP_SCRATCH_B1
		rts
		.pend

func_rnd_stack	.proc
	; -- put a random ubyte on the estack
		jsr  math.randbyte
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_rndw_stack	.proc
	; -- put a random uword on the estack
		jsr  math.randword
		sta  P8ESTACK_LO,x
		tya
		sta  P8ESTACK_HI,x
		dex
		rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peekw   .proc
	; -- read the word value on the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend
	.pend

; ---- block: 'graphics' ----
graphics	.proc
	;	src line: library:/prog8lib/c64/graphics.p8:7
internal_plotx 	= 4 	; zp UWORD
	BITMAP_ADDRESS = $2000
	WIDTH = $0140
	HEIGHT = $c8

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/c64/graphics.p8:8
	;	src line: library:/prog8lib/c64/graphics.p8:9
	;	src line: library:/prog8lib/c64/graphics.p8:10
	;	src line: library:/prog8lib/c64/graphics.p8:318
	;	src line: library:/prog8lib/c64/graphics.p8:28

clear_screen	.proc
; simple int arg(s) passed via register(s)
	sta  pixelcolor
	sty  bgcolor
; statements
	;	src line: library:/prog8lib/c64/graphics.p8:28
	;	src line: library:/prog8lib/c64/graphics.p8:28
	;	src line: library:/prog8lib/c64/graphics.p8:29
	txa
	pha
	lda  #<$2000
	sta  cx16.r0
	lda  #>$2000
	sta  cx16.r0+1
	
	lda  #<$1f40
	sta  cx16.r1
	lda  #>$1f40
	sta  cx16.r1+1
	
	lda  #0
	jsr  sys.memset
	pla
	tax
	;	src line: library:/prog8lib/c64/graphics.p8:30
	lda  pixelcolor
	sta  P8ESTACK_LO,x
	dex
	lda  P8ESTACK_LO+1,x
	asl  a
	asl  a
	asl  a
	asl  a
	sta  P8ESTACK_LO+1,x
	lda  bgcolor
	sta  P8ESTACK_LO,x
	dex
	jsr  prog8_lib.bitor_b
	inx
	lda  P8ESTACK_LO,x
	pha
	lda  #0
	tay
	pla
	jmp  txt.fill_screen
	;	src line: library:/prog8lib/c64/graphics.p8:28
; variables

; non-zeropage variables
bgcolor	.byte  0
pixelcolor	.byte  0
	.pend
	;	src line: library:/prog8lib/c64/graphics.p8:150

horizontal_line	.proc
; statements
	;	src line: library:/prog8lib/c64/graphics.p8:150
	;	src line: library:/prog8lib/c64/graphics.p8:150
	;	src line: library:/prog8lib/c64/graphics.p8:150
	;	src line: library:/prog8lib/c64/graphics.p8:151
	ldy  length+1
	lda  length
	cpy  #>8
	bcc  +
	bne  prog8_label_59_if_end
	cmp  #<8
	bcs  prog8_label_59_if_end
+
	;	src line: library:/prog8lib/c64/graphics.p8:152
	lda  x
	ldy  x+1
	sta  internal_plotx
	sty  internal_plotx+1
	
	;	src line: library:/prog8lib/c64/graphics.p8:153
	ldy  length
	beq  prog8_label_60_repeatend
	sty  prog8_label_62_counter
prog8_label_61_repeat
	;	src line: library:/prog8lib/c64/graphics.p8:154
	txa
	pha
	lda  y
	jsr  internal_plot
	pla
	tax
	;	src line: library:/prog8lib/c64/graphics.p8:155
	inc  internal_plotx
	bne  +
	inc  internal_plotx+1
+
	dec  prog8_label_62_counter
	bne  prog8_label_61_repeat
prog8_label_60_repeatend
	;	src line: library:/prog8lib/c64/graphics.p8:157
	rts
prog8_label_59_if_end
	;	src line: library:/prog8lib/c64/graphics.p8:160
	;	src line: library:/prog8lib/c64/graphics.p8:160
	lda  x
	sta  separate_pixels
	;	src line: library:/prog8lib/c64/graphics.p8:160
	and  #7
	sta  separate_pixels
	;	src line: library:/prog8lib/c64/graphics.p8:161
	;	src line: library:/prog8lib/c64/graphics.p8:161
	lda  x
	sta  P8ESTACK_LO,x
	lda  x+1
	sta  P8ESTACK_HI,x
	dex
	lda  #<$fff8
	sta  P8ESTACK_LO,x
	lda  #>$fff8
	sta  P8ESTACK_HI,x
	dex
	
	jsr  prog8_lib.bitand_w
	ldy  y
	jsr  get_y_lookup
	sta  P8ESTACK_LO,x
	tya
	sta  P8ESTACK_HI,x
	dex
	jsr  prog8_lib.add_w
	inx
	lda  P8ESTACK_LO,x
	sta  addr
	lda  P8ESTACK_HI,x
	sta  addr+1
	
	;	src line: library:/prog8lib/c64/graphics.p8:163
	lda  separate_pixels
	beq  prog8_label_63_if_end
	;	src line: library:/prog8lib/c64/graphics.p8:164
                lda  addr
                sta  P8ZP_SCRATCH_W1
                lda  addr+1
                sta  P8ZP_SCRATCH_W1+1
                ldy  separate_pixels
                lda  hline_filled_right,y
                eor  #255
                ldy  #0
                ora  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W1),y
	;	src line: library:/prog8lib/c64/graphics.p8:176
	lda  addr
	clc
	adc  #8
	sta  addr
	bcc  +
	inc  addr+1
+
	;	src line: library:/prog8lib/c64/graphics.p8:177
	lda  length
	clc
	adc  separate_pixels
	sta  length
	bcc  +
	inc  length+1
+
	;	src line: library:/prog8lib/c64/graphics.p8:178
	lda  length
	sec
	sbc  #8
	sta  length
	bcs  +
	dec  length+1
+
prog8_label_63_if_end
	;	src line: library:/prog8lib/c64/graphics.p8:181
	lda  length
	ora  length+1
	beq  prog8_label_64_if_end
	;	src line: library:/prog8lib/c64/graphics.p8:182
                lda  length
                and  #7
                sta  separate_pixels
                stx  P8ZP_SCRATCH_REG
                lsr  length+1
                ror  length
                lsr  length+1
                ror  length
                lsr  length+1
                ror  length
                lda  addr
                sta  _modified+1
                lda  addr+1
                sta  _modified+2
                lda  length
                ora  length+1
                beq  _zero
                ldy  length
                ldx  #$ff
_modified       stx  $ffff      ; modified
                lda  _modified+1
                clc
                adc  #8
                sta  _modified+1
                bcc  +
                inc  _modified+2
+               dey
                bne  _modified
_zero           ldx  P8ZP_SCRATCH_REG

                ldy  separate_pixels
                beq  hline_zero2
                lda  _modified+1
                sta  P8ZP_SCRATCH_W1
                lda  _modified+2
                sta  P8ZP_SCRATCH_W1+1
                lda  hline_filled_right,y
                ldy  #0
                ora  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W1),y
                jmp  hline_zero2
hline_filled_right   .byte  0, %10000000, %11000000, %11100000, %11110000, %11111000, %11111100, %11111110
hline_zero2
prog8_label_64_if_end
	;	src line: library:/prog8lib/c64/graphics.p8:150
	rts
; variables
prog8_label_62_counter    .byte  0

; non-zeropage variables
length	.word  0
y	.byte  0
x	.word  0
separate_pixels	.byte  0
addr	.word  0
	.pend
	;	src line: library:/prog8lib/c64/graphics.p8:230

vertical_line	.proc
; statements
	;	src line: library:/prog8lib/c64/graphics.p8:230
	;	src line: library:/prog8lib/c64/graphics.p8:230
	;	src line: library:/prog8lib/c64/graphics.p8:230
	;	src line: library:/prog8lib/c64/graphics.p8:231
	lda  x
	ldy  x+1
	sta  internal_plotx
	sty  internal_plotx+1
	
	;	src line: library:/prog8lib/c64/graphics.p8:232
	ldy  height
	beq  prog8_label_65_repeatend
	sty  prog8_label_67_counter
prog8_label_66_repeat
	;	src line: library:/prog8lib/c64/graphics.p8:233
	txa
	pha
	lda  y
	jsr  internal_plot
	pla
	tax
	;	src line: library:/prog8lib/c64/graphics.p8:234
	inc  y
	dec  prog8_label_67_counter
	bne  prog8_label_66_repeat
prog8_label_65_repeatend
	;	src line: library:/prog8lib/c64/graphics.p8:230
	rts
; variables
prog8_label_67_counter    .byte  0

; non-zeropage variables
height	.byte  0
y	.byte  0
x	.word  0
	.pend
	;	src line: library:/prog8lib/c64/graphics.p8:307
	;	src line: library:/prog8lib/c64/graphics.p8:320

internal_plot	.proc
	;	src line: library:/prog8lib/c64/graphics.p8:321
        tay
        lda  internal_plotx+1
        sta  P8ZP_SCRATCH_W2+1
        lsr  a            ; 0
        sta  P8ZP_SCRATCH_W2
        lda  internal_plotx
        pha
        and  #7
        tax

        lda  _y_lookup_lo,y
        clc
        adc  P8ZP_SCRATCH_W2
        sta  P8ZP_SCRATCH_W2
        lda  _y_lookup_hi,y
        adc  P8ZP_SCRATCH_W2+1
        sta  P8ZP_SCRATCH_W2+1

        pla     ; internal_plotx
        and  #%11111000
        tay
        lda  (P8ZP_SCRATCH_W2),y
        ora  _ormask,x
        sta  (P8ZP_SCRATCH_W2),y
        rts

_ormask     .byte 128, 64, 32, 16, 8, 4, 2, 1

; note: this can be even faster if we also have a 256 byte x-lookup table, but hey.
; see http://codebase64.org/doku.php?id=base:various_techniques_to_calculate_adresses_fast_common_screen_formats_for_pixel_graphics
; the y lookup tables encodes this formula:  BITMAP_ADDRESS + 320*(py>>3) + (py & 7)    (y from 0..199)
; We use the 64tass syntax for range expressions to calculate this table on assembly time.

_plot_y_values := $2000 + 320*(range(200)>>3) + (range(200) & 7)

_y_lookup_lo    .byte  <_plot_y_values
_y_lookup_hi    .byte  >_plot_y_values
	.pend
	;	src line: library:/prog8lib/c64/graphics.p8:363

get_y_lookup	.proc
	;	src line: library:/prog8lib/c64/graphics.p8:364
            lda  internal_plot._y_lookup_lo,y
            pha
            lda  internal_plot._y_lookup_hi,y
            tay
            pla
            rts
	.pend
prog8_init_vars	.block
	;	src line: library:/prog8lib/c64/graphics.p8:318
	lda  #0
	sta  internal_plotx
	sta  internal_plotx+1
	
	rts
	.bend
	.pend
; global float constants
; memory slabs
prog8_slabs	.block
	.bend
prog8_program_end	; end of program label for progend()
