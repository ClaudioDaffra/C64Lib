                ; 6502 assembly code for 'prova'
                ; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2022-09-18T12:23:39
                ; assembler syntax is for the 64tasm cross-assembler
                ; output options: output=PRG launcher=BASIC zp=FLOATSAFE

                .cpu  '6502'
                .enc  'none'

                ;P8ZP_SCRATCH_B1    = 2     ;   2   zpy
                ;P8ZP_SCRATCH_REG   = 3     ;   3   zpx
                ;P8ZP_SCRATCH_W1    = 251   ;   zpWord0
                ;P8ZP_SCRATCH_W2    = 253   ;   zpWord1

                ; ............................................. ZERO PAGE

                zpy		= $02
                zpx		= $2a
                zpa		= $52

                ; .............................................
                ;
                ;   zpByte00
                ;   zpByte01

                ; .............................................

                zpByte0 = $fb   ;   251
                zpByte1 = $fc
                zpByte2 = $fd   ;   253
                zpByte3 = $fe

                zpWord0     = $fb
                zpWord0hi   = $fb
                zpWord0lo   = $fc

                zpWord1     = $fd
                zpWord1hi   = $fd
                zpWord1lo   = $fe

                ; ............................................. 

                ;   zpByte4 = $03   ;   3
                ;   zpByte5 = $04
                ;   zpByte6 = $05   ;   5
                ;   zpByte7 = $06
                ;   zpWord2 = $03
                ;   zpWord3 = $05

                ; .............................................

                .weak
                stack.lo = $ce00
                stack.hi = $cf00
                .endweak

;***********************
; #LIBRARY : 'prog8_interned_strings' 
;***********************

prog8_interned_strings    .proc

; non-zeropage variables
string_0    ; PETSCII:"\uf10d\uf11a\uf139\uf11b     \uf11a\uf13a\uf11b"
.byte  $9c, $12, $df, $92, $20, $20, $20, $20, $20, $12, $e9, $92, $00
string_1    ; PETSCII:"\uf10b\uf11a\u258e\uf139\uf11b   \uf11a\uf13a\uf130\uf11b"
.byte  $9a, $12, $f4, $df, $92, $20, $20, $20, $12, $e9, $ea, $92, $00
string_2    ; PETSCII:"\uf10f\uf11a\u258c \uf139\uf11b \uf11a\uf13a \uf11b\u258c"
.byte  $9f, $12, $e1, $20, $df, $92, $20, $12, $e9, $20, $92, $e1, $00
string_3    ; PETSCII:"\uf102 \uf132\uf11a\u2596\uf11b \uf11a\u2597\uf11b\uf132"
.byte  $1e, $20, $f7, $12, $fb, $92, $20, $12, $ec, $92, $f7, $00
string_4    ; PETSCII:"\uf10e \u2582\uf11a\u2598\uf11b \uf11a\u259d\uf11b\u2582"
.byte  $9e, $20, $ef, $12, $fe, $92, $20, $12, $fc, $92, $ef, $00
string_5    ; PETSCII:"\uf104 \uf11a \uf11b\uf13a\uf11b \uf139\uf11a \uf11b"
.byte  $81, $20, $12, $20, $92, $e9, $92, $20, $df, $12, $20, $92, $00
string_6    ; PETSCII:"\uf101\uf130\uf13a   \uf139\u258e\uf100"
.byte  $1c, $ea, $e9, $20, $20, $20, $df, $f4, $05, $00
string_7    ; PETSCII:"$"
.byte  $24, $00

; subroutines in this block

.pend

                    ;***********************
                    ; #LIBRARY : 'conv' 
                    ;***********************

                    conv    .proc
 
                    ; non-zeropage variables
                    string_out    ; PETSCII:"????????????????"
                        .byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
                        .byte  $00

                    ; subroutines in this block
 
                    str_ub0    .proc
                                stx  zpx
                                jsr  conv.ubyte2decimal
                                sty  string_out
                                sta  string_out+1
                                stx  string_out+2
                                lda  #0
                                sta  string_out+3
                                ldx  zpx
                                rts
                        .pend
 
                    str_ub    .proc
                     
                            stx  zpx
                            ldy  #0
                            sty  zpy
                            jsr  conv.ubyte2decimal
                    _output_byte_digits
                                    ; hundreds?
                            cpy  #'0'
                            beq  +
                            pha
                            tya
                            ldy  zpy
                            sta  string_out,y
                            pla
                            inc  zpy
                            ; tens?
                    +        ldy  zpy
                                    cmp  #'0'
                            beq  +
                            sta  string_out,y
                            iny
                    +               ; ones.
                                    txa
                                    sta  string_out,y
                                    iny
                                    lda  #0
                                    sta  string_out,y
                                    ldx  zpx
                                    rts
                        .pend
 

                        str_b    .proc
                            
                                    stx  zpx
                                    ldy  #0
                                    sty  zpy
                                    cmp  #0
                                    bpl  +
                                    pha
                                    lda  #'-'
                                    sta  string_out
                                    inc  zpy
                                    pla
                        +        jsr  conv.byte2decimal
                                    bra  str_ub._output_byte_digits
                            .pend
                            ;    src line: library:/prog8lib/conv.p8:76

                        str_ubhex    .proc
                            ;    src line: library:/prog8lib/conv.p8:78
                                    jsr  conv.ubyte2hex
                                    sta  string_out
                                    sty  string_out+1
                                    lda  #0
                                    sta  string_out+2
                                    rts
                            .pend
 
                        str_ubbin    .proc
                            ;    src line: library:/prog8lib/conv.p8:90
                                sta  zpy
                                ldy  #0
                                sty  string_out+8
                                ldy  #7
                        -        lsr  zpy
                                    bcc  +
                                    lda  #'1'
                                    bne  _digit
                        +           lda  #'0'
                        _digit      sta  string_out,y
                                    dey
                                bpl  -
                                rts
                            .pend
 
                        str_uwbin    .proc
                            ;    src line: library:/prog8lib/conv.p8:109
                                sta  zpx
                                tya
                                jsr  str_ubbin
                                ldy  #0
                                sty  string_out+16
                                ldy  #7
                        -        lsr  zpx
                                    bcc  +
                                    lda  #'1'
                                    bne  _digit
                        +           lda  #'0'
                        _digit      sta  string_out+8,y
                                    dey
                                bpl  -
                                rts
                            .pend
 
                        str_uwhex    .proc
                         
                                    pha
                                    tya
                                    jsr  conv.ubyte2hex
                                    sta  string_out
                                    sty  string_out+1
                                    pla
                                    jsr  conv.ubyte2hex
                                    sta  string_out+2
                                    sty  string_out+3
                                    lda  #0
                                    sta  string_out+4
                                    rts
                            .pend
 

                            str_uw0    .proc
                             
                                    stx  zpx
                                    jsr  conv.uword2decimal
                                    ldy  #0
                            -           lda  conv.uword2decimal.decTenThousands,y
                                        sta  string_out,y
                                        beq  +
                                        iny
                                        bne  -
                            +           ldx  zpx
                                    rts
                                .pend
 

                            str_uw    .proc
                             
                                    stx  zpx
                                    jsr  conv.uword2decimal
                                    ldx  #0
                            _output_digits
                                    ldy  #0
                            -           lda  conv.uword2decimal.decTenThousands,y
                                        beq  _allzero
                                        cmp  #'0'
                                        bne  _gotdigit
                                        iny
                                        bne  -
                            _gotdigit   sta  string_out,x
                                        inx
                                        iny
                                        lda  conv.uword2decimal.decTenThousands,y
                                        bne  _gotdigit
                            _end        lda  #0
                                        sta  string_out,x
                                        ldx  zpx
                                        rts

                            _allzero    lda  #'0'
                                        sta  string_out,x
                                        inx
                                        bne  _end
                                .pend
 

                            str_w    .proc
                             
                                    cpy  #0
                                    bpl  str_uw
                                    stx  zpx
                                    pha
                                    lda  #'-'
                                    sta  string_out
                                        tya
                                        eor  #255
                                        tay
                                        pla
                                        eor  #255
                                        clc
                                        adc  #1
                                        bcc  +
                                        iny
                            +        jsr  conv.uword2decimal
                                    ldx  #1
                                    bne  str_uw._output_digits
                             
                              rts
                                .pend
  

                                            any2uword    .proc
                                                ;    src line: library:/prog8lib/conv.p8:226
                                                pha
                                                sta  zpWord0
                                                sty  zpWord0+1
                                                ldy  #0
                                                lda  (zpWord0),y
                                                ldy  zpWord0+1
                                                cmp  #'$'
                                                beq  _hex
                                                cmp  #'%'
                                                beq  _bin
                                                pla
                                                jsr  str2uword
                                                jmp  _result
                                            _hex    pla
                                                jsr  hex2uword
                                                jmp  _result
                                            _bin    pla
                                                jsr  bin2uword
                                            _result
                                                    pha
                                                    lda  cx16.r15
                                                    sta  zpy        ; result value
                                                    pla
                                                    sta  cx16.r15
                                                    sty  cx16.r15+1
                                                    lda  zpy
                                                    rts
                                                .pend
                                             
                                            str2uword    .proc
                                                ;    src line: library:/prog8lib/conv.p8:282
                                            _result = zpWord0
                                                        sta  zpWord1
                                                        sty  zpWord1+1
                                                    ldy  #0
                                                    sty  _result
                                                    sty  _result+1
                                                    sty  cx16.r15+1
                                            _loop
                                                    lda  (zpWord1),y
                                                    sec
                                                    sbc  #48
                                                    bpl  _digit
                                            _done
                                                    sty  cx16.r15
                                                    lda  _result
                                                    ldy  _result+1
                                                    rts
                                            _digit
                                                    cmp  #10
                                                    bcs  _done
                                                    ; add digit to result
                                                    pha
                                                    jsr  _result_times_10
                                                    pla
                                                    clc
                                                    adc  _result
                                                    sta  _result
                                                    bcc  +
                                                    inc  _result+1
                                            +        iny
                                                    bne  _loop
                                                    ; never reached

                                            _result_times_10     ; (W*4 + W)*2
                                                    lda  _result+1
                                                    sta  zpx
                                                    lda  _result
                                                    asl  a
                                                    rol  zpx
                                                    asl  a
                                                    rol  zpx
                                                    clc
                                                    adc  _result
                                                    sta  _result
                                                    lda  zpx
                                                    adc  _result+1
                                                    asl  _result
                                                    rol  a
                                                    sta  _result+1
                                                    rts
                                                .pend
                                                ;    src line: library:/prog8lib/conv.p8:336

                                                    str2word    .proc
                                                        ;    src line: library:/prog8lib/conv.p8:341
                                                    _result = zpWord0
                                                            sta  zpWord1
                                                            sty  zpWord1+1
                                                            ldy  #0
                                                            sty  _result
                                                            sty  _result+1
                                                            sty  _negative
                                                            sty  cx16.r15+1
                                                            lda  (zpWord1),y
                                                            cmp  #'+'
                                                            bne  +
                                                            iny
                                                    +        cmp  #'-'
                                                            bne  _parse
                                                            inc  _negative
                                                            iny
                                                    _parse        lda  (zpWord1),y
                                                            sec
                                                            sbc  #48
                                                            bpl  _digit
                                                    _done
                                                            sty  cx16.r15
                                                            lda  _negative
                                                            beq  +
                                                            sec
                                                            lda  #0
                                                            sbc  _result
                                                            sta  _result
                                                            lda  #0
                                                            sbc  _result+1
                                                            sta  _result+1
                                                    +        lda  _result
                                                            ldy  _result+1
                                                            rts
                                                    _digit
                                                            cmp  #10
                                                            bcs  _done
                                                            ; add digit to result
                                                            pha
                                                            jsr  str2uword._result_times_10
                                                            pla
                                                            clc
                                                            adc  _result
                                                            sta  _result
                                                            bcc  +
                                                            inc  _result+1
                                                    +        iny
                                                            bne  _parse
                                                            ; never reached
                                                    _negative    .byte  0
                                                        .pend
 
                                                hex2uword    .proc
                                                    ;    src line: library:/prog8lib/conv.p8:400
                                                    sta  zpWord1
                                                    sty  zpWord1+1
                                                    ldy  #0
                                                    sty  zpWord0
                                                    sty  zpWord0+1
                                                    sty  cx16.r15+1
                                                    lda  (zpWord1),y
                                                    beq  _stop
                                                    cmp  #'$'
                                                    bne  _loop
                                                    iny
                                                _loop
                                                    lda  #0
                                                    sta  zpy
                                                    lda  (zpWord1),y
                                                    beq  _stop
                                                    cmp  #7                 ; screencode letters A-F are 1-6
                                                    bcc  _add_letter
                                                    and  #127
                                                    cmp  #97
                                                    bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
                                                    cmp  #'g'
                                                    bcs  _stop
                                                    cmp  #'a'
                                                    bcs  _add_letter
                                                    cmp  #'0'
                                                    bcc  _stop
                                                    cmp  #'9'+1
                                                    bcs  _stop
                                                _calc
                                                    asl  zpWord0
                                                    rol  zpWord0+1
                                                    asl  zpWord0
                                                    rol  zpWord0+1
                                                    asl  zpWord0
                                                    rol  zpWord0+1
                                                    asl  zpWord0
                                                    rol  zpWord0+1
                                                    and  #$0f
                                                    clc
                                                    adc  zpy
                                                    ora  zpWord0
                                                    sta  zpWord0
                                                    iny
                                                    bne  _loop
                                                _stop
                                                    sty  cx16.r15
                                                    lda  zpWord0
                                                    ldy  zpWord0+1
                                                    rts
                                                _add_letter
                                                    pha
                                                    lda  #9
                                                    sta  zpy
                                                    pla
                                                    jmp  _calc
                                                _try_iso
                                                        cmp  #103
                                                        bcs  _stop
                                                        and  #63
                                                        bne  _add_letter
                                                    .pend


                                                bin2uword    .proc
                                                    ;    src line: library:/prog8lib/conv.p8:469
                                                    sta  zpWord1
                                                    sty  zpWord1+1
                                                    ldy  #0
                                                    sty  zpWord0
                                                    sty  zpWord0+1
                                                    sty  cx16.r15+1
                                                    lda  (zpWord1),y
                                                    beq  _stop
                                                    cmp  #'%'
                                                    bne  _loop
                                                    iny
                                                _loop
                                                    lda  (zpWord1),y
                                                    cmp  #'0'
                                                    bcc  _stop
                                                    cmp  #'2'
                                                    bcs  _stop
                                                _first  asl  zpWord0
                                                    rol  zpWord0+1
                                                    and  #1
                                                    ora  zpWord0
                                                    sta  zpWord0
                                                    iny
                                                    bne  _loop
                                                _stop
                                                    sty  cx16.r15
                                                    lda  zpWord0
                                                    ldy  zpWord0+1
                                                    rts
                                                    .pend
 

                                                ubyte2decimal    .proc
                                                    ;    src line: library:/prog8lib/conv.p8:507
                                                        ldy  #uword2decimal.ASCII_0_OFFSET
                                                        bne  uword2decimal.hex_try200
                                                        rts
                                                    .pend
 

                                                    uword2decimal    .proc
                                                        ;    src line: library:/prog8lib/conv.p8:520
                                                    ;Convert 16 bit Hex to Decimal (0-65535) Rev 2
                                                    ;By Omegamatrix    Further optimizations by tepples
                                                    ; routine from https://forums.nesdev.org/viewtopic.php?f=2&t=11341&start=15

                                                    ;HexToDec99
                                                    ; start in A
                                                    ; end with A = 10's, decOnes (also in X)

                                                    ;HexToDec255
                                                    ; start in A
                                                    ; end with Y = 100's, A = 10's, decOnes (also in X)

                                                    ;HexToDec999
                                                    ; start with A = high byte, Y = low byte
                                                    ; end with Y = 100's, A = 10's, decOnes (also in X)
                                                    ; requires 1 extra temp register on top of decOnes, could combine
                                                    ; these two if HexToDec65535 was eliminated...

                                                    ;HexToDec65535
                                                    ; start with A/Y (low/high) as 16 bit value
                                                    ; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
                                                    ; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


                                                    ASCII_0_OFFSET     = $30
                                                    temp               = zpy    ; byte in zeropage
                                                    hexHigh          = zpWord0    ; byte in zeropage
                                                    hexLow           = zpWord0+1    ; byte in zeropage


                                                HexToDec65535; SUBROUTINE
                                                    sty    hexHigh               ;3  @9
                                                    sta    hexLow                ;3  @12
                                                    tya
                                                    tax                          ;2  @14
                                                    lsr    a                     ;2  @16
                                                    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

                                                    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
                                                    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

                                                    ;at this point we have a number 1-65 that we have to times by 24,
                                                    ;add to original sum, and Mod 1024 to get a remainder 0-999
                                                 
                                                    sta    temp                  ;3  @25
                                                    asl    a                     ;2  @27
                                                    adc    temp                  ;3  @30  x3
                                                    tay                          ;2  @32
                                                    lsr    a                     ;2  @34
                                                    lsr    a                     ;2  @36
                                                    lsr    a                     ;2  @38
                                                    lsr    a                     ;2  @40
                                                    lsr    a                     ;2  @42
                                                    tax                          ;2  @44
                                                    tya                          ;2  @46
                                                    asl    a                     ;2  @48
                                                    asl    a                     ;2  @50
                                                    asl    a                     ;2  @52
                                                    clc                          ;2  @54
                                                    adc    hexLow                ;3  @57
                                                    sta    hexLow                ;3  @60
                                                    txa                          ;2  @62
                                                    adc    hexHigh               ;3  @65
                                                    sta    hexHigh               ;3  @68
                                                    ror    a                     ;2  @70
                                                    lsr    a                     ;2  @72
                                                    tay                          ;2  @74    integer divide 1,000 (result 0-65)

                                                    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
                                                    tax                          ;2  @78
                                                    lda    ShiftedBcdTab,x       ;4  @82
                                                    tax                          ;2  @84
                                                    rol    a                     ;2  @86
                                                    and    #$0F                  ;2  @88
                                                    ora    #ASCII_0_OFFSET
                                                    sta    decThousands          ;3  @91
                                                    txa                          ;2  @93
                                                    lsr    a                     ;2  @95
                                                    lsr    a                     ;2  @97
                                                    lsr    a                     ;2  @99
                                                    ora    #ASCII_0_OFFSET
                                                    sta    decTenThousands       ;3  @102

                                                    lda    hexLow                ;3  @105
                                                    cpy    temp                  ;3  @108
                                                    bmi    _doSubtract           ;2³ @110/111
                                                    beq    _useZero               ;2³ @112/113
                                                    adc    #23 + 24              ;2  @114
                                                _doSubtract
                                                    sbc    #23                   ;2  @116
                                                    sta    hexLow                ;3  @119
                                                _useZero
                                                    lda    hexHigh               ;3  @122
                                                    sbc    #0                    ;2  @124

                                                Start100s
                                                    and    #$03                  ;2  @126
                                                    tax                          ;2  @128   0,1,2,3
                                                    cmp    #2                    ;2  @130
                                                    rol    a                     ;2  @132   0,2,5,7
                                                    ora    #ASCII_0_OFFSET
                                                    tay                          ;2  @134   Y = Hundreds digit

                                                    lda    hexLow                ;3  @137
                                                    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
                                                    bcs    hex_doSub200             ;2³ @143/144

                                                hex_try200
                                                    cmp    #200                  ;2  @145
                                                    bcc    hex_try100               ;2³ @147/148
                                                hex_doSub200
                                                    iny                          ;2  @149
                                                    iny                          ;2  @151
                                                    sbc    #200                  ;2  @153
                                                hex_try100
                                                    cmp    #100                  ;2  @155
                                                    bcc    HexToDec99            ;2³ @157/158
                                                    iny                          ;2  @159
                                                    sbc    #100                  ;2  @161

                                                HexToDec99; SUBROUTINE
                                                    lsr    a                     ;2  @163
                                                    tax                          ;2  @165
                                                    lda    ShiftedBcdTab,x       ;4  @169
                                                    tax                          ;2  @171
                                                    rol    a                     ;2  @173
                                                    and    #$0F                  ;2  @175
                                                    ora    #ASCII_0_OFFSET
                                                    sta    decOnes               ;3  @178
                                                    txa                          ;2  @180
                                                    lsr    a                     ;2  @182
                                                    lsr    a                     ;2  @184
                                                    lsr    a                     ;2  @186
                                                    ora    #ASCII_0_OFFSET

                                                    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
                                                    sty  decHundreds
                                                    sta  decTens
                                                    ldx  decOnes
                                                    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


                                                HexToDec999; SUBROUTINE
                                                    sty    hexLow                ;3  @9
                                                    jmp    Start100s             ;3  @12

                                                Mod100Tab
                                                    .byte 0,56,12,56+12

                                                ShiftedBcdTab
                                                    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
                                                    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
                                                    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
                                                    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
                                                    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

                                                decTenThousands       .byte  0
                                                decThousands        .byte  0
                                                decHundreds        .byte  0
                                                decTens            .byte  0
                                                decOnes           .byte  0
                                                            .byte  0        ; zero-terminate the decimal output string
                                                    .pend
                                                    ;    src line: library:/prog8lib/conv.p8:689

                                                byte2decimal    .proc
                                                  
                                                        cmp  #0
                                                        bpl  +
                                                        eor  #255
                                                        clc
                                                        adc  #1
                                                +        jmp  ubyte2decimal
                                                    .pend
                                    

                                                ubyte2hex    .proc
                                                 
                                                        stx  zpx
                                                        pha
                                                        and  #$0f
                                                        tax
                                                        ldy  _hex_digits,x
                                                        pla
                                                        lsr  a
                                                        lsr  a
                                                        lsr  a
                                                        lsr  a
                                                        tax
                                                        lda  _hex_digits,x
                                                        ldx  zpx
                                                        rts

                                                _hex_digits    .text "0123456789abcdef"    ; can probably be reused for other stuff as well
                                                    .pend
                                 

                                                uword2hex    .proc
                                                    ;    src line: library:/prog8lib/conv.p8:726
                                                        sta  zpx
                                                        tya
                                                        jsr  ubyte2hex
                                                        sta  output
                                                        sty  output+1
                                                        lda  zpx
                                                        jsr  ubyte2hex
                                                        sta  output+2
                                                        sty  output+3
                                                        rts
                                                output        .text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
                                                    .pend
                                    
                                    .pend


;***********************
; #LIBRARY : 'cx16logo' 
;***********************

cx16logo    .proc
 
; non-zeropage variables
logo_lines    .word  prog8_interned_strings.string_0, prog8_interned_strings.string_1, prog8_interned_strings.string_2, prog8_interned_strings.string_3, prog8_interned_strings.string_4, prog8_interned_strings.string_5, prog8_interned_strings.string_6

; subroutines in this block
 
    .pend

;***********************
; #LIBRARY : 'txt' 
;***********************

                    txt    .proc

                    DEFAULT_WIDTH  = $28    ;   40
                    DEFAULT_HEIGHT = $19    ;   25

                    ; non-zeropage variables

                    chrout = $ffd2

                    ; subroutines in this block
 
                    nl    .proc

                        lda  #$8d
                        jmp  txt.chrout

                    .pend
                     
                    spc    .proc
                     
                        lda  #$20
                        jmp  txt.chrout

                    .pend
 
            column    .proc
             
                    sec
                    jsr  c64.PLOT
                    tay
                    clc
                    jmp  c64.PLOT
                    
            .pend
 
            fill_screen    .proc
             
                    pha
                    tya
                    jsr  clear_screencolors
                    pla
                    jmp  clear_screenchars
                    
            .pend
 
            clear_screenchars    .proc
             
                    ldy  #250
            -        
                    sta  c64.Screen+250*0-1,y
                    sta  c64.Screen+250*1-1,y
                    sta  c64.Screen+250*2-1,y
                    sta  c64.Screen+250*3-1,y
                    dey
                    bne  -
                    
                    rts

            .pend
 
            clear_screencolors    .proc

                    ldy  #250
            -        
                    sta  c64.Colors+250*0-1,y
                    sta  c64.Colors+250*1-1,y
                    sta  c64.Colors+250*2-1,y
                    sta  c64.Colors+250*3-1,y
                    dey
                    bne  -
                    rts
            .pend
 
            scroll_left    .proc
             
                    stx  zpx
                    bcc _scroll_screen

            +       ; scroll the screen and the color memory

                    ldx  #0
                    ldy  #38
            -
                    .for row=0, row<=24, row+=1
                        lda  c64.Screen + 40*row + 1,x
                        sta  c64.Screen + 40*row + 0,x
                        lda  c64.Colors + 40*row + 1,x
                        sta  c64.Colors + 40*row + 0,x
                    .next
                    inx
                    dey
                    bpl  -
                    rts

            _scroll_screen  ; scroll only the screen memory
                    ldx  #0
                    ldy  #38
            -
                    .for row=0, row<=24, row+=1
                        lda  c64.Screen + 40*row + 1,x
                        sta  c64.Screen + 40*row + 0,x
                    .next
                    inx
                    dey
                    bpl  -

                    ldx  zpx
                    rts
            .pend

            scroll_right    .proc
             
                    stx  zpx
                    bcc  _scroll_screen

            +       ; scroll the screen and the color memory
                    ldx  #38
            -
                    .for row=0, row<=24, row+=1
                        lda  c64.Screen + 40*row + 0,x
                        sta  c64.Screen + 40*row + 1,x
                        lda  c64.Colors + 40*row + 0,x
                        sta  c64.Colors + 40*row + 1,x
                    .next
                    dex
                    bpl  -
                    rts

            _scroll_screen  ; scroll only the screen memory
                    ldx  #38
            -
                    .for row=0, row<=24, row+=1
                        lda  c64.Screen + 40*row + 0,x
                        sta  c64.Screen + 40*row + 1,x
                    .next
                    dex
                    bpl  -

                    ldx  zpx
                    rts
            .pend
 
            scroll_up    .proc
             
                    stx  zpx
                    bcc  _scroll_screen

            +       ; scroll the screen and the color memory
                    ldx #39
            -
                    .for row=1, row<=24, row+=1
                        lda  c64.Screen + 40*row,x
                        sta  c64.Screen + 40*(row-1),x
                        lda  c64.Colors + 40*row,x
                        sta  c64.Colors + 40*(row-1),x
                    .next
                    dex
                    bpl  -
                    rts

            _scroll_screen  ; scroll only the screen memory
                    ldx #39
            -
                    .for row=1, row<=24, row+=1
                        lda  c64.Screen + 40*row,x
                        sta  c64.Screen + 40*(row-1),x
                    .next
                    dex
                    bpl  -

                    ldx  zpx
                    rts
                .pend
 
            scroll_down    .proc
             
                    stx  zpx
                    bcc  _scroll_screen

            +       ; scroll the screen and the color memory
                    ldx #39
            -
                    .for row=23, row>=0, row-=1
                        lda  c64.Colors + 40*row,x
                        sta  c64.Colors + 40*(row+1),x
                        lda  c64.Screen + 40*row,x
                        sta  c64.Screen + 40*(row+1),x
                    .next
                    dex
                    bpl  -
                    rts

            _scroll_screen  ; scroll only the screen memory
                    ldx #39
            -
                    .for row=23, row>=0, row-=1
                        lda  c64.Screen + 40*row,x
                        sta  c64.Screen + 40*(row+1),x
                    .next
                    dex
                    bpl  -

                    ldx  zpx
                    rts
                .pend
 
            print    .proc
             
                    sta  zpy
                    sty  zpx
                    ldy  #0
            -        
                    lda  (zpy),y
                    beq  +
                    jsr  c64.CHROUT
                    iny
                    bne  -
            +        
                    rts         
            .pend
 
                    print_ub0    .proc
                     
                            stx  zpx
                            jsr  conv.ubyte2decimal
                            pha
                            tya
                            jsr  c64.CHROUT
                            pla
                            jsr  c64.CHROUT
                            txa
                            jsr  c64.CHROUT
                            ldx  zpx
                            rts
                    .pend
 
                            ; ----------------------------------------------------------------------- print_ub (dec)
                            ;   
                            ;   input   :   a   <- (unsigned byte);
                            ;   return  :   //
                            ;   output  :   a   -> (unsigned byte) -> decimal

                            print_ub    .proc

                                    stx  zpx
                                    jsr  conv.ubyte2decimal
                            _print_byte_digits
                                    pha
                                    cpy  #'0'
                                    beq  +
                                    tya
                                    jsr  c64.CHROUT
                                    pla
                                    jsr  c64.CHROUT
                                    jmp  print_ub_ones
                            +       
                                    pla
                                    cmp  #'0'
                                    beq  print_ub_ones
                                    jsr  c64.CHROUT
                            print_ub_ones   
                                    txa
                                    jsr  c64.CHROUT
                                    ldx  zpx
                                    rts
                                    
                            .pend

                    ; -----------------------------------------------------------------------

                    print_b    .proc
                     
                            stx  zpx
                            pha
                            cmp  #0
                            bpl  +
                            lda  #'-'
                            jsr  c64.CHROUT
                    +        pla
                            jsr  conv.byte2decimal
                            jmp  print_ub._print_byte_digits
                    .pend
 
                    print_ubhex    .proc
                     
                            stx  zpx
                            bcc  +
                            pha
                            lda  #'$'
                            jsr  c64.CHROUT
                            pla
                    +        jsr  conv.ubyte2hex
                            jsr  c64.CHROUT
                            tya
                            jsr  c64.CHROUT
                            ldx  zpx
                            rts
                    .pend
 
                    print_ubbin    .proc
                     
                            stx  zpx
                            sta  zpy
                            bcc  +
                            lda  #'%'
                            jsr  c64.CHROUT
                    +        
                            ldy  #8
                    -        
                            lda  #'0'
                            asl  zpy
                            bcc  +
                            lda  #'1'
                    +        
                            jsr  c64.CHROUT
                            dey
                            bne  -
                            ldx  zpx
                            rts
                    .pend

                    print_uwbin    .proc
                     
                            pha
                            tya
                            jsr  print_ubbin
                            pla
                            clc
                            jmp  print_ubbin
                    .pend
 

                    print_uwhex    .proc

                            pha
                            tya
                            jsr  print_ubhex
                            pla
                            clc
                            jmp  print_ubhex
                    .pend
 

                    print_uw0    .proc
                     
                            stx  zpx
                            jsr  conv.uword2decimal
                            ldy  #0
                    -        
                            lda  conv.uword2decimal.decTenThousands,y
                            beq  +
                            jsr  c64.CHROUT
                            iny
                            bne  -
                    +        
                            ldx  zpx
                            rts
                    .pend

                    print_uw    .proc
                     
                            stx  zpx
                            jsr  conv.uword2decimal
                            ldx  zpx
                            ldy  #0
                    -        
                            lda  conv.uword2decimal.decTenThousands,y
                            beq  _allzero
                            cmp  #'0'
                            bne  _gotdigit
                            iny
                            bne  -
                    _gotdigit
                            jsr  c64.CHROUT
                            iny
                            lda  conv.uword2decimal.decTenThousands,y
                            bne  _gotdigit
                            rts
                    _allzero
                            lda  #'0'
                            jmp  c64.CHROUT
                    .pend

                    print_w    .proc
                      
                            cpy  #0
                            bpl  +
                            pha
                            lda  #'-'
                            jsr  c64.CHROUT
                            tya
                            eor  #255
                            tay
                            pla
                            eor  #255
                            clc
                            adc  #1
                            bcc  +
                            iny
                    +        
                            jmp  print_uw
                    .pend
 
                input_chars    .proc
                 
                        sta  zpWord0
                        sty  zpWord0+1
                        ldy  #0                ; char counter = 0
                -        
                        jsr  c64.CHRIN
                        cmp  #$0d            ; return (ascii 13) pressed?
                        beq  +                ; yes, end.
                        sta  (zpWord0),y    ; else store char in buffer
                        iny
                        bne  -
                +        
                        lda  #0
                        sta  (zpWord0),y    ; finish string with 0 byte
                        rts
                .pend

            setchr    .proc
                    pha
                    tya
                    asl  a
                    tay
                    lda  _screenrows+1,y
                    sta  _mod+2
                    txa
                    clc
                    adc  _screenrows,y
                    sta  _mod+1
                    bcc  +
                    inc  _mod+2
            +        
                    pla
            _mod        
                    sta  $ffff        ; modified
                    rts

            _screenrows    .word  $0400 + range(0, 1000, 40)
            .pend
 
            getchr    .proc
             
                    pha
                    tya
                    asl  a
                    tay
                    lda  setchr._screenrows+1,y
                    sta  _mod+2
                    pla
                    clc
                    adc  setchr._screenrows,y
                    sta  _mod+1
                    bcc  _mod
                    inc  _mod+2
            _mod        
                    lda  $ffff        ; modified
                    rts
            .pend

            setclr    .proc
             
                    pha
                    tya
                    asl  a
                    tay
                    lda  _colorrows+1,y
                    sta  _mod+2
                    txa
                    clc
                    adc  _colorrows,y
                    sta  _mod+1
                    bcc  +
                    inc  _mod+2
            +        
                    pla
            _mod        
                    sta  $ffff        ; modified
                    rts

            _colorrows    .word  $d800 + range(0, 1000, 40)
            .pend
 
            getclr    .proc
             
                    pha
                    tya
                    asl  a
                    tay
                    lda  setclr._colorrows+1,y
                    sta  _mod+2
                    pla
                    clc
                    adc  setclr._colorrows,y
                    sta  _mod+1
                    bcc  _mod
                    inc  _mod+2
            _mod        
                    lda  $ffff        ; modified
                    rts
            .pend
 
            plot    .proc
             
                    stx  zpx
                    tax
                    clc
                    jsr  c64.PLOT
                    ldx  zpx
                    rts
                .pend
 

                width    .proc
                 
                        jsr  c64.SCREEN
                        txa
                        rts
                .pend
                    ;    src line: library:/prog8lib/c64/textio.p8:604

                height    .proc
                    ;    src line: library:/prog8lib/c64/textio.p8:606
                        jsr  c64.SCREEN
                        tya
                        rts
                    .pend
    .pend

;***********************
; #LIBRARY : 'c64' 
;***********************

c64    .proc
     
    TIME_HI = $a0
    TIME_MID = $a1
    TIME_LO = $a2
    STATUS = $90
    STKEY = $91
    SFDX = $cb
                        COLOR = $0286
    HIBASE = $0288
    CINV = $0314
    CBINV = $0316
    NMINV = $0318
    NMI_VEC = $fffa
    RESET_VEC = $fffc
    IRQ_VEC = $fffe
    SPRPTR0 = $07f8
    SPRPTR1 = $07f9
    SPRPTR2 = $07fa
    SPRPTR3 = $07fb
    SPRPTR4 = $07fc
    SPRPTR5 = $07fd
    SPRPTR6 = $07fe
    SPRPTR7 = $07ff
    SPRPTR = $07f8
    SP0X = $d000
    SP0Y = $d001
    SP1X = $d002
    SP1Y = $d003
    SP2X = $d004
    SP2Y = $d005
    SP3X = $d006
    SP3Y = $d007
    SP4X = $d008
    SP4Y = $d009
    SP5X = $d00a
    SP5Y = $d00b
    SP6X = $d00c
    SP6Y = $d00d
    SP7X = $d00e
    SP7Y = $d00f
    SPXY = $d000
    SPXYW = $d000
    MSIGX = $d010
    SCROLY = $d011
    RASTER = $d012
    LPENX = $d013
    LPENY = $d014
    SPENA = $d015
    SCROLX = $d016
    YXPAND = $d017
    VMCSB = $d018
    VICIRQ = $d019
    IREQMASK = $d01a
    SPBGPR = $d01b
    SPMC = $d01c
    XXPAND = $d01d
    SPSPCL = $d01e
    SPBGCL = $d01f
                        EXTCOL = $d020
                        BGCOL0 = $d021
                        BGCOL1 = $d022
                        BGCOL2 = $d023
                        BGCOL4 = $d024
    SPMC0 = $d025
    SPMC1 = $d026
    SP0COL = $d027
    SP1COL = $d028
    SP2COL = $d029
    SP3COL = $d02a
    SP4COL = $d02b
    SP5COL = $d02c
    SP6COL = $d02d
    SP7COL = $d02e
    SPCOL = $d027
    CIA1PRA = $dc00
    CIA1PRB = $dc01
    CIA1DDRA = $dc02
    CIA1DDRB = $dc03
    CIA1TAL = $dc04
    CIA1TAH = $dc05
    CIA1TBL = $dc06
    CIA1TBH = $dc07
    CIA1TOD10 = $dc08
    CIA1TODSEC = $dc09
    CIA1TODMMIN = $dc0a
    CIA1TODHR = $dc0b
    CIA1SDR = $dc0c
    CIA1ICR = $dc0d
    CIA1CRA = $dc0e
    CIA1CRB = $dc0f
    CIA2PRA = $dd00
    CIA2PRB = $dd01
    CIA2DDRA = $dd02
    CIA2DDRB = $dd03
    CIA2TAL = $dd04
    CIA2TAH = $dd05
    CIA2TBL = $dd06
    CIA2TBH = $dd07
    CIA2TOD10 = $dd08
    CIA2TODSEC = $dd09
    CIA2TODMIN = $dd0a
    CIA2TODHR = $dd0b
    CIA2SDR = $dd0c
    CIA2ICR = $dd0d
    CIA2CRA = $dd0e
    CIA2CRB = $dd0f
    FREQLO1 = $d400
    FREQHI1 = $d401
    FREQ1 = $d400
    PWLO1 = $d402
    PWHI1 = $d403
    PW1 = $d402
    CR1 = $d404
    AD1 = $d405
    SR1 = $d406
    FREQLO2 = $d407
    FREQHI2 = $d408
    FREQ2 = $d407
    PWLO2 = $d409
    PWHI2 = $d40a
    PW2 = $d409
    CR2 = $d40b
    AD2 = $d40c
    SR2 = $d40d
    FREQLO3 = $d40e
    FREQHI3 = $d40f
    FREQ3 = $d40e
    PWLO3 = $d410
    PWHI3 = $d411
    PW3 = $d410
    CR3 = $d412
    AD3 = $d413
    SR3 = $d414
    FCLO = $d415
    FCHI = $d416
    FC = $d415
    RESFILT = $d417
    MVOL = $d418
    POTX = $d419
    POTY = $d41a
    OSC3 = $d41b
    ENV3 = $d41c
                    Screen = $0400
                    Colors = $d800

; non-zeropage variables
                    STROUT = $ab1e
                    CLEARSCR = $e544
                    HOMECRSR = $e566
    IRQDFRT = $ea31
    IRQDFEND = $ea81
                        CINT = $ff81
                        IOINIT = $ff84
    RAMTAS = $ff87
                        RESTOR = $ff8a
    VECTOR = $ff8d
    SETMSG = $ff90
    SECOND = $ff93
    TKSA = $ff96
    MEMTOP = $ff99
    MEMBOT = $ff9c
    SCNKEY = $ff9f
    SETTMO = $ffa2
    ACPTR = $ffa5
    CIOUT = $ffa8
    UNTLK = $ffab
    UNLSN = $ffae
    LISTEN = $ffb1
    TALK = $ffb4
    READST = $ffb7
    SETLFS = $ffba
    SETNAM = $ffbd
    OPEN = $ffc0
    CLOSE = $ffc3
    CHKIN = $ffc6
    CHKOUT = $ffc9
    CLRCHN = $ffcc
                    CHRIN = $ffcf
                    CHROUT = $ffd2
    LOAD = $ffd5
    SAVE = $ffd8
    SETTIM = $ffdb
    RDTIM = $ffde
    STOP = $ffe1
    GETIN = $ffe4
    CLALL = $ffe7
    UDTIM = $ffea
                    SCREEN = $ffed
                    PLOT = $fff0
    IOBASE = $fff3

; subroutines in this block
 
 
STOP2    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:228
        txa
        pha
        jsr  c64.STOP
        beq  +
        pla
        tax
        lda  #0
        rts
+       pla
        tax
        lda  #1
        rts
    .pend
    ;    src line: library:/prog8lib/c64/syslib.p8:244

RDTIM16    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:246
        stx  zpx
        jsr  c64.RDTIM
        pha
        txa
        tay
        pla
        ldx  zpx
        rts
    .pend
    ;    src line: library:/prog8lib/c64/syslib.p8:262

                            init_system    .proc

                                    sei
                                    cld
                                    lda  #%00101111
                                    sta  $00
                                    lda  #%00100111
                                    sta  $01
                                    jsr  c64.IOINIT
                                    jsr  c64.RESTOR
                                    jsr  c64.CINT
                                    lda  #6
                                    sta  c64.EXTCOL
                                    lda  #7
                                    sta  c64.COLOR
                                    lda  #0
                                    sta  c64.BGCOL0
                                    jsr  disable_runstop_and_charsetswitch
                                    clc
                                    clv
                                    cli
                                    rts
                                .pend
   

                        init_system_phase2    .proc
                            ;    src line: library:/prog8lib/c64/syslib.p8:294
                                rts     ; no phase 2 steps on the C64
                            .pend
                            ;    src line: library:/prog8lib/c64/syslib.p8:299

                        cleanup_at_exit    .proc
                            ;    src line: library:/prog8lib/c64/syslib.p8:301
                                jmp  c64.enable_runstop_and_charsetswitch
                            .pend
                            ;    src line: library:/prog8lib/c64/syslib.p8:306

                                            disable_runstop_and_charsetswitch    .proc
                                               
                                                    lda  #$80
                                                    sta  657    ; disable charset switching
                                                    lda  #239
                                                    sta  808    ; disable run/stop key
                                                    rts
                                                .pend
 

                                                    enable_runstop_and_charsetswitch    .proc
                                                     
                                                            lda  #0
                                                            sta  657    ; enable charset switching
                                                            lda  #237
                                                            sta  808    ; enable run/stop key
                                                            rts
                                                        .pend
 

set_irq    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:327
            sta  _modified+1
            sty  _modified+2
            lda  #0
            adc  #0
            sta  _use_kernal
        sei
        lda  #<_irq_handler
        sta  c64.CINV
        lda  #>_irq_handler
        sta  c64.CINV+1
        cli
        rts
_irq_handler    jsr  _irq_handler_init
_modified    jsr  $ffff                      ; modified
        jsr  _irq_handler_end
        lda  _use_kernal
        bne  +
        lda  #$ff
        sta  c64.VICIRQ            ; acknowledge raster irq
        lda  c64.CIA1ICR        ; acknowledge CIA1 interrupt
        ; end irq processing - don't use kernal's irq handling
        pla
        tay
        pla
        tax
        pla
        rti
+        jmp  c64.IRQDFRT        ; continue with normal kernal irq routine

_use_kernal     .byte  0

_irq_handler_init
        ; save all zp scratch registers and the X register as these might be clobbered by the irq routine
        stx  IRQ_X_REG
        lda  zpy
        sta  IRQ_SCRATCH_ZPB1
        lda  zpx
        sta  IRQ_SCRATCH_ZPREG
        lda  zpWord0
        sta  IRQ_SCRATCH_ZPWORD1
        lda  zpWord0+1
        sta  IRQ_SCRATCH_ZPWORD1+1
        lda  zpWord1
        sta  IRQ_SCRATCH_ZPWORD2
        lda  zpWord1+1
        sta  IRQ_SCRATCH_ZPWORD2+1
        ; stack protector; make sure we don't clobber the top of the evaluation stack
        dex
        dex
        dex
        dex
        dex
        dex
        cld
        rts

_irq_handler_end
        ; restore all zp scratch registers and the X register
        lda  IRQ_SCRATCH_ZPB1
        sta  zpy
        lda  IRQ_SCRATCH_ZPREG
        sta  zpx
        lda  IRQ_SCRATCH_ZPWORD1
        sta  zpWord0
        lda  IRQ_SCRATCH_ZPWORD1+1
        sta  zpWord0+1
        lda  IRQ_SCRATCH_ZPWORD2
        sta  zpWord1
        lda  IRQ_SCRATCH_ZPWORD2+1
        sta  zpWord1+1
        ldx  IRQ_X_REG
        rts

IRQ_X_REG        .byte  0
IRQ_SCRATCH_ZPB1    .byte  0
IRQ_SCRATCH_ZPREG    .byte  0
IRQ_SCRATCH_ZPWORD1    .word  0
IRQ_SCRATCH_ZPWORD2    .word  0
    .pend
    ;    src line: library:/prog8lib/c64/syslib.p8:410

restore_irq    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:411
        sei
        lda  #<c64.IRQDFRT
        sta  c64.CINV
        lda  #>c64.IRQDFRT
        sta  c64.CINV+1
        lda  #0
        sta  c64.IREQMASK    ; disable raster irq
        lda  #%10000001
        sta  c64.CIA1ICR    ; restore CIA1 irq
        cli
        rts
    .pend
    ;    src line: library:/prog8lib/c64/syslib.p8:426

set_rasterirq    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:427
            sta  _modified+1
            sty  _modified+2
            lda  #0
            adc  #0
            sta  set_irq._use_kernal
        lda  cx16.r0
        ldy  cx16.r0+1
        sei
        jsr  _setup_raster_irq
        lda  #<_raster_irq_handler
        sta  c64.CINV
        lda  #>_raster_irq_handler
        sta  c64.CINV+1
        cli
        rts

_raster_irq_handler
        jsr  set_irq._irq_handler_init
_modified    jsr  $ffff              ; modified
        jsr  set_irq._irq_handler_end
                lda  #$ff
                sta  c64.VICIRQ            ; acknowledge raster irq
        lda  set_irq._use_kernal
        bne  +
        ; end irq processing - don't use kernal's irq handling
        pla
        tay
        pla
        tax
        pla
        rti
+        jmp  c64.IRQDFRT                ; continue with kernal irq routine

_setup_raster_irq
        pha
        lda  #%01111111
        sta  c64.CIA1ICR    ; "switch off" interrupts signals from cia-1
        sta  c64.CIA2ICR    ; "switch off" interrupts signals from cia-2
        and  c64.SCROLY
        sta  c64.SCROLY     ; clear most significant bit of raster position
        lda  c64.CIA1ICR    ; ack previous irq
        lda  c64.CIA2ICR    ; ack previous irq
        pla
        sta  c64.RASTER     ; set the raster line number where interrupt should occur
        cpy  #0
        beq  +
        lda  c64.SCROLY
        ora  #%10000000
        sta  c64.SCROLY     ; set most significant bit of raster position
+        lda  #%00000001
        sta  c64.IREQMASK   ;enable raster interrupt signals from vic
        rts
    .pend
    .pend


;***********************
; #LIBRARY : 'sys' 
;***********************

sys    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:487
    target = $40

; non-zeropage variables

; subroutines in this block
 
reset_system    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:495
            sei
            lda  #14
            sta  $01        ; bank the kernal in
            jmp  (c64.RESET_VEC)
    .pend
    ;    src line: library:/prog8lib/c64/syslib.p8:514

waitvsync    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:517
-           bit  c64.SCROLY
            bpl  -
-           bit  c64.SCROLY
            bmi  -
            rts
    .pend
 
internal_stringcopy    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:537
        sta  zpWord0
        sty  zpWord0+1
        lda  cx16.r0
        ldy  cx16.r0+1
        jmp  prog8_lib.strcpy
    .pend
    
    
    ;    src line: library:/prog8lib/c64/syslib.p8:546

                                        memcopy    .proc
                                         
                                                    ldx  cx16.r0
                                                    stx  zpWord0        ; source in ZP
                                                    ldx  cx16.r0+1
                                                    stx  zpWord0+1
                                                    
                                                    ldx  cx16.r1
                                                    stx  zpWord1        ; target in ZP
                                                    ldx  cx16.r1+1
                                                    stx  zpWord1+1
                                                    
                                                    cpy  #0
                                                    bne  _longcopy

                                                    ; copy <= 255 bytes
                                                    tay
                                                    bne  _copyshort
                                                    rts     ; nothing to copy

                                        _copyshort
                                                    ; decrease source and target pointers so we can simply index by Y
                                                    lda  zpWord0
                                                    bne  +
                                                    dec  zpWord0+1
                                        +           dec  zpWord0
                                                    lda  zpWord1
                                                    bne  +
                                                    dec  zpWord1+1
                                        +           dec  zpWord1

                                        -           lda  (zpWord0),y
                                                    sta  (zpWord1),y
                                                    dey
                                                    bne  -
                                                    rts

                                        _longcopy
                                                    sta  zpy        ; lsb(count) = remainder in last page
                                                    tya
                                                    tax                         ; x = num pages (1+)
                                                    ldy  #0
                                        -           lda  (zpWord0),y
                                                    sta  (zpWord1),y
                                                    iny
                                                    bne  -
                                                    inc  zpWord0+1
                                                    inc  zpWord1+1
                                                    dex
                                                    bne  -
                                                    ldy  zpy
                                                    bne  _copyshort
                                                    rts
                                            .pend
                                            ;    src line: library:/prog8lib/c64/syslib.p8:602

memset    .proc
   
            ldy  cx16.r0
                            sty  zpWord0
            ldy  cx16.r0+1
                            sty  zpWord0+1
            ldx  cx16.r1
                            ldy  cx16.r1+1
                            
            jmp  prog8_lib.memset
    .pend
  

memsetw    .proc
 
            ldx  cx16.r0
                        stx  zpWord0
            ldx  cx16.r0+1
                        stx  zpWord0+1
            ldx  cx16.r1
                        stx  zpWord1
            ldx  cx16.r1+1
                        stx  zpWord1+1
                        
            jmp  prog8_lib.memsetw
    .pend
 
.pend

;***********************
; #LIBRARY : 'cx16' ----
;***********************

cx16    .proc
    ;    src line: library:/prog8lib/c64/syslib.p8:681
    r0 = $cf00
    r1 = $cf02
    r2 = $cf04
    r3 = $cf06
    r4 = $cf08
    r5 = $cf0a
    r6 = $cf0c
    r7 = $cf0e
    r8 = $cf10
    r9 = $cf12
    r10 = $cf14
    r11 = $cf16
    r12 = $cf18
    r13 = $cf1a
    r14 = $cf1c
    r15 = $cf1e
    
    r0s = $cf00
    r1s = $cf02
    r2s = $cf04
    r3s = $cf06
    r4s = $cf08
    r5s = $cf0a
    r6s = $cf0c
    r7s = $cf0e
    r8s = $cf10
    r9s = $cf12
    r10s = $cf14
    r11s = $cf16
    r12s = $cf18
    r13s = $cf1a
    r14s = $cf1c
    r15s = $cf1e
    r0L = $cf00
    r1L = $cf02
    r2L = $cf04
    r3L = $cf06
    r4L = $cf08
    r5L = $cf0a
    r6L = $cf0c
    r7L = $cf0e
    r8L = $cf10
    r9L = $cf12
    r10L = $cf14
    r11L = $cf16
    r12L = $cf18
    r13L = $cf1a
    r14L = $cf1c
    r15L = $cf1e
    r0H = $cf01
    r1H = $cf03
    r2H = $cf05
    r3H = $cf07
    r4H = $cf09
    r5H = $cf0b
    r6H = $cf0d
    r7H = $cf0f
    r8H = $cf11
    r9H = $cf13
    r10H = $cf15
    r11H = $cf17
    r12H = $cf19
    r13H = $cf1b
    r14H = $cf1d
    r15H = $cf1f
    r0sL = $cf00
    r1sL = $cf02
    r2sL = $cf04
    r3sL = $cf06
    r4sL = $cf08
    r5sL = $cf0a
    r6sL = $cf0c
    r7sL = $cf0e
    r8sL = $cf10
    r9sL = $cf12
    r10sL = $cf14
    r11sL = $cf16
    r12sL = $cf18
    r13sL = $cf1a
    r14sL = $cf1c
    r15sL = $cf1e
    r0sH = $cf01
    r1sH = $cf03
    r2sH = $cf05
    r3sH = $cf07
    r4sH = $cf09
    r5sH = $cf0b
    r6sH = $cf0d
    r7sH = $cf0f
    r8sH = $cf11
    r9sH = $cf13
    r10sH = $cf15
    r11sH = $cf17
    r12sH = $cf19
    r13sH = $cf1b
    r14sH = $cf1d
    r15sH = $cf1f

; non-zeropage variables

; subroutines in this block
 
    .pend

;***********************
; #LIBRARY : 'diskio' 
;***********************
 
diskio    .proc
    ;    src line: library:/prog8lib/diskio.p8:7
first_byte     = 146     ; zp UBYTE
list_skip_disk_name     = 150     ; zp UBYTE
list_pattern     = 6     ; zp UWORD
list_blocks     = 8     ; zp UWORD
iteration_in_progress     = 249     ; zp UBYTE
have_first_byte     = 10     ; zp UBYTE

; non-zeropage variables
list_filename    ; PETSCII:"??????????????????????????????????????????????????"
    .byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
    .byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
    .byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
    .byte  $3f, $3f, $00

; subroutines in this block
 

lf_start_list    .proc
pattern_ptr     = 11     ; zp UWORD
drivenumber     = 13     ; zp UBYTE
; statements
 
    jsr  lf_end_list
 
    lda  pattern_ptr
    ldy  pattern_ptr+1
    sta  list_pattern
    sty  list_pattern+1
 
    lda  #1
    sta  list_skip_disk_name
    ;    src line: library:/prog8lib/diskio.p8:148
    sta  iteration_in_progress
    ;    src line: library:/prog8lib/diskio.p8:150
    stx  prog8_regsaveX
    ldy  #>prog8_interned_strings.string_7
    ldx  #<prog8_interned_strings.string_7
    lda  #1
    jsr  c64.SETNAM
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:151
    stx  prog8_regsaveX
    ldy  #0
    ldx  drivenumber
    lda  #12
    jsr  c64.SETLFS
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:152
    stx  prog8_regsaveX
    jsr  c64.OPEN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:153
    bcs  io_error
    ;    src line: library:/prog8lib/diskio.p8:155
    stx  prog8_regsaveX
    ldx  #12
    jsr  c64.CHKIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:156
    bcs  io_error
    ;    src line: library:/prog8lib/diskio.p8:159
    lda  #4
    sta  prog8_label_37_counter
prog8_label_36_repeat
    ;    src line: library:/prog8lib/diskio.p8:160
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    ldx  prog8_regsaveX
    dec  prog8_label_37_counter
    bne  prog8_label_36_repeat
    ;    src line: library:/prog8lib/diskio.p8:163
    jsr  c64.READST
    cmp  #0
    bne  prog8_label_38_if_end
    ;    src line: library:/prog8lib/diskio.p8:164
    lda  #1
    rts
prog8_label_38_if_end
    ;    src line: library:/prog8lib/diskio.p8:166
io_error
    ;    src line: library:/prog8lib/diskio.p8:167
    jsr  lf_end_list
    ;    src line: library:/prog8lib/diskio.p8:168
    lda  #0
    rts
; variables
prog8_label_37_counter = 81
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:171

lf_next_entry    .proc
blocks_msb     = 14     ; zp UBYTE
blocks_lsb     = 15     ; zp UBYTE
nameptr     = 19     ; zp UWORD
char     = 21     ; zp UBYTE
; statements
 
    lda  iteration_in_progress
    bne  prog8_label_39_if_end
    ;    src line: library:/prog8lib/diskio.p8:177
    lda  #0
    rts
prog8_label_39_if_end
    ;    src line: library:/prog8lib/diskio.p8:179
prog8_label_21_repeat
    ;    src line: library:/prog8lib/diskio.p8:180
    stx  prog8_regsaveX
    ldx  #12
    jsr  c64.CHKIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:182
    lda  #<list_filename
    ldy  #>list_filename
    sta  nameptr
    sty  nameptr+1
    
    ;    src line: library:/prog8lib/diskio.p8:183
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    sta  blocks_lsb
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:184
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    sta  blocks_msb
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:186
    jsr  c64.READST
    cmp  #0
    bne  close_end
    ;    src line: library:/prog8lib/diskio.p8:189
    lda  blocks_lsb
    ldy  blocks_msb
    sta  list_blocks
    sty  list_blocks+1
    ;    src line: library:/prog8lib/diskio.p8:192
prog8_label_14_whileloop
    ;    src line: library:/prog8lib/diskio.p8:192
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    ldx  prog8_regsaveX
    cmp  #$22
    beq  prog8_label_15_afterwhile
    ;    src line: library:/prog8lib/diskio.p8:193
    jsr  c64.READST
    cmp  #0
    bne  close_end
    ;    src line: library:/prog8lib/diskio.p8:192
    jmp  prog8_label_14_whileloop
    ;    src line: library:/prog8lib/diskio.p8:192
prog8_label_15_afterwhile
    ;    src line: library:/prog8lib/diskio.p8:198
prog8_label_18_repeat
    ;    src line: library:/prog8lib/diskio.p8:199
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    sta  char
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:200
    lda  char
    beq  prog8_label_16_after
    ;    src line: library:/prog8lib/diskio.p8:202
    lda  char
    cmp  #34
    beq  prog8_label_17_after
    ;    src line: library:/prog8lib/diskio.p8:204
    lda  char
    ldy  #0
    sta  (nameptr),y
    ;    src line: library:/prog8lib/diskio.p8:205
    inc  nameptr
    bne  +
    inc  nameptr+1
+
    ;    src line: library:/prog8lib/diskio.p8:198
    jmp  prog8_label_18_repeat
    ;    src line: library:/prog8lib/diskio.p8:203
prog8_label_17_after
    ;    src line: library:/prog8lib/diskio.p8:201
prog8_label_16_after
    ;    src line: library:/prog8lib/diskio.p8:208
    lda  #0
    ldy  #0
    sta  (nameptr),y
    ;    src line: library:/prog8lib/diskio.p8:210
prog8_label_19_whileloop
    ;    src line: library:/prog8lib/diskio.p8:210
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    ldx  prog8_regsaveX
    cmp  #0
    beq  prog8_label_20_afterwhile
    ;    src line: library:/prog8lib/diskio.p8:210
    jmp  prog8_label_19_whileloop
    ;    src line: library:/prog8lib/diskio.p8:210
prog8_label_20_afterwhile
    ;    src line: library:/prog8lib/diskio.p8:214
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:215
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:217
    lda  list_skip_disk_name
    bne  prog8_label_40_if_end
    ;    src line: library:/prog8lib/diskio.p8:218
    lda  list_pattern
    ora  list_pattern+1
    bne  prog8_label_41_if_end
    ;    src line: library:/prog8lib/diskio.p8:219
    lda  #1
    rts
prog8_label_41_if_end
    ;    src line: library:/prog8lib/diskio.p8:220
    lda  list_pattern
    sta  cx16.r0
    lda  list_pattern+1
    sta  cx16.r0+1
    
    ldy  #>list_filename
    lda  #<list_filename
    jsr  string.pattern_match
    cmp  #0
    beq  prog8_label_42_if_end
    ;    src line: library:/prog8lib/diskio.p8:221
    lda  #1
    rts
prog8_label_42_if_end
prog8_label_40_if_end
    ;    src line: library:/prog8lib/diskio.p8:223
    lda  #0
    sta  list_skip_disk_name
    ;    src line: library:/prog8lib/diskio.p8:179
    jmp  prog8_label_21_repeat
    ;    src line: library:/prog8lib/diskio.p8:226
close_end
    ;    src line: library:/prog8lib/diskio.p8:227
    jsr  lf_end_list
    ;    src line: library:/prog8lib/diskio.p8:228
    lda  #0
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:231

lf_end_list    .proc
; statements
 
    lda  iteration_in_progress
    beq  prog8_label_43_if_end
    ;    src line: library:/prog8lib/diskio.p8:234
    stx  prog8_regsaveX
    jsr  c64.CLRCHN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:235
    stx  prog8_regsaveX
    lda  #12
    jsr  c64.CLOSE
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:236
    lda  #0
    sta  iteration_in_progress
prog8_label_43_if_end
    ;    src line: library:/prog8lib/diskio.p8:231
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:243

f_open    .proc
filenameptr     = 22     ; zp UWORD
drivenumber     = 24     ; zp UBYTE
; statements
 
    jsr  f_close
    ;    src line: library:/prog8lib/diskio.p8:248
    stx  prog8_regsaveX
    ldy  filenameptr+1
    lda  filenameptr
    jsr  string.length
    tya
    pha
    ldy  filenameptr+1
    lda  filenameptr
    pha
    tya
    tay
    pla
    tax
    pla
    jsr  c64.SETNAM
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:249
    stx  prog8_regsaveX
    ldy  #0
    ldx  drivenumber
    lda  #11
    jsr  c64.SETLFS
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:250
    stx  prog8_regsaveX
    jsr  c64.OPEN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:251
    bcs  prog8_label_44_branch_else
    ;    src line: library:/prog8lib/diskio.p8:252
    jsr  c64.READST
    cmp  #0
    bne  prog8_label_45_if_end
    ;    src line: library:/prog8lib/diskio.p8:253
    lda  #1
    sta  iteration_in_progress
    ;    src line: library:/prog8lib/diskio.p8:254
    lda  #0
    sta  have_first_byte
    ;    src line: library:/prog8lib/diskio.p8:255
    stx  prog8_regsaveX
    ldx  #11
    jsr  c64.CHKIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:256
    bcs  prog8_label_46_branch_else
    ;    src line: library:/prog8lib/diskio.p8:257
    stx  prog8_regsaveX
    jsr  c64.CHRIN
    sta  first_byte
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:258
    jsr  c64.READST
    cmp  #0
    bne  prog8_label_47_if_end
    ;    src line: library:/prog8lib/diskio.p8:259
    lda  #1
    sta  have_first_byte
    ;    src line: library:/prog8lib/diskio.p8:260
    lda  #1
    rts
prog8_label_47_if_end
prog8_label_46_branch_else
prog8_label_45_if_end
prog8_label_44_branch_else
    ;    src line: library:/prog8lib/diskio.p8:265
    jsr  f_close
    ;    src line: library:/prog8lib/diskio.p8:266
    lda  #0
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:269

f_read    .proc
num_bytes     = 25     ; zp UWORD
bufferpointer     = 27     ; zp UWORD
; statements
 
    lda  iteration_in_progress
    sta  stack.lo,x
    dex
    jsr  prog8_lib.equalzero_b
    lda  num_bytes
    sta  stack.lo,x
    lda  num_bytes+1
    sta  stack.hi,x
    dex
    jsr  prog8_lib.equalzero_w
    jsr  prog8_lib.bitor_b
    inx
    lda  stack.lo,x
    beq  prog8_label_48_if_end
    ;    src line: library:/prog8lib/diskio.p8:275
    ldy  #>0
    lda  #<0
    rts
prog8_label_48_if_end
    ;    src line: library:/prog8lib/diskio.p8:277
    lda  #0
    sta  list_blocks
    sta  list_blocks+1
    
    ;    src line: library:/prog8lib/diskio.p8:278
    lda  have_first_byte
    beq  prog8_label_49_if_end
    ;    src line: library:/prog8lib/diskio.p8:279
    lda  #0
    sta  have_first_byte
    ;    src line: library:/prog8lib/diskio.p8:280
    lda  first_byte
    ldy  #0
    sta  (bufferpointer),y
    ;    src line: library:/prog8lib/diskio.p8:281
    inc  bufferpointer
    bne  +
    inc  bufferpointer+1
+
    ;    src line: library:/prog8lib/diskio.p8:282
    inc  list_blocks
    bne  +
    inc  list_blocks+1
+
    ;    src line: library:/prog8lib/diskio.p8:283
    lda  num_bytes
    bne  +
    dec  num_bytes+1
+       dec  num_bytes 
prog8_label_49_if_end
    ;    src line: library:/prog8lib/diskio.p8:286
    stx  prog8_regsaveX
    ldx  #11
    jsr  c64.CHKIN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:288
            lda  bufferpointer
            sta  m_in_buffer+1
            lda  bufferpointer+1
            sta  m_in_buffer+2
    ;    src line: library:/prog8lib/diskio.p8:294
    ldy  num_bytes+1
    lda  num_bytes
    sta  prog8_label_52_counter
    sty  prog8_label_52_counter+1
prog8_label_51_repeat    lda  prog8_label_52_counter
    bne  +
    lda  prog8_label_52_counter+1
    beq  prog8_label_50_repeatend
    lda  prog8_label_52_counter
    bne  +
    dec  prog8_label_52_counter+1
+               dec  prog8_label_52_counter
    ;    src line: library:/prog8lib/diskio.p8:295
                jsr  c64.CHRIN
                sta  cx16.r5
m_in_buffer     sta  $ffff
                inc  m_in_buffer+1
                bne  +
                inc  m_in_buffer+2
+               inc  list_blocks
                bne  +
                inc  list_blocks+1
+
    ;    src line: library:/prog8lib/diskio.p8:308
    lda  cx16.r5
    cmp  #<13
    bne  prog8_label_53_if_end
    lda  cx16.r5+1
    cmp  #>13
    bne  prog8_label_53_if_end
 
    jsr  c64.READST
    sta  first_byte
 
    and  #$40
    beq  prog8_label_54_if_end
 
    jsr  f_close
 
    lda  list_blocks
    bne  +
    dec  list_blocks+1
+       dec  list_blocks 
prog8_label_54_if_end
 
    lda  first_byte
    beq  prog8_label_55_if_end
 
    ldy  list_blocks+1
    lda  list_blocks
    rts
prog8_label_55_if_end
prog8_label_53_if_end
    jmp  prog8_label_51_repeat
prog8_label_50_repeatend
    ;    src line: library:/prog8lib/diskio.p8:318
    ldy  list_blocks+1
    lda  list_blocks
    rts
; variables
prog8_label_52_counter = 82
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:342

f_readline    .proc
    ;    src line: library:/prog8lib/diskio.p8:348
            sta  zpWord0
            sty  zpWord0+1
            ldx  #11
            jsr  c64.CHKIN              ; use channel 11 again for input
            ldy  #0
            lda  have_first_byte
            beq  _loop
            lda  #0
            sta  have_first_byte
            lda  first_byte
            sta  (zpWord0),y
            iny
_loop       jsr  c64.CHRIN
            sta  (zpWord0),y
            beq  _end
            iny
            cmp  #$0a
            beq  _line_end
            cmp  #$0d
            bne  _loop
_line_end   dey     ; get rid of the trailing end-of-line char
            lda  #0
            sta  (zpWord0),y
_end        rts
    .pend
    ;    src line: library:/prog8lib/diskio.p8:377

f_close    .proc
; statements
    ;    src line: library:/prog8lib/diskio.p8:379
    lda  iteration_in_progress
    beq  prog8_label_56_if_end
    ;    src line: library:/prog8lib/diskio.p8:380
    stx  prog8_regsaveX
    jsr  c64.CLRCHN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:381
    stx  prog8_regsaveX
    lda  #11
    jsr  c64.CLOSE
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:382
    lda  #0
    sta  iteration_in_progress
prog8_label_56_if_end
    ;    src line: library:/prog8lib/diskio.p8:377
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:417

f_close_w    .proc
; statements
    ;    src line: library:/prog8lib/diskio.p8:419
    stx  prog8_regsaveX
    jsr  c64.CLRCHN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:420
    stx  prog8_regsaveX
    lda  #14
    jsr  c64.CLOSE
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:417
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:497

load    .proc
address_override     = 29     ; zp UWORD
filenameptr     = 31     ; zp UWORD
drivenumber     = 33     ; zp UBYTE
; statements
    ;    src line: library:/prog8lib/diskio.p8:497
    ;    src line: library:/prog8lib/diskio.p8:497
    ;    src line: library:/prog8lib/diskio.p8:497
    ;    src line: library:/prog8lib/diskio.p8:498
    lda  drivenumber
    sta  diskio.load_headerless_cx16.drivenumber
    
    lda  filenameptr
    ldy  filenameptr+1
    sta  diskio.load_headerless_cx16.filenameptr
    sty  diskio.load_headerless_cx16.filenameptr+1
    
    lda  address_override
    ldy  address_override+1
    sta  diskio.load_headerless_cx16.address_override
    sty  diskio.load_headerless_cx16.address_override+1
    
    lda  #0
    sta  diskio.load_headerless_cx16.headerless
    jmp  load_headerless_cx16
; variables

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/diskio.p8:527

load_headerless_cx16    .proc
headerless     = 57     ; zp UBYTE
address_override     = 58     ; zp UWORD
filenameptr     = 60     ; zp UWORD
drivenumber     = 62     ; zp UBYTE
secondary     = 63     ; zp UBYTE
; statements
 
    stx  prog8_regsaveX
    ldy  filenameptr+1
    lda  filenameptr
    jsr  string.length
    tya
    pha
    ldy  filenameptr+1
    lda  filenameptr
    pha
    tya
    tay
    pla
    tax
    pla
    jsr  c64.SETNAM
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:529
    ;    src line: library:/prog8lib/diskio.p8:529
    lda  #1
    sta  secondary
    ;    src line: library:/prog8lib/diskio.p8:530
    lda  #0
    sta  cx16.r1
    sta  cx16.r1+1
    
    ;    src line: library:/prog8lib/diskio.p8:531
    lda  address_override
    ora  address_override+1
    beq  prog8_label_57_if_end
    ;    src line: library:/prog8lib/diskio.p8:532
    lda  #0
    sta  secondary
prog8_label_57_if_end
    ;    src line: library:/prog8lib/diskio.p8:533
    lda  headerless
    beq  prog8_label_58_if_end
    ;    src line: library:/prog8lib/diskio.p8:534
    lda  secondary
    ora  #2
    sta  secondary
prog8_label_58_if_end
    ;    src line: library:/prog8lib/diskio.p8:535
    stx  prog8_regsaveX
    ldy  secondary
    ldx  drivenumber
    lda  #1
    jsr  c64.SETLFS
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:536
            stx  zpx
            lda  #0
            ldx  address_override
            ldy  address_override+1
            jsr  c64.LOAD
            bcs  +
            stx  cx16.r1
            sty  cx16.r1+1
+           ldx  zpx
    ;    src line: library:/prog8lib/diskio.p8:548
    stx  prog8_regsaveX
    jsr  c64.CLRCHN
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:549
    stx  prog8_regsaveX
    lda  #1
    jsr  c64.CLOSE
    ldx  prog8_regsaveX
    ;    src line: library:/prog8lib/diskio.p8:550
    lda  cx16.r1
    ldy  cx16.r1+1
    rts
; variables
prog8_regsaveX     .byte  0

; non-zeropage variables
    .pend
prog8_init_vars    .block
    ;    src line: library:/prog8lib/diskio.p8:106
    lda  #0
    sta  list_skip_disk_name
    ;    src line: library:/prog8lib/diskio.p8:107
    sta  list_pattern
    sta  list_pattern+1
    
    ;    src line: library:/prog8lib/diskio.p8:108
    lda  #0
    sta  list_blocks
    sta  list_blocks+1
    
    ;    src line: library:/prog8lib/diskio.p8:109
    lda  #0
    sta  iteration_in_progress
    ;    src line: library:/prog8lib/diskio.p8:110
    sta  first_byte
    ;    src line: library:/prog8lib/diskio.p8:111
    sta  have_first_byte
    rts
    .bend
    .pend

            ;***********************
            ; #LIBRARY : 'string' 
            ;***********************

            string    .proc
 
            ; non-zeropage variables

            ; subroutines in this block
             

            length    .proc
                
                    sta  zpWord0
                    sty  zpWord0+1
                    ldy  #0
            -        lda  (zpWord0),y
                    beq  +
                    iny
                    bne  -
            +        rts
                .pend
                

            left    .proc
             
                            ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                    ldy  cx16.r0
                    sty  zpWord0
                    ldy  cx16.r0+1
                    sty  zpWord0+1
                    ldy  cx16.r1
                    sty  zpWord1
                    ldy  cx16.r1+1
                    sty  zpWord1+1
                    tay
                    lda  #0
                    sta  (zpWord1),y
                    cpy  #0
                    bne  _loop
                    rts
            _loop        dey
                    lda  (zpWord0),y
                    sta  (zpWord1),y
                    cpy  #0
                    bne  _loop
            +        rts
                .pend
 

            right    .proc
                ;    src line: library:/prog8lib/string.p8:58
                            ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                            sta  zpy
                            lda  cx16.r0
                            ldy  cx16.r0+1
                            jsr  string.length
                            tya
                            sec
                            sbc  zpy
                            clc
                            adc  cx16.r0
                    sta  zpWord0
                    lda  cx16.r0+1
                    adc  #0
                    sta  zpWord0+1
                    ldy  cx16.r1
                    sty  zpWord1
                    ldy  cx16.r1+1
                    sty  zpWord1+1
                    ldy  zpy
                    lda  #0
                    sta  (zpWord1),y
                    cpy  #0
                    bne  _loop
                    rts
            _loop        dey
                    lda  (zpWord0),y
                    sta  (zpWord1),y
                    cpy  #0
                    bne  _loop
            +        rts
                .pend
                ;    src line: library:/prog8lib/string.p8:92

        slice    .proc
            ;    src line: library:/prog8lib/string.p8:98
                        ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                ; substr(source, target, start, length)
                sta  zpy
                lda  cx16.r0
                sta  zpWord0
                lda  cx16.r0+1
                sta  zpWord0+1
                lda  cx16.r1
                sta  zpWord1
                lda  cx16.r1+1
                sta  zpWord1+1

                ; adjust src location
                clc
                lda  zpWord0
                adc  zpy
                sta  zpWord0
                bcc  +
                inc  zpWord0+1
        +        lda  #0
                sta  (zpWord1),y
                beq  _startloop
        -        lda  (zpWord0),y
                sta  (zpWord1),y
        _startloop    dey
                cpy  #$ff
                bne  -
                rts
            .pend
            ;    src line: library:/prog8lib/string.p8:130

            find    .proc
                ;    src line: library:/prog8lib/string.p8:133
                            ; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
                            sta  zpy
                    lda  cx16.r0
                    ldy  cx16.r0+1
                    sta  zpWord0
                    sty  zpWord0+1
                    ldy  #0
            -        lda  (zpWord0),y
                    beq  _notfound
                    cmp  zpy
                    beq  _found
                    iny
                    bne  -
            _notfound    lda  #0
                            clc
                    rts
            _found        tya
                            sec
                            rts
                .pend
                

        copy    .proc
          
                sta  zpWord0
                sty  zpWord0+1
                lda  cx16.r0
                ldy  cx16.r0+1
                jmp  prog8_lib.strcpy
            .pend
            

        compare    .proc
             
                sta  zpWord1
                sty  zpWord1+1
                lda  cx16.r0
                ldy  cx16.r0+1
                jmp  prog8_lib.strcmp_mem
            .pend
    

                lower    .proc
                     
                            sta  zpWord0
                            sty  zpWord0+1
                            ldy  #0
                -           lda  (zpWord0),y
                            beq  _done
                            and  #$7f
                            cmp  #97
                            bcc  +
                            cmp  #123
                            bcs  +
                            and  #%11011111
                +           sta  (zpWord0),y
                            iny
                            bne  -
                _done       rts
                    .pend
                   

                upper    .proc
                 
                            sta  zpWord0
                            sty  zpWord0+1
                            ldy  #0
                -           lda  (zpWord0),y
                            beq  _done
                            cmp  #65
                            bcc  +
                            cmp  #91
                            bcs  +
                            ora  #%00100000
                +           sta  (zpWord0),y
                            iny
                            bne  -
                _done       rts
                    .pend
 

                pattern_match    .proc
                    ;    src line: library:/prog8lib/string.p8:248
                ; pattern matching of a string.
                ; Input:  cx16.r0:  A NUL-terminated, <255-length pattern
                ;              AY:  A NUL-terminated, <255-length string
                ;
                ; Output: A = 1 if the string matches the pattern, A = 0 if not.
                ;
                ; Notes:  Clobbers A, X, Y. Each * in the pattern uses 4 bytes of stack.
                ;
                ; see http://6502.org/source/strings/patmatch.htm

                str = zpWord0

                    stx  zpx
                    sta  str
                    sty  str+1
                    lda  cx16.r0
                    sta  modify_pattern1+1
                    sta  modify_pattern2+1
                    lda  cx16.r0+1
                    sta  modify_pattern1+2
                    sta  modify_pattern2+2
                    jsr  _match
                    lda  #0
                    adc  #0
                    ldx  zpx
                    rts


                _match
                    ldx #$00        ; x is an index in the pattern
                    ldy #$ff        ; y is an index in the string
                modify_pattern1
                next    lda $ffff,x   ; look at next pattern character    MODIFIED
                    cmp #'*'     ; is it a star?
                    beq star        ; yes, do the complicated stuff
                    iny             ; no, let's look at the string
                    cmp #'?'     ; is the pattern caracter a ques?
                    bne reg         ; no, it's a regular character
                    lda (str),y     ; yes, so it will match anything
                    beq fail        ;  except the end of string
                reg     cmp (str),y     ; are both characters the same?
                    bne fail        ; no, so no match
                    inx             ; yes, keep checking
                    cmp #0          ; are we at end of string?
                    bne next        ; not yet, loop
                found   rts             ; success, return with c=1

                star    inx             ; skip star in pattern
                modify_pattern2
                    cmp $ffff,x       ; string of stars equals one star    MODIFIED
                    beq star        ;  so skip them also
                stloop  txa             ; we first try to match with * = ""
                    pha             ;  and grow it by 1 character every
                    tya             ;  time we loop
                    pha             ; save x and y on stack
                    jsr next        ; recursive call
                    pla             ; restore x and y
                    tay
                    pla
                    tax
                    bcs found       ; we found a match, return with c=1
                    iny             ; no match yet, try to grow * string
                    lda (str),y     ; are we at the end of string?
                    bne stloop      ; not yet, add a character
                fail    clc             ; yes, no match found, return with c=0
                    rts
                    .pend
    
    
    
            .pend

; ****************** 
; #LIBRARY : 'math' 
; ******************* 

math    .proc
    ;    src line: library:/prog8lib/math.p8:3

; non-zeropage variables

; subroutines in this block
    ;    src line: library:/prog8lib/math.p8:4
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;    http://6502org.wikidot.com/software-math
;    http://codebase64.org/doku.php?id=base:6502_6510_maths
;


math_store_reg    .byte  0        ; temporary storage


multiply_bytes    .proc
    ; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
        sta  zpy         ; num1
        sty  zpx        ; num2
        lda  #0
        beq  _enterloop
_doAdd        clc
        adc  zpy
_loop        asl  zpy
_enterloop    lsr  zpx
        bcs  _doAdd
        bne  _loop
        rts
        .pend


multiply_bytes_into_word    .proc
    ; -- multiply 2 bytes A and Y, result as word in A/Y (unsigned)
        sta  zpy
        sty  zpx
        stx  math_store_reg
        lda  #0
        ldx  #8
        lsr  zpy
-        bcc  +
        clc
        adc  zpx
+        ror  a
        ror  zpy
        dex
        bne  -
        tay
        lda  zpy
        ldx  math_store_reg
        rts
        .pend


multiply_words    .proc
    ; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
    ;      input: A/Y = first 16-bit number, zpWord0 in ZP = second 16-bit number
    ;      output: multiply_words.result  4-bytes/32-bits product, LSB order (low-to-high)
    ;      clobbers: A

        sta  zpWord1
        sty  zpWord1+1
        stx  zpx

mult16        lda  #0
        sta  result+2    ; clear upper bits of product
        sta  result+3
        ldx  #16            ; for all 16 bits...
-         lsr  zpWord0+1    ; divide multiplier by 2
        ror  zpWord0
        bcc  +
        lda  result+2    ; get upper half of product and add multiplicand
        clc
        adc  zpWord1
        sta  result+2
        lda  result+3
        adc  zpWord1+1
+         ror  a                ; rotate partial product
        sta  result+3
        ror  result+2
        ror  result+1
        ror  result
        dex
        bne  -
        ldx  zpx
        rts

result        .byte  0,0,0,0
        .pend


divmod_b_asm    .proc
    ; signed byte division: make everything positive and fix sign afterwards
        sta  zpy
        tya
        eor  zpy
        php            ; save sign
        lda  zpy
        bpl  +
        eor  #$ff
        sec
        adc  #0            ; make it positive
+        pha
        tya
        bpl  +
        eor  #$ff
        sec
        adc  #0            ; make it positive
        tay
+        pla
        jsr  divmod_ub_asm
        sta  _remainder
        plp
        bpl  +
        tya
        eor  #$ff
        sec
        adc  #0            ; negate result
        tay
+        rts
_remainder    .byte  0
        .pend


divmod_ub_asm    .proc
    ; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
    ;    division by zero will result in quotient = 255 and remainder = original number
        sty  zpx
        sta  zpy
        stx  math_store_reg

        lda  #0
        ldx  #8
        asl  zpy
-        rol  a
        cmp  zpx
        bcc  +
        sbc  zpx
+        rol  zpy
        dex
        bne  -
        ldy  zpy
        ldx  math_store_reg
        rts
        .pend

divmod_w_asm    .proc
    ; signed word division: make everything positive and fix sign afterwards
        sta  zpWord1
        sty  zpWord1+1
        lda  zpWord0+1
        eor  zpWord1+1
        php            ; save sign
        lda  zpWord0+1
        bpl  +
        lda  #0
        sec
        sbc  zpWord0
        sta  zpWord0
        lda  #0
        sbc  zpWord0+1
        sta  zpWord0+1
+        lda  zpWord1+1
        bpl  +
        lda  #0
        sec
        sbc  zpWord1
        sta  zpWord1
        lda  #0
        sbc  zpWord1+1
        sta  zpWord1+1
+        tay
        lda  zpWord1
        jsr  divmod_uw_asm
        plp            ; restore sign
        bpl  +
        sta  zpWord1
        sty  zpWord1+1
        lda  #0
        sec
        sbc  zpWord1
        pha
        lda  #0
        sbc  zpWord1+1
        tay
        pla
+        rts
        .pend

divmod_uw_asm    .proc
    ; -- divide two unsigned words (16 bit each) into 16 bit results
    ;    input:  zpWord0 in ZP: 16 bit number, A/Y: 16 bit divisor
    ;    output: zpWord1 in ZP: 16 bit remainder, A/Y: 16 bit division result
    ;    division by zero will result in quotient = 65535 and remainder = divident


dividend = zpWord0
remainder = zpWord1
result = dividend ;save memory by reusing divident to store the result

        sta  _divisor
        sty  _divisor+1
        stx  zpx
        lda  #0                ;preset remainder to 0
        sta  remainder
        sta  remainder+1
        ldx  #16            ;repeat for each bit: ...

-        asl  dividend        ;dividend lb & hb*2, msb -> Carry
        rol  dividend+1
        rol  remainder        ;remainder lb & hb * 2 + msb from carry
        rol  remainder+1
        lda  remainder
        sec
        sbc  _divisor        ;substract divisor to see if it fits in
        tay                   ;lb result -> Y, for we may need it later
        lda  remainder+1
        sbc  _divisor+1
        bcc  +            ;if carry=0 then divisor didn't fit in yet

        sta  remainder+1    ;else save substraction result as new remainder,
        sty  remainder
        inc  result        ;and INCrement result cause divisor fit in 1 times

+        dex
        bne  -

        lda  result
        ldy  result+1
        ldx  zpx
        rts
_divisor    .word 0
        .pend


randseed    .proc
    ; -- reset the random seeds for the byte and word random generators
    ;    arguments: uword seed in A/Y   clobbers A
    ;    (default starting values are:  A=$2c Y=$9e)
        sta  randword._seed
        sty  randword._seed+1
        clc
        adc  #14
        sta  randbyte._seed
        rts
        .pend


randbyte        .proc
    ; -- 8 bit pseudo random number generator into A (by just reusing randword)
        jmp  randword
        .pend

randword    .proc
    ; -- 16 bit pseudo random number generator into AY

        ; rand64k       ;Factors of 65535: 3 5 17 257
        lda sr1+1
        asl a
        asl a
        eor sr1+1
        asl a
        eor sr1+1
        asl a
        asl a
        eor sr1+1
        asl a
        rol sr1         ;shift this left, "random" bit comes from low
        rol sr1+1
        ; rand32k       ;Factors of 32767: 7 31 151 are independent and can be combined
        lda sr2+1
        asl a
        eor sr2+1
        asl a
        asl a
        ror sr2         ;shift this right, random bit comes from high - nicer when eor with sr1
        rol sr2+1
        lda sr1+1         ;can be left out
        eor sr2+1         ;if you dont use
        tay               ;y as suggested
        lda sr1           ;mix up lowbytes of SR1
        eor sr2           ;and SR2 to combine both
        rts

sr1         .word $a55a
sr2         .word $7653

        .pend


; ----------- optimized multiplications (stack) : ---------
stack_mul_byte_3    .proc
        ; X + X*2
        lda  stack.lo+1,x
        asl  a
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_3    .proc
        ; W*2 + W
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend


stack_mul_byte_5    .proc
        ; X*4 + X
        lda  stack.lo+1,x
        asl  a
        asl  a
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_5    .proc
        ; W*4 + W
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend


stack_mul_byte_6    .proc
        ; (X*2 + X)*2
        lda  stack.lo+1,x
        asl  a
                clc
        adc  stack.lo+1,x
        asl  a
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_6    .proc
        ; (W*2 + W)*2
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        asl  stack.lo+1,x
                rol  a
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_7    .proc
        ; X*8 - X
        lda  stack.lo+1,x
        asl  a
        asl  a
        asl  a
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_7    .proc
        ; W*8 - W
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        sbc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_9    .proc
        ; X*8 + X
        lda  stack.lo+1,x
        asl  a
        asl  a
        asl  a
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_9    .proc
        ; W*8 + W
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_10    .proc
        ; (X*4 + X)*2
        lda  stack.lo+1,x
        asl  a
        asl  a
        clc
        adc  stack.lo+1,x
        asl  a
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_10    .proc
        ; (W*4 + W)*2
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        asl  stack.lo+1,x
                rol  a
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_11    .proc
        ; (X*2 + X)*4 - X
        lda  stack.lo+1,x
        asl  a
        clc
        adc  stack.lo+1,x
        asl  a
        asl  a
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

; mul_word_11 is skipped (too much code)

stack_mul_byte_12    .proc
        ; (X*2 + X)*4
        lda  stack.lo+1,x
        asl  a
        clc
        adc  stack.lo+1,x
        asl  a
        asl  a
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_12    .proc
        ; (W*2 + W)*4
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        asl  stack.lo+1,x
                rol  a
        asl  stack.lo+1,x
                rol  a
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_13    .proc
        ; (X*2 + X)*4 + X
        lda  stack.lo+1,x
        asl  a
                clc
        adc  stack.lo+1,x
        asl  a
        asl  a
                clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

; mul_word_13 is skipped (too much code)

stack_mul_byte_14    .proc
        ; (X*8 - X)*2
        lda  stack.lo+1,x
        asl  a
        asl  a
        asl  a
                sec
        sbc  stack.lo+1,x
                asl  a
        sta  stack.lo+1,x
        rts
        .pend

; mul_word_14 is skipped (too much code)

stack_mul_byte_15    .proc
        ; X*16 - X
        lda  stack.lo+1,x
        asl  a
        asl  a
        asl  a
        asl  a
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_15    .proc
        ; W*16 - W
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        sbc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_20    .proc
        ; (X*4 + X)*4
        lda  stack.lo+1,x
        asl  a
        asl  a
        clc
        adc  stack.lo+1,x
        asl  a
        asl  a
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_20    .proc
        ; (W*4 + W)*4
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        asl  stack.lo+1,x
                rol  a
        asl  stack.lo+1,x
                rol  a
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_25    .proc
        ; (X*2 + X)*8 + X
        lda  stack.lo+1,x
        asl  a
        clc
        adc  stack.lo+1,x
        asl  a
        asl  a
        asl  a
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_25    .proc
        ; W = (W*2 + W) *8 + W
        lda  stack.hi+1,x
        sta  zpWord0+1
        lda  stack.lo+1,x
        asl  a
        rol  zpWord0+1
        clc
        adc  stack.lo+1,x
        sta  zpWord0
        lda  zpWord0+1
        adc  stack.hi+1,x
        sta  zpWord0+1
        lda  zpWord0
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpWord0+1
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_40    .proc
        lda  stack.lo+1,x
        and  #7
        tay
        lda  mul_byte_40._forties,y
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_40    .proc
        ; (W*4 + W)*8
        lda  stack.hi+1,x
        sta  zpx
        lda  stack.lo+1,x
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        clc
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  zpx
        adc  stack.hi+1,x
        asl  stack.lo+1,x
                rol  a
        asl  stack.lo+1,x
                rol  a
        asl  stack.lo+1,x
                rol  a
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_byte_50    .proc
        lda  stack.lo+1,x
        and  #7
        tay
        lda  mul_byte_50._fifties, y
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_50    .proc
        ; W = W * 25 * 2
        jsr  stack_mul_word_25
        asl  stack.lo+1,x
        rol  stack.hi+1,x
        rts
        .pend

stack_mul_byte_80    .proc
        lda  stack.lo+1,x
        and  #3
        tay
        lda  mul_byte_80._eighties, y
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_80    .proc
        ; W = W * 40 * 2
        jsr  stack_mul_word_40
        asl  stack.lo+1,x
        rol  stack.hi+1,x
        rts
        .pend

stack_mul_byte_100    .proc
        lda  stack.lo+1,x
        and  #3
        tay
        lda  mul_byte_100._hundreds, y
        sta  stack.lo+1,x
        rts
        .pend

stack_mul_word_100    .proc
        ; W = W * 25 * 4
        jsr  stack_mul_word_25
        asl  stack.lo+1,x
        rol  stack.hi+1,x
        asl  stack.lo+1,x
        rol  stack.hi+1,x
        rts
        .pend

stack_mul_word_320    .proc
        ; stackW = stackLo * 256 + stackLo * 64     (stackHi doesn't matter)
        ldy  stack.lo+1,x
        lda  #0
        sta  stack.hi+1,x
        tya
        asl  a
        rol  stack.hi+1,x
        asl  a
        rol  stack.hi+1,x
        asl  a
        rol  stack.hi+1,x
        asl  a
        rol  stack.hi+1,x
        asl  a
        rol  stack.hi+1,x
        asl  a
        rol  stack.hi+1,x
        sta  stack.lo+1,x
        tya
        clc
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

stack_mul_word_640    .proc
        ; stackW = (stackLo * 2 * 320)    (stackHi doesn't matter)
        asl  stack.lo+1,x
        jmp  stack_mul_word_320
        .pend


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3    .proc
        ; A = A + A*2
        sta  zpx
        asl  a
        clc
        adc  zpx
        rts
        .pend

mul_word_3    .proc
        ; AY = AY*2 + AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        tay
        lda  zpWord0
        rts
        .pend


mul_byte_5    .proc
        ; A = A*4 + A
        sta  zpx
        asl  a
        asl  a
        clc
        adc  zpx
        rts
        .pend

mul_word_5    .proc
        ; AY = AY*4 + AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        tay
        lda  zpWord0
        rts
        .pend


mul_byte_6    .proc
        ; A = (A*2 + A)*2
        sta  zpx
        asl  a
                clc
                adc  zpx
        asl  a
        rts
        .pend

mul_word_6    .proc
        ; AY = (AY*2 + AY)*2
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        tay
        lda  zpWord0+1
        adc  zpWord1+1
        sta  zpWord0+1
        tya
        asl  a
        rol  zpWord0+1
        ldy  zpWord0+1
        rts
        .pend

mul_byte_7    .proc
        ; A = A*8 - A
        sta  zpx
        asl  a
        asl  a
        asl  a
        sec
        sbc  zpx
        rts
        .pend

mul_word_7    .proc
        ; AY = AY*8 - AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        sec
        sbc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        sbc  zpWord1+1
        tay
        lda  zpWord0
        rts
        .pend

mul_byte_9    .proc
        ; A = A*8 + A
        sta  zpx
        asl  a
        asl  a
        asl  a
        clc
        adc  zpx
        rts
        .pend

mul_word_9    .proc
        ; AY = AY*8 + AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        tay
        lda  zpWord0
        rts
        rts
        .pend

mul_byte_10    .proc
        ; A=(A*4 + A)*2
        sta  zpx
        asl  a
        asl  a
        clc
        adc  zpx
        asl  a
        rts
        .pend

mul_word_10    .proc
        ; AY=(AY*4 + AY)*2
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        sta  zpWord0+1
        lda  zpWord0
        asl  a
        rol  zpWord0+1
        ldy  zpWord0+1
        rts
        .pend

mul_byte_11    .proc
        ; A=(A*2 + A)*4 - A
        sta  zpx
        asl  a
        clc
        adc  zpx
        asl  a
        asl  a
        sec
        sbc  zpx
        rts
        .pend

; mul_word_11 is skipped (too much code)

mul_byte_12    .proc
        ; A=(A*2 + A)*4
        sta  zpx
        asl  a
        clc
        adc  zpx
        asl  a
        asl  a
        rts
        .pend

mul_word_12    .proc
        ; AY=(AY*2 + AY)*4
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        sta  zpWord0+1
        lda  zpWord0
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        ldy  zpWord0+1
        rts
        .pend

mul_byte_13    .proc
        ; A=(A*2 + A)*4 + A
        sta  zpx
        asl  a
                clc
        adc  zpx
        asl  a
        asl  a
                clc
        adc  zpx
        rts
        .pend

; mul_word_13 is skipped (too much code)

mul_byte_14    .proc
        ; A=(A*8 - A)*2
        sta  zpx
        asl  a
        asl  a
        asl  a
                sec
        sbc  zpx
                asl  a
        rts
        .pend

; mul_word_14 is skipped (too much code)

mul_byte_15    .proc
        ; A=A*16 - A
        sta  zpx
        asl  a
        asl  a
        asl  a
        asl  a
        sec
        sbc  zpx
        rts
        .pend

mul_word_15    .proc
        ; AY = AY * 16 - AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        sec
        sbc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        sbc  zpWord1+1
        tay
        lda  zpWord0
        rts
        .pend

mul_byte_20    .proc
        ; A=(A*4 + A)*4
        sta  zpx
        asl  a
        asl  a
        clc
        adc  zpx
        asl  a
        asl  a
        rts
        .pend

mul_word_20    .proc
        ; AY = AY * 10 * 2
        jsr  mul_word_10
        sty  zpx
        asl  a
        rol  zpx
        ldy  zpx
        rts
        .pend

mul_byte_25    .proc
        ; A=(A*2 + A)*8 + A
        sta  zpx
        asl  a
        clc
        adc  zpx
        asl  a
        asl  a
        asl  a
        clc
        adc  zpx
        rts
        .pend

mul_word_25    .proc
        ; AY = (AY*2 + AY) *8 + AY
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        sta  zpWord0+1
        lda  zpWord0
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        tay
        lda  zpWord0
        rts
        .pend

mul_byte_40    .proc
        and  #7
        tay
        lda  _forties,y
        rts
_forties    .byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
        .pend

mul_word_40    .proc
        ; AY = (AY*4 + AY)*8
        sta  zpWord0
        sty  zpWord0+1
        sta  zpWord1
        sty  zpWord1+1
        asl  a
        rol  zpWord0+1
        asl  a
        rol  zpWord0+1
        clc
        adc  zpWord1
        sta  zpWord0
        lda  zpWord0+1
        adc  zpWord1+1
        asl  zpWord0
        rol  a
        asl  zpWord0
        rol  a
        asl  zpWord0
        rol  a
        tay
        lda  zpWord0
        rts
        .pend

mul_byte_50    .proc
        and  #7
        tay
        lda  _fifties, y
        rts
_fifties    .byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
        .pend

mul_word_50    .proc
        ; AY = AY * 25 * 2
        jsr  mul_word_25
        sty  zpx
        asl  a
        rol  zpx
        ldy  zpx
        rts
        .pend

mul_byte_80    .proc
        and  #3
        tay
        lda  _eighties, y
        rts
_eighties    .byte  0*80, 1*80, 2*80, 3*80
        .pend

mul_word_80    .proc
        ; AY = AY * 40 * 2
        jsr  mul_word_40
        sty  zpx
        asl  a
        rol  zpx
        ldy  zpx
        rts
        .pend

mul_byte_100    .proc
        and  #3
        tay
        lda  _hundreds, y
        rts
_hundreds    .byte  0*100, 1*100, 2*100, 3*100 & 255
        .pend

mul_word_100    .proc
        ; AY = AY * 25 * 4
        jsr  mul_word_25
        sty  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        ldy  zpx
        rts
        .pend

mul_word_320    .proc
        ; AY = A * 256 + A * 64     (msb in Y doesn't matter)
        sta  zpy
        ldy  #0
        sty  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        asl  a
        rol  zpx
        pha
        clc
        lda  zpy
        adc  zpx
        tay
        pla
        rts
        .pend

mul_word_640    .proc
        ; AY = (A * 2 * 320) (msb in Y doesn't matter)
        asl  a
        jmp  mul_word_320
        .pend


; ----------- end optimized multiplications -----------


; bit shifts.
; anything below 3 is done inline. anything above 7 is done via other optimizations.

shift_left_w_7    .proc
        lda  stack.hi+1,x
        sta  zpy
        lda  stack.lo+1,x

        asl  a
        rol  zpy
_shift6        asl  a
        rol  zpy
_shift5        asl  a
        rol  zpy
_shift4        asl  a
        rol  zpy
_shift3        asl  a
        rol  zpy
        asl  a
        rol  zpy
        asl  a
        rol  zpy

        sta  stack.lo+1,x
        lda  zpy
        sta  stack.hi+1,x
        rts
        .pend

shift_left_w_6    .proc
        lda  stack.hi+1,x
        sta  zpy
        lda  stack.lo+1,x
        jmp  shift_left_w_7._shift6
        .pend

shift_left_w_5    .proc
        lda  stack.hi+1,x
        sta  zpy
        lda  stack.lo+1,x
        jmp  shift_left_w_7._shift5
        .pend

shift_left_w_4    .proc
        lda  stack.hi+1,x
        sta  zpy
        lda  stack.lo+1,x
        jmp  shift_left_w_7._shift4
        .pend

shift_left_w_3    .proc
        lda  stack.hi+1,x
        sta  zpy
        lda  stack.lo+1,x
        jmp  shift_left_w_7._shift3
        .pend


shift_left_w    .proc
        ; -- variable number of shifts left
        inx
        ldy  stack.lo,x
        bne  _shift
        rts
_shift        asl  stack.lo+1,x
        rol  stack.hi+1,x
        dey
        bne  _shift
        rts
        .pend

shift_right_uw    .proc
        ; -- uword variable number of shifts right
        inx
        ldy  stack.lo,x
        bne  _shift
        rts
_shift        lsr  stack.hi+1,x
        ror  stack.lo+1,x
        dey
        bne  _shift
        rts
        .pend

shift_right_uw_7    .proc
        lda  stack.lo+1,x
        sta  zpy
        lda  stack.hi+1,x

        lsr  a
        ror  zpy
_shift6        lsr  a
        ror  zpy
_shift5        lsr  a
        ror  zpy
_shift4        lsr  a
        ror  zpy
_shift3        lsr  a
        ror  zpy
        lsr  a
        ror  zpy
        lsr  a
        ror  zpy

        sta  stack.hi+1,x
        lda  zpy
        sta  stack.lo+1,x
        rts
        .pend

shift_right_uw_6    .proc
        lda  stack.lo+1,x
        sta  zpy
        lda  stack.hi+1,x
        jmp  shift_right_uw_7._shift6
        .pend

shift_right_uw_5    .proc
        lda  stack.lo+1,x
        sta  zpy
        lda  stack.hi+1,x
        jmp  shift_right_uw_7._shift5
        .pend

shift_right_uw_4    .proc
        lda  stack.lo+1,x
        sta  zpy
        lda  stack.hi+1,x
        jmp  shift_right_uw_7._shift4
        .pend

shift_right_uw_3    .proc
        lda  stack.lo+1,x
        sta  zpy
        lda  stack.hi+1,x
        jmp  shift_right_uw_7._shift3
        .pend


shift_right_w_7        .proc
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1

        asl  a
        ror  zpWord0+1
        ror  zpWord0

        lda  zpWord0+1
_shift6        asl  a
        ror  zpWord0+1
        ror  zpWord0
        lda  zpWord0+1
_shift5        asl  a
        ror  zpWord0+1
        ror  zpWord0
        lda  zpWord0+1
_shift4        asl  a
        ror  zpWord0+1
        ror  zpWord0
        lda  zpWord0+1
_shift3        asl  a
        ror  zpWord0+1
        ror  zpWord0
        lda  zpWord0+1
        asl  a
        ror  zpWord0+1
        ror  zpWord0
        lda  zpWord0+1
        asl  a
        ror  zpWord0+1
        ror  zpWord0

        lda  zpWord0
        sta  stack.lo+1,x
        lda  zpWord0+1
        sta  stack.hi+1,x
        rts
        .pend

shift_right_w_6    .proc
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        jmp  shift_right_w_7._shift6
        .pend

shift_right_w_5    .proc
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        jmp  shift_right_w_7._shift5
        .pend

shift_right_w_4    .proc
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        jmp  shift_right_w_7._shift4
        .pend

shift_right_w_3    .proc
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        jmp  shift_right_w_7._shift3
        .pend


shift_right_w    .proc
        ; -- signed word variable number of shifts right
        inx
        ldy  stack.lo,x
        bne  _shift
        rts
_shift        lda  stack.hi+1,x
        asl  a
        ror  stack.hi+1,x
        ror  stack.lo+1,x
        dey
        bne  _shift
        rts
        .pend


; support for bit shifting that is too large to be unrolled:

lsr_byte_A    .proc
        ; -- lsr signed byte in A times the value in Y (assume >0)
        cmp  #0
        bmi  _negative
-        lsr  a
        dey
        bne  -
        rts
_negative    lsr  a
        ora  #$80
        dey
        bne  _negative
        rts
        .pend


square          .proc
; -- calculate square root of signed word in AY, result in AY
; routine by Lee Davsion, source: http://6502.org/source/integers/square.htm
; using this routine is about twice as fast as doing a regular multiplication.
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = zpWord0       ; number to square low byte
numberh = zpWord0+1     ; number to square high byte
squarel = zpWord1       ; square low byte
squareh = zpWord1+1     ; square high byte
tempsq = zpy        ; temp byte for intermediate result

    sta  numberl
    sty  numberh
    stx  zpx

    lda     #$00        ; clear a
    sta     squarel     ; clear square low byte
                    ; (no need to clear the high byte, it gets shifted out)
    lda    numberl     ; get number low byte
    ldx    numberh     ; get number high  byte
    bpl    _nonneg      ; if +ve don't negate it
                    ; else do a two's complement
    eor    #$ff        ; invert
    sec                ; +1
    adc    #$00        ; and add it

_nonneg:
    sta    tempsq      ; save abs(number)
    ldx    #$08        ; set bit count

_nextr2bit:
    asl    squarel     ; low byte *2
    rol    squareh     ; high byte *2+carry from low
    asl    a           ; shift number byte
    bcc    _nosqadd     ; don't do add if c = 0
    tay                 ; save a
    clc                 ; clear carry for add
    lda    tempsq      ; get number
    adc    squarel     ; add number^2 low byte
    sta    squarel     ; save number^2 low byte
    lda    #$00        ; clear a
    adc    squareh     ; add number^2 high byte
    sta    squareh     ; save number^2 high byte
    tya                 ; get a back

_nosqadd:
    dex                 ; decrement bit count
    bne    _nextr2bit   ; go do next bit

    lda  squarel
    ldy  squareh
    ldx  zpx
    rts

        .pend
    ;    src line: library:/prog8lib/math.p8:6

sin8u    .proc
    ;    src line: library:/prog8lib/math.p8:7
    tay
    lda  _sinecos8u,y
    rts
_sinecos8u    .byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
    .pend
    ;    src line: library:/prog8lib/math.p8:15

cos8u    .proc
    ;    src line: library:/prog8lib/math.p8:16
        tay
        lda  sin8u._sinecos8u+64,y
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:23

sin8    .proc
    ;    src line: library:/prog8lib/math.p8:24
        tay
        lda  _sinecos8,y
        rts
_sinecos8    .char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
    .pend
    ;    src line: library:/prog8lib/math.p8:32

cos8    .proc
    ;    src line: library:/prog8lib/math.p8:33
        tay
        lda  sin8._sinecos8+64,y
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:40

sin16    .proc
    ;    src line: library:/prog8lib/math.p8:41
        tay
        lda  _sinecos8lo,y
        pha
        lda  _sinecos8hi,y
        tay
        pla
        rts
_  :=  trunc(32767.0 * sin(range(256+64) * rad(360.0/256.0)))
_sinecos8lo     .byte  <_
_sinecos8hi     .byte  >_
    .pend
    ;    src line: library:/prog8lib/math.p8:55

cos16    .proc
    ;    src line: library:/prog8lib/math.p8:56
        tay
        lda  sin16._sinecos8lo+64,y
        pha
        lda  sin16._sinecos8hi+64,y
        tay
        pla
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:67

sin16u    .proc
    ;    src line: library:/prog8lib/math.p8:68
        tay
        lda  _sinecos8ulo,y
        pha
        lda  _sinecos8uhi,y
        tay
        pla
        rts
_  :=  trunc(32768.0 + 32767.5 * sin(range(256+64) * rad(360.0/256.0)))
_sinecos8ulo     .byte  <_
_sinecos8uhi     .byte  >_
    .pend
    ;    src line: library:/prog8lib/math.p8:82

cos16u    .proc
    ;    src line: library:/prog8lib/math.p8:83
        tay
        lda  sin16u._sinecos8ulo+64,y
        pha
        lda  sin16u._sinecos8uhi+64,y
        tay
        pla
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:94

sinr8u    .proc
    ;    src line: library:/prog8lib/math.p8:95
        tay
        lda  _sinecosR8u,y
        rts
_sinecosR8u    .byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
    .pend
    ;    src line: library:/prog8lib/math.p8:103

cosr8u    .proc
    ;    src line: library:/prog8lib/math.p8:104
        tay
        lda  sinr8u._sinecosR8u+45,y
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:111

sinr8    .proc
    ;    src line: library:/prog8lib/math.p8:112
        tay
        lda  _sinecosR8,y
        rts
_sinecosR8    .char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
    .pend
    ;    src line: library:/prog8lib/math.p8:120

cosr8    .proc
    ;    src line: library:/prog8lib/math.p8:121
        tay
        lda  sinr8._sinecosR8+45,y
        rts
    .pend
 

sinr16    .proc
 
        tay
        lda  _sinecosR8lo,y
        pha
        lda  _sinecosR8hi,y
        tay
        pla
        rts
_  :=  trunc(32767.0 * sin(range(180+45) * rad(360.0/180.0)))
_sinecosR8lo     .byte  <_
_sinecosR8hi     .byte  >_
    .pend
 

cosr16    .proc
 
        tay
        lda  sinr16._sinecosR8lo+45,y
        pha
        lda  sinr16._sinecosR8hi+45,y
        tay
        pla
        rts
    .pend
    ;    src line: library:/prog8lib/math.p8:155

sinr16u    .proc
    ;    src line: library:/prog8lib/math.p8:156
        tay
        lda  _sinecosR8ulo,y
        pha
        lda  _sinecosR8uhi,y
        tay
        pla
        rts
_  :=  trunc(32768.0 + 32767.5 * sin(range(180+45) * rad(360.0/180.0)))
_sinecosR8ulo     .byte  <_
_sinecosR8uhi     .byte  >_
    .pend
    ;    src line: library:/prog8lib/math.p8:170

cosr16u    .proc
    ;    src line: library:/prog8lib/math.p8:171
        tay
        lda  sinr16u._sinecosR8ulo+45,y
        pha
        lda  sinr16u._sinecosR8uhi+45,y
        tay
        pla
        rts
    .pend
    .pend

;***********************
; #LIBRARY : 'prog8_lib' 
;***********************

prog8_lib    .proc
 

                ; non-zeropage variables

                ; subroutines in this block
                 
                ; Internal library routines - always included by the compiler
                ; Generic machine independent 6502 code.


                orig_stackpointer    .byte  0    ; stores the Stack pointer register at program start

                read_byte_from_address_on_stack    .proc
                    ; -- read the byte from the memory address on the top of the stack, return in A (stack remains unchanged)
                        lda  stack.lo+1,x
                        ldy  stack.hi+1,x
                        sta  zpWord1
                        sty  zpWord1+1
                        ldy  #0
                        lda  (zpWord1),y
                        rts
                        .pend


                write_byte_to_address_on_stack    .proc
                    ; -- write the byte in A to the memory address on the top of the stack (stack remains unchanged)
                        ldy  stack.lo+1,x
                        sty  zpWord1
                        ldy  stack.hi+1,x
                        sty  zpWord1+1
                        ldy  #0
                        sta  (zpWord1),y
                        rts
                        .pend



neg_b        .proc
        lda  #0
        sec
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        rts
        .pend

neg_w        .proc
        sec
        lda  #0
        sbc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  #0
        sbc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

inv_word    .proc
        lda  stack.lo+1,x
        eor  #255
        sta  stack.lo+1,x
        lda  stack.hi+1,x
        eor  #255
        sta  stack.hi+1,x
        rts
        .pend

bitand_b    .proc
        ; -- bitwise and (of 2 bytes)
        lda  stack.lo+2,x
        and  stack.lo+1,x
        inx
        sta  stack.lo+1,x
        rts
        .pend

bitor_b        .proc
        ; -- bitwise or (of 2 bytes)
        lda  stack.lo+2,x
        ora  stack.lo+1,x
        inx
        sta  stack.lo+1,x
        rts
        .pend

bitxor_b    .proc
        ; -- bitwise xor (of 2 bytes)
        lda  stack.lo+2,x
        eor  stack.lo+1,x
        inx
        sta  stack.lo+1,x
        rts
        .pend

bitand_w    .proc
        ; -- bitwise and (of 2 words)
        lda  stack.lo+2,x
        and  stack.lo+1,x
        sta  stack.lo+2,x
        lda  stack.hi+2,x
        and  stack.hi+1,x
        sta  stack.hi+2,x
        inx
        rts
        .pend

bitor_w        .proc
        ; -- bitwise or (of 2 words)
        lda  stack.lo+2,x
        ora  stack.lo+1,x
        sta  stack.lo+2,x
        lda  stack.hi+2,x
        ora  stack.hi+1,x
        sta  stack.hi+2,x
        inx
        rts
        .pend

bitxor_w    .proc
        ; -- bitwise xor (of 2 bytes)
        lda  stack.lo+2,x
        eor  stack.lo+1,x
        sta  stack.lo+2,x
        lda  stack.hi+2,x
        eor  stack.hi+1,x
        sta  stack.hi+2,x
        inx
        rts
        .pend


add_w        .proc
    ; -- push word+word / uword+uword
        inx
        clc
        lda  stack.lo,x
        adc  stack.lo+1,x
        sta  stack.lo+1,x
        lda  stack.hi,x
        adc  stack.hi+1,x
        sta  stack.hi+1,x
        rts
        .pend

sub_w        .proc
    ; -- push word-word
        inx
        sec
        lda  stack.lo+1,x
        sbc  stack.lo,x
        sta  stack.lo+1,x
        lda  stack.hi+1,x
        sbc  stack.hi,x
        sta  stack.hi+1,x
        rts
        .pend

mul_byte    .proc
    ; -- b*b->b (signed and unsigned)
        inx
        lda  stack.lo,x
        ldy  stack.lo+1,x
        jsr  math.multiply_bytes
        sta  stack.lo+1,x
        rts
        .pend

mul_word    .proc
        inx
        lda  stack.lo,x
        sta  zpWord0
        lda  stack.hi,x
        sta  zpWord0+1
        lda  stack.lo+1,x
        ldy  stack.hi+1,x
        jsr  math.multiply_words
        lda  math.multiply_words.result
        sta  stack.lo+1,x
        lda  math.multiply_words.result+1
        sta  stack.hi+1,x
        rts
        .pend

idiv_b        .proc
    ; signed division: use unsigned division and fix sign of result afterwards
        inx
        lda  stack.lo,x
        eor  stack.lo+1,x
        php            ; save sign of result
        lda  stack.lo,x
        bpl  +
        eor  #$ff
        sec
        adc  #0            ; make num1 positive
+        tay
        inx
        lda  stack.lo,x
        bpl  +
        eor  #$ff
        sec
        adc  #0            ; make num2 positive
+        jsr  math.divmod_ub_asm
        sta  _remainder
        tya
        plp            ; get sign of result
        bpl  +
        eor  #$ff
        sec
        adc  #0            ; negate result
+        sta  stack.lo,x
        dex
        rts
_remainder    .byte  0
        .pend

idiv_ub        .proc
        inx
        ldy  stack.lo,x
        lda  stack.lo+1,x
        jsr  math.divmod_ub_asm
        tya
        sta  stack.lo+1,x
        rts
        .pend

idiv_w        .proc
    ; signed division: use unsigned division and fix sign of result afterwards
        lda  stack.hi+2,x
        eor  stack.hi+1,x
        php                ; save sign of result
        lda  stack.hi+1,x
        bpl  +
        jsr  neg_w            ; make value positive
+        inx
        lda  stack.hi+1,x
        bpl  +
        jsr  neg_w            ; make value positive
+        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        lda  stack.lo,x
        ldy  stack.hi,x
        jsr  math.divmod_uw_asm
        sta  stack.lo+1,x
        tya
        sta  stack.hi+1,x
        plp
        bpl  +
        jmp  neg_w        ; negate result
+        rts
        .pend

idiv_uw        .proc
        inx
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        lda  stack.lo,x
        ldy  stack.hi,x
        jsr  math.divmod_uw_asm
        sta  stack.lo+1,x
        tya
        sta  stack.hi+1,x
        rts
        .pend

remainder_ub    .proc
        inx
        ldy  stack.lo,x    ; right operand
        lda  stack.lo+1,x  ; left operand
        jsr  math.divmod_ub_asm
        sta  stack.lo+1,x
        rts
        .pend

remainder_uw    .proc
        inx
        lda  stack.lo+1,x
        sta  zpWord0
        lda  stack.hi+1,x
        sta  zpWord0+1
        lda  stack.lo,x
        ldy  stack.hi,x
        jsr  math.divmod_uw_asm
        lda  zpWord1
        sta  stack.lo+1,x
        lda  zpWord1+1
        sta  stack.hi+1,x
        rts
        .pend

equal_w        .proc
    ; -- are the two words on the stack identical?
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        bne  equal_b._equal_b_false
        lda  stack.hi+1,x
        cmp  stack.hi+2,x
        bne  equal_b._equal_b_false
        beq  equal_b._equal_b_true
        .pend

notequal_b    .proc
    ; -- are the two bytes on the stack different?
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        beq  equal_b._equal_b_false
        bne  equal_b._equal_b_true
        .pend

notequal_w    .proc
    ; -- are the two words on the stack different?
        lda  stack.hi+1,x
        cmp  stack.hi+2,x
        beq  notequal_b
        bne  equal_b._equal_b_true
        .pend

less_ub        .proc
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        bcc  equal_b._equal_b_true
        bcs  equal_b._equal_b_false
        .pend

less_b        .proc
    ; see http://www.6502.org/tutorials/compare_beyond.html
        lda  stack.lo+2,x
        sec
        sbc  stack.lo+1,x
        bvc  +
        eor  #$80
+        bmi  equal_b._equal_b_true
        bpl  equal_b._equal_b_false
        .pend

reg_less_uw    .proc
        ;  AY < zpWord1?
        cpy  zpWord1+1
        bcc  _true
        bne  _false
        cmp  zpWord1
        bcc  _true
_false        lda  #0
        rts
_true        lda  #1
        rts
        .pend

less_uw        .proc
        lda  stack.hi+2,x
        cmp  stack.hi+1,x
        bcc  equal_b._equal_b_true
        bne  equal_b._equal_b_false
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        bcc  equal_b._equal_b_true
        bcs  equal_b._equal_b_false
        .pend

reg_less_w    .proc
        ; -- AY < zpWord1?
        cmp  zpWord1
        tya
        sbc  zpWord1+1
        bvc  +
        eor  #$80
+        bmi  _true
        lda  #0
        rts
_true        lda  #1
        rts
        .pend

less_w        .proc
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        lda  stack.hi+2,x
        sbc  stack.hi+1,x
        bvc  +
        eor  #$80
+        bmi  equal_b._equal_b_true
        bpl  equal_b._equal_b_false
        .pend

equal_b        .proc
    ; -- are the two bytes on the stack identical?
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        bne  _equal_b_false
_equal_b_true    lda  #1
_equal_b_store    inx
        sta  stack.lo+1,x
        rts
_equal_b_false    lda  #0
        beq  _equal_b_store
        .pend

lesseq_ub    .proc
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        bcs  equal_b._equal_b_true
        bcc  equal_b._equal_b_false
        .pend

lesseq_b    .proc
    ; see http://www.6502.org/tutorials/compare_beyond.html
        lda  stack.lo+2,x
        clc
        sbc  stack.lo+1,x
        bvc  +
        eor  #$80
+        bmi  equal_b._equal_b_true
        bpl  equal_b._equal_b_false
        .pend

reg_lesseq_uw    .proc
        ; AY <= zpWord1?
        cpy  zpWord1+1
        beq  +
        bcc  _true
        lda  #0
        rts
+        cmp  zpWord1
        bcc  _true
        beq  _true
        lda  #0
        rts
_true        lda  #1
        rts
        .pend

lesseq_uw    .proc
        lda  stack.hi+1,x
        cmp  stack.hi+2,x
        bcc  equal_b._equal_b_false
        bne  equal_b._equal_b_true
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        bcs  equal_b._equal_b_true
        bcc  equal_b._equal_b_false
        .pend

reg_lesseq_w    .proc
        ; -- zpWord1 <= AY ?   (note: order different from other routines)
        cmp  zpWord1
        tya
        sbc  zpWord1+1
        bvc  +
        eor  #$80
+        bpl  +
        lda  #0
        rts
+        lda  #1
        rts
        .pend

lesseq_w    .proc
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        lda  stack.hi+1,x
        sbc  stack.hi+2,x
        bvc  +
        eor  #$80
+        bpl  equal_b._equal_b_true
        bmi  equal_b._equal_b_false
        .pend

greater_ub    .proc
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        beq  equal_b._equal_b_false
        bcs  equal_b._equal_b_true
        bcc  equal_b._equal_b_false
        .pend

greater_b    .proc
    ; see http://www.6502.org/tutorials/compare_beyond.html
        lda  stack.lo+2,x
        clc
        sbc  stack.lo+1,x
        bvc  +
        eor  #$80
+        bpl  equal_b._equal_b_true
        bmi  equal_b._equal_b_false
        .pend

greater_uw    .proc
        lda  stack.hi+1,x
        cmp  stack.hi+2,x
        bcc  equal_b._equal_b_true
        bne  equal_b._equal_b_false
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        bcc  equal_b._equal_b_true
        bcs  equal_b._equal_b_false
        .pend

greater_w    .proc
        lda  stack.lo+1,x
        cmp  stack.lo+2,x
        lda  stack.hi+1,x
        sbc  stack.hi+2,x
        bvc  +
        eor  #$80
+        bmi  equal_b._equal_b_true
        bpl  equal_b._equal_b_false
        .pend

greatereq_ub    .proc
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        bcs  equal_b._equal_b_true
        bcc  equal_b._equal_b_false
        .pend

greatereq_b    .proc
    ; see http://www.6502.org/tutorials/compare_beyond.html
        lda  stack.lo+2,x
        sec
        sbc  stack.lo+1,x
        bvc  +
        eor  #$80
+        bpl  equal_b._equal_b_true
        bmi  equal_b._equal_b_false
        .pend

greatereq_uw    .proc
        lda  stack.hi+2,x
        cmp  stack.hi+1,x
        bcc  equal_b._equal_b_false
        bne  equal_b._equal_b_true
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        bcs  equal_b._equal_b_true
        bcc  equal_b._equal_b_false
        .pend

greatereq_w    .proc
        lda  stack.lo+2,x
        cmp  stack.lo+1,x
        lda  stack.hi+2,x
        sbc  stack.hi+1,x
        bvc  +
        eor  #$80
+        bmi  equal_b._equal_b_false
        bpl  equal_b._equal_b_true
        .pend


shiftleft_b    .proc
        inx
        ldy  stack.lo,x
        bne  +
        rts
+        lda  stack.lo+1,x
-        asl  a
        dey
        bne  -
        sta  stack.lo+1,x
        rts
        .pend

shiftright_b    .proc
        inx
        ldy  stack.lo,x
        bne  +
        rts
+        lda  stack.lo+1,x
-        lsr  a
        dey
        bne  -
        sta  stack.lo+1,x
        rts
        .pend


equalzero_b    .proc
        lda  stack.lo+1,x
        beq  _true
        bne  _false
_true        lda  #1
        sta  stack.lo+1,x
        rts
_false        lda  #0
        sta  stack.lo+1,x
        rts
        .pend

equalzero_w    .proc
        lda  stack.lo+1,x
        ora  stack.hi+1,x
        beq  equalzero_b._true
        bne  equalzero_b._false
        .pend

notequalzero_b    .proc
        lda  stack.lo+1,x
        beq  equalzero_b._false
        bne  equalzero_b._true
        .pend

notequalzero_w    .proc
        lda  stack.lo+1,x
        ora  stack.hi+1,x
        beq  equalzero_b._false
        bne  equalzero_b._true
        .pend

lesszero_b    .proc
        lda  stack.lo+1,x
        bmi  equalzero_b._true
        jmp  equalzero_b._false
        .pend

lesszero_w    .proc
        lda  stack.hi+1,x
        bmi  equalzero_b._true
        jmp  equalzero_b._false
        .pend

greaterzero_ub    .proc
        lda  stack.lo+1,x
        bne  equalzero_b._true
        beq  equalzero_b._false
        .pend

greaterzero_sb    .proc
        lda  stack.lo+1,x
        beq  equalzero_b._false
        bpl  equalzero_b._true
        bmi  equalzero_b._false
        .pend

greaterzero_uw    .proc
        lda  stack.lo+1,x
        ora  stack.hi+1,x
        bne  equalzero_b._true
        beq  equalzero_b._false
        .pend

greaterzero_sw    .proc
        lda  stack.hi+1,x
        bmi  equalzero_b._false
        ora  stack.lo+1,x
        beq  equalzero_b._false
        bne  equalzero_b._true
        .pend

lessequalzero_sb    .proc
        lda  stack.lo+1,x
        bmi  equalzero_b._true
        beq  equalzero_b._true
        bne  equalzero_b._false
        .pend

lessequalzero_sw    .proc
        lda  stack.hi+1,x
        bmi  equalzero_b._true
        ora  stack.lo+1,x
        beq  equalzero_b._true
        bne  equalzero_b._false
        .pend

greaterequalzero_sb    .proc
        lda  stack.lo+1,x
            bpl  equalzero_b._true
            bmi  equalzero_b._false
        .pend

greaterequalzero_sw    .proc
        lda  stack.hi+1,x
            bpl  equalzero_b._true
            bmi  equalzero_b._false
        .pend

                                memcopy16_up    .proc
                                    ; -- copy memory UP from (zpWord0) to (zpWord1) of length X/Y (16-bit, X=lo, Y=hi)
                                    ;    clobbers register A,X,Y
                                        source = zpWord0
                                        dest = zpWord1
                                        length = zpy   ; (and SCRATCH_ZPREG)

                                        stx  length
                                        sty  length+1

                                        ldx  length             ; move low byte of length into X
                                        bne  +                  ; jump to start if X > 0
                                        dec  length             ; subtract 1 from length
                                +        ldy  #0                 ; set Y to 0
                                -        lda  (source),y         ; set A to whatever (source) points to offset by Y
                                        sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
                                        iny                     ; increment Y
                                        bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
                                        inc  source+1           ; increment hi byte of source
                                        inc  dest+1             ; increment hi byte of dest
                                +        dex                     ; decrement X (lo byte counter)
                                        bne  -                  ; if X<>0 then move another byte
                                        dec  length             ; we've moved 255 bytes, dec length
                                        bpl  -                  ; if length is still positive go back and move more
                                        rts                     ; done
                                        .pend


                            memset          .proc
                                ; -- fill memory from (zpWord0), length XY, with value in A.
                                ;    clobbers X, Y
                                    stx  zpy
                                    sty  _save_reg
                                    ldy  #0
                                    ldx  _save_reg
                                    beq  _lastpage
                            _fullpage    
                                    sta  (zpWord0),y
                                    iny
                                    bne  _fullpage
                                    inc  zpWord0+1          ; next page
                                    dex
                                    bne  _fullpage

                            _lastpage    
                                    ldy  zpy
                                    beq  +
                            -             
                                    dey
                                    sta  (zpWord0),y
                                    bne  -

                            +               
                                    rts
                            _save_reg    .byte  0

                            .pend


                            memsetw        .proc

                                ; -- fill memory from (zpWord0) number of words in zpWord1, with word value in AY.
                                ;    clobbers A, X, Y
                                    sta  _mod1+1                    ; self-modify
                                    sty  _mod1b+1                   ; self-modify
                                    sta  _mod2+1                    ; self-modify
                                    sty  _mod2b+1                   ; self-modify
                                    ldx  zpWord0
                                    stx  zpy
                                    ldx  zpWord0+1
                                    inx
                                    stx  zpx                ; second page

                                    ldy  #0
                                    ldx  zpWord1+1
                                    beq  _lastpage
                            _fullpage
                            _mod1           
                                    lda  #0                 ; self-modified
                                    sta  (zpWord0),y        ; first page
                                    sta  (zpy),y            ; second page
                                    iny
                            _mod1b        lda  #0                         ; self-modified
                                    sta  (zpWord0),y        ; first page
                                    sta  (zpy),y            ; second page
                                    iny
                                    bne  _fullpage
                                    inc  zpWord0+1          ; next page pair
                                    inc  zpWord0+1          ; next page pair
                                    inc  zpy+1              ; next page pair
                                    inc  zpy+1              ; next page pair
                                    dex
                                    bne  _fullpage
                            _lastpage    
                                    ldx  zpWord1
                                    beq  _done

                                    ldy  #0
                            -
                            _mod2           
                                    lda  #0                         ; self-modified
                                    sta  (zpWord0), y
                                    inc  zpWord0
                                    bne  _mod2b
                                    inc  zpWord0+1
                            _mod2b          
                                    lda  #0                         ; self-modified
                                    sta  (zpWord0), y
                                    inc  zpWord0
                                    bne  +
                                    inc  zpWord0+1
                            +               
                                    dex
                                    bne  -
                            _done        
                                    rts
                                    
                            .pend



ror2_mem_ub    .proc
        ; -- in-place 8-bit ror of byte at memory location in AY
        sta  zpWord0
        sty  zpWord0+1
        ldy  #0
        lda  (zpWord0),y
        lsr  a
        bcc  +
        ora  #$80
+        sta  (zpWord0),y
        rts
        .pend

rol2_mem_ub    .proc
        ; -- in-place 8-bit rol of byte at memory location in AY
        sta  zpWord0
        sty  zpWord0+1
        ldy  #0
        lda  (zpWord0),y
        cmp  #$80
        rol  a
        sta  (zpWord0),y
        rts
        .pend

rol_array_ub    .proc
        ; -- rol a ubyte in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        ldy  _arg_index
        lda  (zpWord0),y
        rol  a
        sta  (zpWord0),y
        rts
_arg_target    .word    0
_arg_index    .byte   0
        .pend


ror_array_ub    .proc
        ; -- ror a ubyte in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        ldy  _arg_index
        lda  (zpWord0),y
        ror  a
        sta  (zpWord0),y
        rts
_arg_target    .word    0
_arg_index    .byte   0
        .pend

ror2_array_ub    .proc
        ; -- ror2 (8-bit ror) a ubyte in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        ldy  _arg_index
        lda  (zpWord0),y
        lsr  a
        bcc  +
        ora  #$80
+        sta  (zpWord0),y
        rts
_arg_target    .word    0
_arg_index    .byte   0
        .pend

rol2_array_ub    .proc
        ; -- rol2 (8-bit rol) a ubyte in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        ldy  _arg_index
        lda  (zpWord0),y
        cmp  #$80
        rol  a
        sta  (zpWord0),y
        rts
_arg_target    .word    0
_arg_index    .byte   0
        .pend

ror_array_uw    .proc
        ; -- ror a uword in an array
        php
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        lda  _arg_index
        asl  a
        tay
        iny
        lda  (zpWord0),y
        plp
        ror  a
        sta  (zpWord0),y
        dey
        lda  (zpWord0),y
        ror  a
        sta  (zpWord0),y
        rts
_arg_target    .word  0
_arg_index    .byte  0
        .pend

rol_array_uw    .proc
        ; -- rol a uword in an array
        php
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        lda  _arg_index
        asl  a
        tay
        lda  (zpWord0),y
        plp
        rol  a
        sta  (zpWord0),y
        iny
        lda  (zpWord0),y
        rol  a
        sta  (zpWord0),y
        rts
_arg_target    .word  0
_arg_index    .byte  0
        .pend

rol2_array_uw    .proc
        ; -- rol2 (16-bit rol) a uword in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        lda  _arg_index
        asl  a
        tay
        lda  (zpWord0),y
        asl  a
        sta  (zpWord0),y
        iny
        lda  (zpWord0),y
        rol  a
        sta  (zpWord0),y
        bcc  +
        dey
        lda  (zpWord0),y
        adc  #0
        sta  (zpWord0),y
+        rts
_arg_target    .word  0
_arg_index    .byte  0
        .pend

ror2_array_uw    .proc
        ; -- ror2 (16-bit ror) a uword in an array
        lda  _arg_target
        ldy  _arg_target+1
        sta  zpWord0
        sty  zpWord0+1
        lda  _arg_index
        asl  a
        tay
        iny
        lda  (zpWord0),y
        lsr  a
        sta  (zpWord0),y
        dey
        lda  (zpWord0),y
        ror  a
        sta  (zpWord0),y
        bcc  +
        iny
        lda  (zpWord0),y
        ora  #$80
        sta  (zpWord0),y
+        rts
_arg_target    .word  0
_arg_index    .byte  0
        .pend


                strcpy        .proc
                        ; copy a string (must be 0-terminated) from A/Y to (zpWord0)
                        ; it is assumed the target string is large enough.
                        ; returns the length of the string that was copied in Y.
                        sta  zpWord1
                        sty  zpWord1+1
                        ldy  #$ff
                -        iny
                        lda  (zpWord1),y
                        sta  (zpWord0),y
                        bne  -
                        rts
                        .pend

strcmp_expression    .proc
        ; -- compare strings, result in A
        lda  _arg_s2
        ldy  _arg_s2+1
        sta  zpWord1
        sty  zpWord1+1
        lda  _arg_s1
        ldy  _arg_s1+1
        jmp  strcmp_mem
_arg_s1        .word  0
_arg_s2        .word  0
        .pend


            strcmp_mem    .proc
                    ; --   compares strings in s1 (AY) and s2 (zpWord1).
                    ;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
                    sta  zpWord0
                    sty  zpWord0+1
                    ldy  #0
            _loop        lda  (zpWord0),y
                    bne  +
                    lda  (zpWord1),y
                    bne  _return_minusone
                    beq  _return
            +        cmp  (zpWord1),y
                    bcc  _return_minusone
                    bne  _return_one
                    inc  zpWord0
                    bne  +
                    inc  zpWord0+1
            +        inc  zpWord1
                    bne  _loop
                    inc  zpWord1+1
                    bne  _loop
            _return_one
                    lda  #1
            _return        rts
            _return_minusone
                    lda  #-1
                    rts
                .pend


sign_extend_stack_byte    .proc
    ; -- sign extend the (signed) byte on the stack to full 16 bits
        lda  stack.lo+1,x
        ora  #$7f
        bmi  +
        lda  #0
+        sta  stack.hi+1,x
        rts
        .pend

                                    strlen          .proc
                                            ; -- returns the number of bytes in the string in AY, in Y.
                                            sta  zpWord0
                                            sty  zpWord0+1
                                            ldy  #0
                                    -        lda  (zpWord0),y
                                            beq  +
                                            iny
                                            bne  -
                                    +        rts
                                            .pend

containment_bytearray    .proc
    ; -- check if a value exists in a byte array.
    ;    parameters: zpWord0: address of the byte array, A = byte to check, Y = length of array (>=1).
    ;    returns boolean 0/1 in A.
        dey
-        cmp  (zpWord0),y
        beq  +
        dey
        cpy  #255
        bne  -
        lda  #0
        rts
+        lda  #1
        rts
        .pend

containment_wordarray    .proc
    ; -- check if a value exists in a word array.
    ;    parameters: zpWord0: value to check, zpWord1: address of the word array, Y = length of array (>=1).
    ;    returns boolean 0/1 in A.
        dey
        tya
        asl  a
        tay
-        lda  zpWord0
        cmp  (zpWord1),y
        bne  +
        lda  zpWord0+1
        iny
        cmp  (zpWord1),y
        beq  _found
+        dey
        dey
        cpy  #254
        bne  -
        lda  #0
        rts
_found        lda  #1
        rts
        .pend
    ;    src line: library:/prog8lib/prog8_lib.p8:5
; ---- builtin functions


func_any_b_stack    .proc
        jsr  func_any_b_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_all_b_stack    .proc
        jsr  func_all_b_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_any_b_into_A    .proc
        ; -- any(array),  array in zpWord0, num bytes in A
        sta  _cmp_mod+1        ; self-modifying code
        ldy  #0
-        lda  (zpWord0),y
        bne  _got_any
        iny
_cmp_mod    cpy  #255        ; modified
        bne  -
        lda  #0
        rts
_got_any    lda  #1
        rts
        .pend


func_all_b_into_A    .proc
        ; -- all(array),  array in zpWord0, num bytes in A
        sta  _cmp_mod+1        ; self-modifying code
        ldy  #0
-        lda  (zpWord0),y
        beq  _got_not_all
        iny
_cmp_mod    cpy  #255        ; modified
        bne  -
        lda  #1
_got_not_all    rts
        .pend

func_any_w_into_A    .proc
        asl  a
        jmp  func_any_b_into_A
        .pend

func_any_w_stack    .proc
        asl  a
        jsr  func_any_b_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_all_w_into_A    .proc
        ; -- all(warray),  array in zpWord0, num bytes in A
        asl  a            ; times 2 because of word
        sta  _cmp_mod+1        ; self-modifying code
        ldy  #0
-        lda  (zpWord0),y
        bne  +
        iny
        lda  (zpWord0),y
        bne  ++
        lda  #0
        rts
+        iny
+        iny
_cmp_mod    cpy  #255        ; modified
        bne  -
        lda  #1
        rts
        .pend

func_all_w_stack    .proc
        jsr  func_all_w_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

abs_b_stack    .proc
    ; -- push abs(A) on stack (as unsigned word)
        jsr  abs_b_into_AY
        sta  stack.lo,x
        stz  stack.hi,x
        dex
        rts
        .pend

abs_b_into_AY    .proc
    ; -- AY = abs(A)  (abs always returns unsigned word)
        ldy  #0
        cmp  #0
        bmi  +
        rts
+        eor  #$ff
        clc
        adc  #1
        rts
        .pend

abs_w_stack    .proc
    ; -- push abs(AY) on stack (as word)
        jsr  abs_w_into_AY
        sta  stack.lo,x
        tya
        sta  stack.hi,x
        dex
        rts
        .pend

abs_w_into_AY    .proc
    ; -- AY = abs(AY)
        cpy  #0
        bmi  +
        rts
+        eor  #$ff
        pha
        tya
        eor  #$ff
        tay
        pla
        clc
        adc  #1
        bcc  +
        iny
+        rts
        .pend

func_sign_b_into_A    .proc
        cmp  #0
        beq  _zero
        bmi  _neg
        lda  #1
_zero        rts
_neg        lda  #-1
        rts
        .pend

func_sign_b_stack    .proc
        jsr  func_sign_b_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sign_ub_into_A    .proc
        cmp  #0
        bne  _pos
        rts
_pos        lda  #1
        rts
        .pend

func_sign_ub_stack    .proc
        jsr  func_sign_ub_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sign_uw_into_A    .proc
        cpy  #0
        beq  _possibly_zero
_pos        lda  #1
        rts
_possibly_zero    cmp  #0
        bne  _pos
        rts
        .pend

func_sign_uw_stack    .proc
        jsr  func_sign_uw_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sign_w_into_A    .proc
        cpy  #0
        beq  _possibly_zero
        bmi  _neg
_pos        lda  #1
        rts
_neg        lda  #-1
        rts
_possibly_zero    cmp  #0
        bne  _pos
        rts
        .pend


func_sign_w_stack    .proc
        jsr  func_sign_w_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sqrt16_stack    .proc
        jsr  func_sqrt16_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sqrt16_into_A    .proc
        ; integer square root from  http://6502org.wikidot.com/software-math-sqrt
        sta  zpWord0
        sty  zpWord0+1
        txa
        pha
        lda  #0
        sta  zpy
        sta  zpx
        ldx  #8
-        sec
        lda  zpWord0+1
        sbc  #$40
        tay
        lda  zpx
        sbc  zpy
        bcc  +
        sty  zpWord0+1
        sta  zpx
+        rol  zpy
        asl  zpWord0
        rol  zpWord0+1
        rol  zpx
        asl  zpWord0
        rol  zpWord0+1
        rol  zpx
        dex
        bne  -
        pla
        tax
        lda  zpy
        rts
        .pend

func_rnd_stack    .proc
    ; -- put a random ubyte on the estack
        jsr  math.randbyte
        sta  stack.lo,x
        dex
        rts
        .pend

func_rndw_stack    .proc
    ; -- put a random uword on the estack
        jsr  math.randword
        sta  stack.lo,x
        tya
        sta  stack.hi,x
        dex
        rts
        .pend


func_sort_ub    .proc
        ; 8bit unsigned sort
        ; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
        ; input:  address of array to sort in zpWord0, length in S
        ; first, put pointer BEFORE array
        sta  zpy
        lda  zpWord0
        bne  +
        dec  zpWord0+1
+        dec  zpWord0
_sortloop    ldy  zpy        ;start of subroutine sort
        lda  (zpWord0),y    ;last value in (what is left of) sequence to be sorted
        sta  zpx        ;save value. will be over-written by largest number
        jmp  _l2
_l1        dey
        beq  _l3
        lda  (zpWord0),y
        cmp  zpWord1+1
        bcc  _l1
_l2        sty  zpWord1    ;index of potentially largest value
        sta  zpWord1+1    ;potentially largest value
        jmp  _l1
_l3        ldy  zpy        ;where the largest value shall be put
        lda  zpWord1+1    ;the largest value
        sta  (zpWord0),y    ;put largest value in place
        ldy  zpWord1    ;index of free space
        lda  zpx        ;the over-written value
        sta  (zpWord0),y    ;put the over-written value in the free space
        dec  zpy        ;end of the shorter sequence still left
        bne  _sortloop            ;start working with the shorter sequence
        rts
        .pend


func_sort_b    .proc
        ; 8bit signed sort
        ; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
        ; input:  address of array to sort in zpWord0, length in A
        ; first, put pointer BEFORE array
        sta  zpy
        lda  zpWord0
        bne  +
        dec  zpWord0+1
+        dec  zpWord0
_sortloop    ldy  zpy        ;start of subroutine sort
        lda  (zpWord0),y    ;last value in (what is left of) sequence to be sorted
        sta  zpx        ;save value. will be over-written by largest number
        jmp  _l2
_l1        dey
        beq  _l3
        lda  (zpWord0),y
        cmp  zpWord1+1
        bmi  _l1
_l2        sty  zpWord1    ;index of potentially largest value
        sta  zpWord1+1    ;potentially largest value
        jmp  _l1
_l3        ldy  zpy        ;where the largest value shall be put
        lda  zpWord1+1    ;the largest value
        sta  (zpWord0),y    ;put largest value in place
        ldy  zpWord1    ;index of free space
        lda  zpx        ;the over-written value
        sta  (zpWord0),y    ;put the over-written value in the free space
        dec  zpy        ;end of the shorter sequence still left
        bne  _sortloop            ;start working with the shorter sequence
        rts
        .pend


func_sort_uw    .proc
        ; 16bit unsigned sort
        ; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
        ; input:  address of array to sort in zpWord0, length in A
        ; first: subtract 2 of the pointer
        asl  a
        sta  zpy
        lda  zpWord0
        sec
        sbc  #2
        sta  zpWord0
        bcs  _sort_loop
        dec  zpWord0+1
_sort_loop    ldy  zpy        ;start of subroutine sort
        lda  (zpWord0),y    ;last value in (what is left of) sequence to be sorted
        sta  _work3                  ;save value. will be over-written by largest number
        iny
        lda  (zpWord0),y
        sta  _work3+1
        dey
        jmp  _l2
_l1        dey
        dey
        beq  _l3
        iny
        lda  (zpWord0),y
        dey
        cmp  zpWord1+1
        bne  +
        lda  (zpWord0),y
        cmp  zpWord1
+        bcc  _l1
_l2        sty  _work1                  ;index of potentially largest value
        lda  (zpWord0),y
        sta  zpWord1          ;potentially largest value
        iny
        lda  (zpWord0),y
        sta  zpWord1+1
        dey
        jmp  _l1
_l3        ldy  zpy           ;where the largest value shall be put
        lda  zpWord1          ;the largest value
        sta  (zpWord0),y      ;put largest value in place
        iny
        lda  zpWord1+1
        sta  (zpWord0),y
        ldy  _work1                  ;index of free space
        lda  _work3                  ;the over-written value
        sta  (zpWord0),y      ;put the over-written value in the free space
        iny
        lda  _work3+1
        sta  (zpWord0),y
        dey
        dec  zpy           ;end of the shorter sequence still left
        dec  zpy
        bne  _sort_loop           ;start working with the shorter sequence
        rts
_work1    .byte  0
_work3    .word  0
        .pend


func_sort_w    .proc
        ; 16bit signed sort
        ; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
        ; input:  address of array to sort in zpWord0, length in A
        ; first: subtract 2 of the pointer
        asl  a
        sta  zpy
        lda  zpWord0
        sec
        sbc  #2
        sta  zpWord0
        bcs  _sort_loop
        dec  zpWord0+1
_sort_loop    ldy  zpy        ;start of subroutine sort
        lda  (zpWord0),y    ;last value in (what is left of) sequence to be sorted
        sta  _work3                  ;save value. will be over-written by largest number
        iny
        lda  (zpWord0),y
        sta  _work3+1
        dey
        jmp  _l2
_l1        dey
        dey
        beq  _l3
        lda  (zpWord0),y
        cmp  zpWord1
        iny
        lda  (zpWord0),y
        dey
        sbc  zpWord1+1
        bvc  +
        eor  #$80
+        bmi  _l1
_l2        sty  _work1                  ;index of potentially largest value
        lda  (zpWord0),y
        sta  zpWord1          ;potentially largest value
        iny
        lda  (zpWord0),y
        sta  zpWord1+1
        dey
        jmp  _l1
_l3        ldy  zpy           ;where the largest value shall be put
        lda  zpWord1          ;the largest value
        sta  (zpWord0),y      ;put largest value in place
        iny
        lda  zpWord1+1
        sta  (zpWord0),y
        ldy  _work1                  ;index of free space
        lda  _work3                  ;the over-written value
        sta  (zpWord0),y      ;put the over-written value in the free space
        iny
        lda  _work3+1
        sta  (zpWord0),y
        dey
        dec  zpy           ;end of the shorter sequence still left
        dec  zpy
        bne  _sort_loop           ;start working with the shorter sequence
        rts
_work1    .byte  0
_work3    .word  0
        .pend


func_reverse_b    .proc
        ; --- reverse an array of bytes (in-place)
        ; inputs:  pointer to array in zpWord0, length in A
_index_right = zpWord1
_index_left = zpWord1+1
_loop_count = zpx
        sta  _loop_count
        lsr  _loop_count
        sec
        sbc  #1
        sta  _index_right
        lda  #0
        sta  _index_left
_loop        ldy  _index_right
        lda  (zpWord0),y
        pha
        ldy  _index_left
        lda  (zpWord0),y
        ldy  _index_right
        sta  (zpWord0),y
        pla
        ldy  _index_left
        sta  (zpWord0),y
        inc  _index_left
        dec  _index_right
        dec  _loop_count
        bne  _loop
        rts
        .pend


func_reverse_w    .proc
        ; --- reverse an array of words (in-place)
        ; inputs:  pointer to array in zpWord0, length in A
_index_first = zpWord1
_index_second = zpWord1+1
_loop_count = zpx
        pha
        asl  a     ; *2 because words
        sec
        sbc  #2
        sta  _index_first
        lda  #0
        sta  _index_second
        pla
        lsr  a
        pha
        sta  _loop_count
        ; first reverse the lsbs
_loop_lo    ldy  _index_first
        lda  (zpWord0),y
        pha
        ldy  _index_second
        lda  (zpWord0),y
        ldy  _index_first
        sta  (zpWord0),y
        pla
        ldy  _index_second
        sta  (zpWord0),y
        inc  _index_second
        inc  _index_second
        dec  _index_first
        dec  _index_first
        dec  _loop_count
        bne  _loop_lo
        ; now reverse the msbs
        dec  _index_second
        inc  _index_first
        inc  _index_first
        inc  _index_first
        pla
        sta  _loop_count
_loop_hi    ldy  _index_first
        lda  (zpWord0),y
        pha
        ldy  _index_second
        lda  (zpWord0),y
        ldy  _index_first
        sta  (zpWord0),y
        pla
        ldy  _index_second
        sta  (zpWord0),y
        dec  _index_second
        dec  _index_second
        inc  _index_first
        inc  _index_first
        dec  _loop_count
        bne  _loop_hi

        rts
        .pend


                        func_peekw   .proc
                            ; -- read the word value on the address in AY
                            sta  zpWord0
                            sty  zpWord0+1
                            ldy  #0
                            lda  (zpWord0),y
                            pha
                            iny
                            lda  (zpWord0),y
                            tay
                            pla
                            rts
                            .pend


                        func_pokew   .proc
                            ; -- store the word value in AY in the address in zpWord0
                            sty  zpx
                            ldy  #0
                            sta  (zpWord0),y
                            iny
                            lda  zpx
                            sta  (zpWord0),y
                            rts
                            .pend
    
.pend

;***********************
; #LIBRARY : 'floats' 
;***********************

floats    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:6
    AYINT_facmo = $64
    PI = 3.141592653589793
    TWOPI = 6.283185307179586

; non-zeropage variables
    MOVFM = $bba2
    FREADMEM = $bba6
    CONUPK = $ba8c
    FAREADMEM = $ba90
    MOVFA = $bbfc
    MOVAF = $bc0c
    MOVEF = $bc0f
    MOVMF = $bbd4
    FTOSWORDYA = $b1aa
    GETADR = $b7f7
    QINT = $bc9b
    AYINT = $b1bf
    GIVAYF = $b391
    FREADUY = $b3a2
    FREADSA = $bc3c
    FREADSTR = $b7b5
    FPRINTLN = $aabc
    FOUT = $bddd
    FADDH = $b849
    MUL10 = $bae2
    DIV10 = $bafe
    FCOMP = $bc5b
    FADDT = $b86a
    FADD = $b867
    FSUBT = $b853
    FSUB = $b850
    FMULTT = $ba2b
    FMULT = $ba28
    FDIVT = $bb12
    FDIV = $bb0f
    FPWRT = $bf7b
    FPWR = $bf78
    FINLOG = $bd7e
    NOTOP = $aed4
    INT = $bccc
    LOG = $b9ea
    SGN = $bc39
    SIGN = $bc2b
    ABS = $bc58
    SQR = $bf71
    SQRA = $bf74
    EXP = $bfed
    NEGOP = $bfb4
    RND = $e097
    COS = $e264
    SIN = $e26b
    TAN = $e2b4
    ATN = $e30e

; subroutines in this block
 
; --- low level floating point assembly routines for the C64

FL_ONE_const    .byte  129                 ; 1.0
FL_ZERO_const    .byte  0,0,0,0,0        ; 0.0
FL_LOG2_const    .byte  $80, $31, $72, $17, $f8    ; log(2)


floats_store_reg    .byte  0        ; temp storage


ub2float    .proc
        ; -- convert ubyte in SCRATCH_ZPB1 to float at address A/Y
        ;    clobbers A, Y
        stx  zpx
        sta  zpWord1
        sty  zpWord1+1
        ldy  zpy
        lda  #0
        jsr  GIVAYF
_fac_to_mem    ldx  zpWord1
        ldy  zpWord1+1
        jsr  MOVMF
        ldx  zpx
        rts
        .pend

b2float        .proc
        ; -- convert byte in SCRATCH_ZPB1 to float at address A/Y
        ;    clobbers A, Y
        stx  zpx
        sta  zpWord1
        sty  zpWord1+1
        lda  zpy
        jsr  FREADSA
        jmp  ub2float._fac_to_mem
        .pend

uw2float    .proc
        ; -- convert uword in SCRATCH_ZPWORD1 to float at address A/Y
        stx  zpx
        sta  zpWord1
        sty  zpWord1+1
        lda  zpWord0
        ldy  zpWord0+1
        jsr  GIVUAYFAY
        jmp  ub2float._fac_to_mem
        .pend

w2float        .proc
        ; -- convert word in SCRATCH_ZPWORD1 to float at address A/Y
        stx  zpx
        sta  zpWord1
        sty  zpWord1+1
        ldy  zpWord0
        lda  zpWord0+1
        jsr  GIVAYF
        jmp  ub2float._fac_to_mem
        .pend


cast_from_uw    .proc
        ; -- uword in A/Y into float var at (zpWord1)
        stx  zpx
        jsr  GIVUAYFAY
        jmp  ub2float._fac_to_mem
        .pend


cast_from_w    .proc
        ; -- word in A/Y into float var at (zpWord1)
        stx  zpx
        jsr  GIVAYFAY
        jmp  ub2float._fac_to_mem
        .pend


cast_from_ub    .proc
        ; -- ubyte in Y into float var at (zpWord1)
        stx  zpx
        jsr  FREADUY
        jmp  ub2float._fac_to_mem
        .pend


cast_from_b    .proc
        ; -- byte in A into float var at (zpWord1)
        stx  zpx
        jsr  FREADSA
        jmp  ub2float._fac_to_mem
        .pend

cast_as_uw_into_ya    .proc               ; also used for float 2 ub
        ; -- cast float at A/Y to uword into Y/A
        jsr  MOVFM
        jmp  cast_FAC1_as_uw_into_ya
        .pend

cast_as_w_into_ay    .proc               ; also used for float 2 b
        ; -- cast float at A/Y to word into A/Y
        jsr  MOVFM
        jmp  cast_FAC1_as_w_into_ay
        .pend

cast_FAC1_as_uw_into_ya    .proc               ; also used for float 2 ub
        ; -- cast fac1 to uword into Y/A
        stx  zpx
        jsr  GETADR     ; into Y/A
        ldx  zpx
        rts
        .pend

cast_FAC1_as_w_into_ay    .proc               ; also used for float 2 b
        ; -- cast fac1 to word into A/Y
        stx  zpx
        jsr  AYINT
        ldy  floats.AYINT_facmo
        lda  floats.AYINT_facmo+1
        ldx  zpx
        rts
        .pend


stack_b2float    .proc
        ; -- b2float operating on the stack
        inx
        lda  stack.lo,x
        stx  zpx
        jsr  FREADSA
        jmp  push_fac1._internal
        .pend

stack_w2float    .proc
        ; -- w2float operating on the stack
        inx
        ldy  stack.lo,x
        lda  stack.hi,x
        stx  zpx
        jsr  GIVAYF
        jmp  push_fac1._internal
        .pend

stack_ub2float    .proc
        ; -- ub2float operating on the stack
        inx
        lda  stack.lo,x
        stx  zpx
        tay
        lda  #0
        jsr  GIVAYF
        jmp  push_fac1._internal
        .pend

stack_uw2float    .proc
        ; -- uw2float operating on the stack
        inx
        lda  stack.lo,x
        ldy  stack.hi,x
        stx  zpx
        jsr  GIVUAYFAY
        jmp  push_fac1._internal
        .pend

stack_float2w    .proc               ; also used for float2b
        jsr  pop_float_fac1
        stx  zpx
        jsr  AYINT
        ldx  zpx
        lda  floats.AYINT_facmo
        sta  stack.hi,x
        lda  floats.AYINT_facmo+1
        sta  stack.lo,x
        dex
        rts
        .pend

stack_float2uw    .proc               ; also used for float2ub
        jsr  pop_float_fac1
        stx  zpx
        jsr  GETADR
        ldx  zpx
        sta  stack.hi,x
        tya
        sta  stack.lo,x
        dex
        rts
        .pend

push_float    .proc
        ; ---- push mflpt5 in A/Y onto stack
        ; (taking 3 stack positions = 6 bytes of which 1 is padding)
        sta  zpWord0
        sty  zpWord0+1
        ldy  #0
        lda  (zpWord0),y
        sta  stack.lo,x
        iny
        lda  (zpWord0),y
        sta  stack.hi,x
        dex
        iny
        lda  (zpWord0),y
        sta  stack.lo,x
        iny
        lda  (zpWord0),y
        sta  stack.hi,x
        dex
        iny
        lda  (zpWord0),y
        sta  stack.lo,x
        dex
        rts
        .pend

pop_float    .proc
        ; ---- pops mflpt5 from stack to memory A/Y
        ; (frees 3 stack positions = 6 bytes of which 1 is padding)
        sta  zpWord0
        sty  zpWord0+1
        ldy  #4
        inx
        lda  stack.lo,x
        sta  (zpWord0),y
        dey
        inx
        lda  stack.hi,x
        sta  (zpWord0),y
        dey
        lda  stack.lo,x
        sta  (zpWord0),y
        dey
        inx
        lda  stack.hi,x
        sta  (zpWord0),y
        dey
        lda  stack.lo,x
        sta  (zpWord0),y
        rts
        .pend

pop_float_fac1    .proc
        ; -- pops float from stack into FAC1
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  pop_float
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jmp  MOVFM
        .pend

copy_float    .proc
        ; -- copies the 5 bytes of the mflt value pointed to by zpWord0,
        ;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
        sta  zpWord1
        sty  zpWord1+1
        ldy  #0
        lda  (zpWord0),y
        sta  (zpWord1),y
        iny
        lda  (zpWord0),y
        sta  (zpWord1),y
        iny
        lda  (zpWord0),y
        sta  (zpWord1),y
        iny
        lda  (zpWord0),y
        sta  (zpWord1),y
        iny
        lda  (zpWord0),y
        sta  (zpWord1),y
        rts
        .pend

inc_var_f    .proc
        ; -- add 1 to float pointed to by A/Y
        sta  zpWord0
        sty  zpWord0+1
        stx  zpx
        jsr  MOVFM
        lda  #<FL_ONE_const
        ldy  #>FL_ONE_const
        jsr  FADD
        ldx  zpWord0
        ldy  zpWord0+1
        jsr  MOVMF
        ldx  zpx
        rts
        .pend

dec_var_f    .proc
        ; -- subtract 1 from float pointed to by A/Y
        sta  zpWord0
        sty  zpWord0+1
        stx  zpx
        lda  #<FL_ONE_const
        ldy  #>FL_ONE_const
        jsr  MOVFM
        lda  zpWord0
        ldy  zpWord0+1
        jsr  FSUB
        ldx  zpWord0
        ldy  zpWord0+1
        jsr  MOVMF
        ldx  zpx
        rts
        .pend


pop_2_floats_f2_in_fac1    .proc
        ; -- pop 2 floats from stack, load the second one in FAC1 as well
        lda  #<fmath_float2
        ldy  #>fmath_float2
        jsr  pop_float
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  pop_float
        lda  #<fmath_float2
        ldy  #>fmath_float2
        jmp  MOVFM
        .pend


fmath_float1    .byte 0,0,0,0,0    ; storage for a mflpt5 value
fmath_float2    .byte 0,0,0,0,0    ; storage for a mflpt5 value


push_fac1    .proc
        ; -- push the float in FAC1 onto the stack
        stx  zpx
_internal    ldx  #<fmath_float1
        ldy  #>fmath_float1
        jsr  MOVMF
        lda  #<fmath_float1
        ldy  #>fmath_float1
        ldx  zpx
        jmp  push_float
        .pend

div_f        .proc
        ; -- push f1/f2 on stack
        jsr  pop_2_floats_f2_in_fac1
        stx  zpx
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  FDIV
        jmp  push_fac1._internal
        .pend

add_f        .proc
        ; -- push f1+f2 on stack
        jsr  pop_2_floats_f2_in_fac1
        stx  zpx
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  FADD
        jmp  push_fac1._internal
        .pend

sub_f        .proc
        ; -- push f1-f2 on stack
        jsr  pop_2_floats_f2_in_fac1
        stx  zpx
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  FSUB
        jmp  push_fac1._internal
        .pend

mul_f        .proc
        ; -- push f1*f2 on stack
        jsr  pop_2_floats_f2_in_fac1
        stx  zpx
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  FMULT
        jmp  push_fac1._internal
        .pend

neg_f        .proc
        ; -- toggle the sign bit on the stack
        lda  stack.hi+3,x
        eor  #$80
        sta  stack.hi+3,x
        rts
        .pend

var_fac1_less_f    .proc
        ; -- is the float in FAC1 < the variable AY?
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #255
        beq  +
        lda  #0
        rts
+        lda  #1
        rts
        .pend

var_fac1_lesseq_f    .proc
        ; -- is the float in FAC1 <= the variable AY?
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #0
        beq  +
        cmp  #255
        beq  +
        lda  #0
        rts
+        lda  #1
        rts
        .pend

var_fac1_greater_f    .proc
        ; -- is the float in FAC1 > the variable AY?
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #1
        beq  +
        lda  #0
        rts
+        lda  #1
        rts
        .pend

var_fac1_greatereq_f    .proc
        ; -- is the float in FAC1 >= the variable AY?
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #0
        beq  +
        cmp  #1
        beq  +
        lda  #0
        rts
+        lda  #1
        rts
        .pend

var_fac1_notequal_f    .proc
        ; -- are the floats numbers in FAC1 and the variable AY *not* identical?
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        and  #1
        rts
        .pend

vars_equal_f    .proc
        ; -- are the mflpt5 numbers in zpWord0 and AY identical?
        sta  zpWord1
        sty  zpWord1+1
        ldy  #0
        lda  (zpWord0),y
        cmp  (zpWord1),y
        bne  _false
        iny
        lda  (zpWord0),y
        cmp  (zpWord1),y
        bne  _false
        iny
        lda  (zpWord0),y
        cmp  (zpWord1),y
        bne  _false
        iny
        lda  (zpWord0),y
        cmp  (zpWord1),y
        bne  _false
        iny
        lda  (zpWord0),y
        cmp  (zpWord1),y
        bne  _false
        lda  #1
        rts
_false        lda  #0
        rts
        .pend

equal_f        .proc
        ; -- are the two mflpt5 numbers on the stack identical?
        inx
        inx
        inx
        inx
        lda  stack.lo-3,x
        cmp  stack.lo,x
        bne  _equals_false
        lda  stack.lo-2,x
        cmp  stack.lo+1,x
        bne  _equals_false
        lda  stack.lo-1,x
        cmp  stack.lo+2,x
        bne  _equals_false
        lda  stack.hi-2,x
        cmp  stack.hi+1,x
        bne  _equals_false
        lda  stack.hi-1,x
        cmp  stack.hi+2,x
        bne  _equals_false
_equals_true    lda  #1
_equals_store    inx
        sta  stack.lo+1,x
        rts
_equals_false    lda  #0
        beq  _equals_store
        .pend

notequal_f    .proc
        ; -- are the two mflpt5 numbers on the stack different?
        jsr  equal_f
        eor  #1        ; invert the result
        sta  stack.lo+1,x
        rts
        .pend

vars_less_f    .proc
        ; -- is float in AY < float in zpWord1 ?
        jsr  MOVFM
        lda  zpWord1
        ldy  zpWord1+1
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #255
        bne  +
        lda  #1
        rts
+        lda  #0
        rts
        .pend

vars_lesseq_f    .proc
        ; -- is float in AY <= float in zpWord1 ?
        jsr  MOVFM
        lda  zpWord1
        ldy  zpWord1+1
        stx  zpx
        jsr  FCOMP
        ldx  zpx
        cmp  #255
        bne  +
-        lda  #1
        rts
+        cmp  #0
        beq  -
        lda  #0
        rts
        .pend

less_f        .proc
        ; -- is f1 < f2?
        jsr  compare_floats
        cmp  #255
        beq  compare_floats._return_true
        bne  compare_floats._return_false
        .pend


lesseq_f    .proc
        ; -- is f1 <= f2?
        jsr  compare_floats
        cmp  #255
        beq  compare_floats._return_true
        cmp  #0
        beq  compare_floats._return_true
        bne  compare_floats._return_false
        .pend

greater_f    .proc
        ; -- is f1 > f2?
        jsr  compare_floats
        cmp  #1
        beq  compare_floats._return_true
        bne  compare_floats._return_false
        .pend

greatereq_f    .proc
        ; -- is f1 >= f2?
        jsr  compare_floats
        cmp  #1
        beq  compare_floats._return_true
        cmp  #0
        beq  compare_floats._return_true
        bne  compare_floats._return_false
        .pend

compare_floats    .proc
        lda  #<fmath_float2
        ldy  #>fmath_float2
        jsr  pop_float
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  pop_float
        lda  #<fmath_float1
        ldy  #>fmath_float1
        jsr  MOVFM        ; fac1 = flt1
        lda  #<fmath_float2
        ldy  #>fmath_float2
        stx  zpx
        jsr  FCOMP        ; A = flt1 compared with flt2 (0=equal, 1=flt1>flt2, 255=flt1<flt2)
        ldx  zpx
        rts
_return_false    lda  #0
_return_result  sta  stack.lo,x
        dex
        rts
_return_true    lda  #1
        bne  _return_result
        .pend

set_array_float_from_fac1    .proc
        ; -- set the float in FAC1 in the array (index in A, array in zpWord0)
        sta  zpy
        asl  a
        asl  a
        clc
        adc  zpy
        ldy  zpWord0+1
        clc
        adc  zpWord0
        bcc  +
        iny
+        stx  floats_store_reg
        tax
        jsr  MOVMF
        ldx  floats_store_reg
        rts
        .pend


set_0_array_float    .proc
        ; -- set a float in an array to zero (index in A, array in zpWord0)
        sta  zpy
        asl  a
        asl  a
        clc
        adc  zpy
        tay
        lda  #0
        sta  (zpWord0),y
        iny
        sta  (zpWord0),y
        iny
        sta  (zpWord0),y
        iny
        sta  (zpWord0),y
        iny
        sta  (zpWord0),y
        rts
        .pend


set_array_float        .proc
        ; -- set a float in an array to a value (index in A, float in zpWord0, array in zpWord1)
        sta  zpy
        asl  a
        asl  a
        clc
        adc  zpy
        adc  zpWord1
        ldy  zpWord1+1
        bcc  +
        iny
+        jmp  copy_float
            ; -- copies the 5 bytes of the mflt value pointed to by SCRATCH_ZPWORD1,
            ;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
        .pend


equal_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        beq  _true
        bne  _false
_true        lda  #1
        sta  stack.lo,x
        dex
        rts
_false        lda  #0
        sta  stack.lo,x
        dex
        rts
        .pend

notequal_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        bne  equal_zero._true
        beq  equal_zero._false
        .pend

greater_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        beq  equal_zero._false
        bpl  equal_zero._true
        jmp  equal_zero._false
        .pend

less_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        bmi  equal_zero._true
        jmp  equal_zero._false
        .pend

greaterequal_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        bpl  equal_zero._true
        jmp  equal_zero._false
        .pend

lessequal_zero    .proc
        jsr  floats.pop_float_fac1
        jsr  floats.SIGN
        beq  equal_zero._true
        bmi  equal_zero._true
        jmp  equal_zero._false
        .pend
    ;    src line: library:/prog8lib/c64/floats.p8:175
; --- floating point builtin functions


func_sign_f_stack    .proc
        jsr  func_sign_f_into_A
        sta  stack.lo,x
        dex
        rts
        .pend

func_sign_f_into_A    .proc
        jsr  MOVFM
        jmp  SIGN
        .pend

func_swap_f    .proc
        ; -- swap floats pointed to by SCRATCH_ZPWORD1, SCRATCH_ZPWORD2
        ldy  #4
-               lda  (zpWord0),y
        pha
        lda  (zpWord1),y
        sta  (zpWord0),y
        pla
        sta  (zpWord1),y
        dey
        bpl  -
        rts
        .pend

func_reverse_f    .proc
        ; --- reverse an array of floats (array in zpWord0, num elements in A)
_left_index = zpWord1
_right_index = zpWord1+1
_loop_count = zpx
        pha
        jsr  a_times_5
        sec
        sbc  #5
        sta  _right_index
        lda  #0
        sta  _left_index
        pla
        lsr  a
        sta  _loop_count
_loop        ; push the left indexed float on the stack
        ldy  _left_index
        lda  (zpWord0),y
        pha
        iny
        lda  (zpWord0),y
        pha
        iny
        lda  (zpWord0),y
        pha
        iny
        lda  (zpWord0),y
        pha
        iny
        lda  (zpWord0),y
        pha
        ; copy right index float to left index float
        ldy  _right_index
        lda  (zpWord0),y
        ldy  _left_index
        sta  (zpWord0),y
        inc  _left_index
        inc  _right_index
        ldy  _right_index
        lda  (zpWord0),y
        ldy  _left_index
        sta  (zpWord0),y
        inc  _left_index
        inc  _right_index
        ldy  _right_index
        lda  (zpWord0),y
        ldy  _left_index
        sta  (zpWord0),y
        inc  _left_index
        inc  _right_index
        ldy  _right_index
        lda  (zpWord0),y
        ldy  _left_index
        sta  (zpWord0),y
        inc  _left_index
        inc  _right_index
        ldy  _right_index
        lda  (zpWord0),y
        ldy  _left_index
        sta  (zpWord0),y
        ; pop the float off the stack into the right index float
        ldy  _right_index
        pla
        sta  (zpWord0),y
        dey
        pla
        sta  (zpWord0),y
        dey
        pla
        sta  (zpWord0),y
        dey
        pla
        sta  (zpWord0),y
        dey
        pla
        sta  (zpWord0),y
        inc  _left_index
        lda  _right_index
        sec
        sbc  #9
        sta  _right_index
        dec  _loop_count
        bne  _loop
        rts

        .pend



a_times_5    .proc
        sta  zpy
        asl  a
        asl  a
        clc
        adc  zpy
        rts
        .pend

func_any_f_into_A    .proc
        jsr  a_times_5
        jmp  prog8_lib.func_any_b_into_A
        .pend

func_all_f_into_A    .proc
        jsr  a_times_5
        jmp  prog8_lib.func_all_b_into_A
        .pend

func_any_f_stack    .proc
        jsr  a_times_5
        jmp  prog8_lib.func_any_b_stack
        .pend

func_all_f_stack    .proc
        jsr  a_times_5
        jmp  prog8_lib.func_all_b_stack
        .pend
 

FREADS32    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:92
        lda  $62
        eor  #$ff
        asl  a
        lda  #0
        ldx  #$a0
        jmp  $bc4f        ; internal BASIC routine
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:102

FREADUS32    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:104
        sec
        lda  #0
        ldx  #$a0
        jmp  $bc4f        ; internal BASIC routine
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:112

FREADS24AXY    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:115
        sty  $62
        stx  $63
        sta  $64
        lda  $62
        eor  #$FF
        asl  a
        lda  #0
        sta  $65
        ldx  #$98
        jmp  $bc4f        ; internal BASIC routine
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:129

GIVUAYFAY    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:131
        sty  $62
        sta  $63
        ldx  #$90
        sec
        jmp  $bc49        ; internal BASIC routine
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:140

GIVAYFAY    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:142
        sta  zpx
        tya
        ldy  zpx
        jmp  GIVAYF        ; this uses the inverse order, Y/A
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:150

FTOSWRDAY    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:152
        jsr  FTOSWORDYA    ; note the inverse Y/A order
        sta  zpx
        tya
        ldy  zpx
        rts
    .pend
    ;    src line: library:/prog8lib/c64/floats.p8:161

GETADRAY    .proc
    ;    src line: library:/prog8lib/c64/floats.p8:163
        jsr  GETADR        ; this uses the inverse order, Y/A
        sta  zpy
        tya
        ldy  zpy
        rts
    .pend
    ;    src line: library:/prog8lib/floats_functions.p8:54

sin    .proc
; statements
 
        lda  #<angle
        ldy  #>angle
        jsr  MOVFM
        stx  zpx
        jsr  SIN
        ldx  zpx
        rts
; variables

; non-zeropage variables
angle    .byte  0,0,0,0,0  ; float
    .pend
    ;    src line: library:/prog8lib/floats_functions.p8:143

rad    .proc
; statements
 
        lda  #<angle
        ldy  #>angle
        jsr  MOVFM
        stx  zpx
        lda  #<_pi_div_180
        ldy  #>_pi_div_180
        jsr  FMULT
        ldx  zpx
        rts
_pi_div_180    .byte 123, 14, 250, 53, 18        ; pi / 180
; variables

; non-zeropage variables
angle    .byte  0,0,0,0,0  ; float
    .pend
    .pend

;***********************
; #LIBRARY : 'graphics' 
;***********************

graphics    .proc
 
internal_plotx     = 4     ; zp UWORD

                    BITMAP_ADDRESS = $2000
                    WIDTH = $0140
                    HEIGHT = $c8

; non-zeropage variables

; subroutines in this block
 

                        clear_screen    .proc
                        bgcolor     = 64        ; zp UBYTE
                        pixelcolor     = 65     ; zp UBYTE
                        ; simple int arg(s) passed via register(s)
                            sta  pixelcolor
                            sty  bgcolor
                        ; statements
                         
                            txa
                            pha
                            
                                        lda  #<$2000
                                        sta  cx16.r0
                                        lda  #>$2000
                                        sta  cx16.r0+1
                                        
                                        lda  #<$1f40
                                        sta  cx16.r1
                                        lda  #>$1f40
                                        sta  cx16.r1+1
                                        
                                        lda  #0
                                        jsr  sys.memset
                            
                            pla
                            tax
 
                            lda  pixelcolor
                            sta  stack.lo,x
                            dex
                            lda  stack.lo+1,x
                            asl  a
                            asl  a
                            asl  a
                            asl  a
                            sta  stack.lo+1,x
                            lda  bgcolor
                            sta  stack.lo,x
                            dex
                            jsr  prog8_lib.bitor_b
                            inx
                            lda  stack.lo,x
                            pha
                            lda  #0
                            tay
                            pla
                            jmp  txt.fill_screen
     
                        ; variables

                        ; non-zeropage variables
                            .pend
  

horizontal_line    .proc
length                  = 66     ; zp UWORD
y                       = 68     ; zp UBYTE
x                       = 69     ; zp UWORD
separate_pixels         = 71     ; zp UBYTE
addr                    = 75     ; zp UWORD
; statements
 
    ldy  length+1
    lda  length
    cpy  #>8
    bcc  +
    bne  prog8_label_59_if_end
    cmp  #<8
    bcs  prog8_label_59_if_end
+
    ;    src line: library:/prog8lib/c64/graphics.p8:152
    lda  x
    ldy  x+1
    sta  internal_plotx
    sty  internal_plotx+1
    
    ;    src line: library:/prog8lib/c64/graphics.p8:153
    ldy  length
    beq  prog8_label_60_repeatend
    sty  prog8_label_62_counter
prog8_label_61_repeat
    ;    src line: library:/prog8lib/c64/graphics.p8:154
    txa
    pha
    lda  y
    jsr  internal_plot
    pla
    tax
    ;    src line: library:/prog8lib/c64/graphics.p8:155
    inc  internal_plotx
    bne  +
    inc  internal_plotx+1
+
    dec  prog8_label_62_counter
    bne  prog8_label_61_repeat
prog8_label_60_repeatend
    ;    src line: library:/prog8lib/c64/graphics.p8:157
    rts
prog8_label_59_if_end
 
    lda  x
    sta  separate_pixels
 
    and  #7
    sta  separate_pixels
 
    lda  x
    sta  stack.lo,x
    lda  x+1
    sta  stack.hi,x
    dex
    lda  #<$fff8
    sta  stack.lo,x
    lda  #>$fff8
    sta  stack.hi,x
    dex
    
    jsr  prog8_lib.bitand_w
    ldy  y
    jsr  get_y_lookup
    sta  stack.lo,x
    tya
    sta  stack.hi,x
    dex
    jsr  prog8_lib.add_w
    inx
    lda  stack.lo,x
    sta  addr
    lda  stack.hi,x
    sta  addr+1
    
    ;    src line: library:/prog8lib/c64/graphics.p8:163
    lda  separate_pixels
    beq  prog8_label_63_if_end
    ;    src line: library:/prog8lib/c64/graphics.p8:164
    lda  addr
    sta  zpWord0
    lda  addr+1
    sta  zpWord0+1
    ldy  separate_pixels
    lda  hline_filled_right,y
    eor  #255
    ldy  #0
    ora  (zpWord0),y
    sta  (zpWord0),y
    ;    src line: library:/prog8lib/c64/graphics.p8:176
    lda  addr
    clc
    adc  #8
    sta  addr
    bcc  +
    inc  addr+1
+
    ;    src line: library:/prog8lib/c64/graphics.p8:177
    lda  length
    clc
    adc  separate_pixels
    sta  length
    bcc  +
    inc  length+1
+
    ;    src line: library:/prog8lib/c64/graphics.p8:178
    lda  length
    sec
    sbc  #8
    sta  length
    bcs  +
    dec  length+1
+
prog8_label_63_if_end
    ;    src line: library:/prog8lib/c64/graphics.p8:181
    lda  length
    ora  length+1
    beq  prog8_label_64_if_end
    ;    src line: library:/prog8lib/c64/graphics.p8:182
                lda  length
                and  #7
                sta  separate_pixels
                stx  zpx
                lsr  length+1
                ror  length
                lsr  length+1
                ror  length
                lsr  length+1
                ror  length
                lda  addr
                sta  _modified+1
                lda  addr+1
                sta  _modified+2
                lda  length
                ora  length+1
                beq  _zero
                ldy  length
                ldx  #$ff
_modified       stx  $ffff      ; modified
                lda  _modified+1
                clc
                adc  #8
                sta  _modified+1
                bcc  +
                inc  _modified+2
+               dey
                bne  _modified
_zero           ldx  zpx

                ldy  separate_pixels
                beq  hline_zero2
                lda  _modified+1
                sta  zpWord0
                lda  _modified+2
                sta  zpWord0+1
                lda  hline_filled_right,y
                ldy  #0
                ora  (zpWord0),y
                sta  (zpWord0),y
                jmp  hline_zero2
hline_filled_right   .byte  0, %10000000, %11000000, %11100000, %11110000, %11111000, %11111100, %11111110
hline_zero2
prog8_label_64_if_end
    ;    src line: library:/prog8lib/c64/graphics.p8:150
    rts
; variables
prog8_label_62_counter = 115

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/c64/graphics.p8:230

vertical_line    .proc
height     = 72     ; zp UBYTE
y     = 77     ; zp UBYTE
x     = 78     ; zp UWORD
; statements
 
    lda  x
    ldy  x+1
    sta  internal_plotx
    sty  internal_plotx+1
    
    ;    src line: library:/prog8lib/c64/graphics.p8:232
    ldy  height
    beq  prog8_label_65_repeatend
    sty  prog8_label_67_counter
prog8_label_66_repeat
    ;    src line: library:/prog8lib/c64/graphics.p8:233
    txa
    pha
    lda  y
    jsr  internal_plot
    pla
    tax
    ;    src line: library:/prog8lib/c64/graphics.p8:234
    inc  y
    dec  prog8_label_67_counter
    bne  prog8_label_66_repeat
prog8_label_65_repeatend
    ;    src line: library:/prog8lib/c64/graphics.p8:230
    rts
; variables
prog8_label_67_counter = 116

; non-zeropage variables
    .pend
    ;    src line: library:/prog8lib/c64/graphics.p8:307
    ;    src line: library:/prog8lib/c64/graphics.p8:320

internal_plot    .proc
    ;    src line: library:/prog8lib/c64/graphics.p8:321
        tay
        lda  internal_plotx+1
        sta  zpWord1+1
        lsr  a            ; 0
        sta  zpWord1
        lda  internal_plotx
        pha
        and  #7
        tax

        lda  _y_lookup_lo,y
        clc
        adc  zpWord1
        sta  zpWord1
        lda  _y_lookup_hi,y
        adc  zpWord1+1
        sta  zpWord1+1

        pla     ; internal_plotx
        and  #%11111000
        tay
        lda  (zpWord1),y
        ora  _ormask,x
        sta  (zpWord1),y
        rts

_ormask     .byte 128, 64, 32, 16, 8, 4, 2, 1

; note: this can be even faster if we also have a 256 byte x-lookup table, but hey.
; see http://codebase64.org/doku.php?id=base:various_techniques_to_calculate_adresses_fast_common_screen_formats_for_pixel_graphics
; the y lookup tables encodes this formula:  BITMAP_ADDRESS + 320*(py>>3) + (py & 7)    (y from 0..199)
; We use the 64tass syntax for range expressions to calculate this table on assembly time.

_plot_y_values := $2000 + 320*(range(200)>>3) + (range(200) & 7)

_y_lookup_lo    .byte  <_plot_y_values
_y_lookup_hi    .byte  >_plot_y_values



    .pend
    

get_y_lookup    .proc
    
            lda  internal_plot._y_lookup_lo,y
            pha
            lda  internal_plot._y_lookup_hi,y
            tay
            pla
            rts
    .pend
prog8_init_vars    .block
    ;    src line: library:/prog8lib/c64/graphics.p8:318
    lda  #0
    sta  internal_plotx
    sta  internal_plotx+1
    
    rts
    .bend
    .pend
; global float constants
; memory slabs
prog8_slabs    .block
    .bend
prog8_program_end    ; end of program label for progend()
