; 6502 assembly code for 'prova'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2022-10-08T09:57:02
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=BASICSAFE

.cpu  '6502'
.enc  'none'
zpa = 2
zpx = 3
zpWord1 = 251    ; word
zpWord0 = 253    ; word
.weak
stack.lo = $ce00
stack.hi = $cf00
.endweak
; ---- basic program with sys call ----
* = $0801
	.word  (+), 2022
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint	; assembly code starts here
	jsr  c64.init_system
	jsr  c64.init_system_phase2
	jsr  main.start
	lda  #31
	sta  $01
	jmp  c64.cleanup_at_exit

; ---- block: 'main' ----
main	.proc
	;	src line: prova.p8:8

; non-zeropage variables

; subroutines in this block
	;	src line: prova.p8:10

start	.proc
; program startup initialization
	cld
+       tsx
	stx  prog8_lib.orig_stackpointer    ; required for sys.exit()
	ldx  #255       ; init estack ptr
	clv
	clc
; statements
	;	src line: prova.p8:12
	;	src line: prova.p8:14
	lda  #<prog8_float_const_0
	ldy  #>prog8_float_const_0
	sta  zpWord1
	sty  zpWord1+1
	lda  #<f
	ldy  #>f
	jsr  floats.copy_float
    
    
	;	src line: prova.p8:16
	lda  #<f
	ldy  #>f
	sta  zpWord1
	sty  zpWord1+1
	lda  #<floats.print_f.value
	ldy  #>floats.print_f.value
	jsr  floats.copy_float
	jmp  floats.print_f
    
	;	src line: prova.p8:10
; variables

; non-zeropage variables
f	.byte  0,0,0,0,0  ; float
	.pend
	.pend

; ---- block: 'txt' ----
txt	.proc
	;	src line: library:/prog8lib/c64/textio.p8:7
	DEFAULT_WIDTH = $28
	DEFAULT_HEIGHT = $19

; non-zeropage variables
	chrout = $ffd2

; subroutines in this block
	;	src line: library:/prog8lib/c64/textio.p8:9
	;	src line: library:/prog8lib/c64/textio.p8:10
	;	src line: library:/prog8lib/c64/textio.p8:29

column	.proc
	;	src line: library:/prog8lib/c64/textio.p8:31
        sec
        jsr  c64.PLOT
        tay
        clc
        jmp  c64.PLOT
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:40

fill_screen	.proc
	;	src line: library:/prog8lib/c64/textio.p8:44
		pha
		tya
		jsr  clear_screencolors
		pla
		jmp  clear_screenchars
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:55

clear_screenchars	.proc
	;	src line: library:/prog8lib/c64/textio.p8:58
		ldy  #250
-		sta  c64.Screen+250*0-1,y
		sta  c64.Screen+250*1-1,y
		sta  c64.Screen+250*2-1,y
		sta  c64.Screen+250*3-1,y
		dey
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:70

clear_screencolors	.proc
	;	src line: library:/prog8lib/c64/textio.p8:73
		ldy  #250
-		sta  c64.Colors+250*0-1,y
		sta  c64.Colors+250*1-1,y
		sta  c64.Colors+250*2-1,y
		sta  c64.Colors+250*3-1,y
		dey
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:97

scroll_left	.proc
	;	src line: library:/prog8lib/c64/textio.p8:102
		stx  zpx
		bcc _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 1,x
            sta  c64.Screen + 40*row + 0,x
            lda  c64.Colors + 40*row + 1,x
            sta  c64.Colors + 40*row + 0,x
        .next
		inx
		dey
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 1,x
            sta  c64.Screen + 40*row + 0,x
        .next
		inx
		dey
		bpl  -

		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:138

scroll_right	.proc
	;	src line: library:/prog8lib/c64/textio.p8:142
		stx  zpx
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 0,x
            sta  c64.Screen + 40*row + 1,x
            lda  c64.Colors + 40*row + 0,x
            sta  c64.Colors + 40*row + 1,x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  c64.Screen + 40*row + 0,x
            sta  c64.Screen + 40*row + 1,x
        .next
		dex
		bpl  -

		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:174

scroll_up	.proc
	;	src line: library:/prog8lib/c64/textio.p8:178
		stx  zpx
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row-1),x
            lda  c64.Colors + 40*row,x
            sta  c64.Colors + 40*(row-1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row-1),x
        .next
		dex
		bpl  -

		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:210

scroll_down	.proc
	;	src line: library:/prog8lib/c64/textio.p8:214
		stx  zpx
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  c64.Colors + 40*row,x
            sta  c64.Colors + 40*(row+1),x
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row+1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  c64.Screen + 40*row,x
            sta  c64.Screen + 40*(row+1),x
        .next
		dex
		bpl  -

		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:246

	;	src line: library:/prog8lib/c64/textio.p8:248

print	.proc
	;	src line: library:/prog8lib/c64/textio.p8:253
		sta  zpa
		sty  zpx
		ldy  #0
-		lda  (zpa),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:266

print_ub0	.proc
	;	src line: library:/prog8lib/c64/textio.p8:268
		stx  zpx
		jsr  conv.ubyte2decimal
		pha
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:283

print_ub	.proc
	;	src line: library:/prog8lib/c64/textio.p8:285
		stx  zpx
		jsr  conv.ubyte2decimal
_print_byte_digits
		pha
		cpy  #'0'
		beq  +
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		jmp  _ones
+       pla
        cmp  #'0'
        beq  _ones
        jsr  c64.CHROUT
_ones   txa
		jsr  c64.CHROUT
		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:308

print_b	.proc
	;	src line: library:/prog8lib/c64/textio.p8:310
		stx  zpx
		pha
		cmp  #0
		bpl  +
		lda  #'-'
		jsr  c64.CHROUT
+		pla
		jsr  conv.byte2decimal
		jmp  print_ub._print_byte_digits
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:323

print_ubhex	.proc
	;	src line: library:/prog8lib/c64/textio.p8:325
		stx  zpx
		bcc  +
		pha
		lda  #'$'
		jsr  c64.CHROUT
		pla
+		jsr  conv.ubyte2hex
		jsr  c64.CHROUT
		tya
		jsr  c64.CHROUT
		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:341

print_ubbin	.proc
	;	src line: library:/prog8lib/c64/textio.p8:343
		stx  zpx
		sta  zpa
		bcc  +
		lda  #'%'
		jsr  c64.CHROUT
+		ldy  #8
-		lda  #'0'
		asl  zpa
		bcc  +
		lda  #'1'
+		jsr  c64.CHROUT
		dey
		bne  -
		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:362

print_uwbin	.proc
	;	src line: library:/prog8lib/c64/textio.p8:364
		pha
		tya
		jsr  print_ubbin
		pla
		clc
		jmp  print_ubbin
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:374

print_uwhex	.proc
	;	src line: library:/prog8lib/c64/textio.p8:377
		pha
		tya
		jsr  print_ubhex
		pla
		clc
		jmp  print_ubhex
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:387

print_uw0	.proc
	;	src line: library:/prog8lib/c64/textio.p8:389
	    stx  zpx
		jsr  conv.uword2decimal
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
        beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:403

print_uw	.proc
	;	src line: library:/prog8lib/c64/textio.p8:405
	    stx  zpx
		jsr  conv.uword2decimal
		ldx  zpx
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
		beq  _allzero
		cmp  #'0'
		bne  _gotdigit
		iny
		bne  -

_gotdigit
		jsr  c64.CHROUT
		iny
		lda  conv.uword2decimal.decTenThousands,y
		bne  _gotdigit
		rts
_allzero
        lda  #'0'
        jmp  c64.CHROUT
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:429

print_w	.proc
	;	src line: library:/prog8lib/c64/textio.p8:431
		cpy  #0
		bpl  +
		pha
		lda  #'-'
		jsr  c64.CHROUT
		tya
		eor  #255
		tay
		pla
		eor  #255
		clc
		adc  #1
		bcc  +
		iny
+		jmp  print_uw
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:450

input_chars	.proc
	;	src line: library:/prog8lib/c64/textio.p8:454
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0				; char counter = 0
-		jsr  c64.CHRIN
		cmp  #$0d			; return (ascii 13) pressed?
		beq  +				; yes, end.
		sta  (zpWord1),y	; else store char in buffer
		iny
		bne  -
+		lda  #0
		sta  (zpWord1),y	; finish string with 0 byte
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:471

setchr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:473
		pha
		tya
		asl  a
		tay
		lda  _screenrows+1,y
		sta  _mod+2
		txa
		clc
		adc  _screenrows,y
		sta  _mod+1
		bcc  +
		inc  _mod+2
+		pla
_mod		sta  $ffff		; modified
		rts

_screenrows	.word  $0400 + range(0, 1000, 40)
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:494

getchr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:496
		pha
		tya
		asl  a
		tay
		lda  setchr._screenrows+1,y
		sta  _mod+2
		pla
		clc
		adc  setchr._screenrows,y
		sta  _mod+1
		bcc  _mod
		inc  _mod+2
_mod		lda  $ffff		; modified
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:514

setclr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:516
		pha
		tya
		asl  a
		tay
		lda  _colorrows+1,y
		sta  _mod+2
		txa
		clc
		adc  _colorrows,y
		sta  _mod+1
		bcc  +
		inc  _mod+2
+		pla
_mod		sta  $ffff		; modified
		rts

_colorrows	.word  $d800 + range(0, 1000, 40)
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:537

getclr	.proc
	;	src line: library:/prog8lib/c64/textio.p8:539
		pha
		tya
		asl  a
		tay
		lda  setclr._colorrows+1,y
		sta  _mod+2
		pla
		clc
		adc  setclr._colorrows,y
		sta  _mod+1
		bcc  _mod
		inc  _mod+2
_mod		lda  $ffff		; modified
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:583

plot	.proc
	;	src line: library:/prog8lib/c64/textio.p8:585
		stx  zpx
		tax
		clc
		jsr  c64.PLOT
		ldx  zpx
		rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:595

width	.proc
	;	src line: library:/prog8lib/c64/textio.p8:597
        jsr  c64.SCREEN
        txa
        rts
	.pend
	;	src line: library:/prog8lib/c64/textio.p8:604

height	.proc
	;	src line: library:/prog8lib/c64/textio.p8:606
        jsr  c64.SCREEN
        tya
        rts
	.pend
	.pend

; ---- block: 'c64' ----
c64	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:4
	TIME_HI = $a0
	TIME_MID = $a1
	TIME_LO = $a2
	STATUS = $90
	STKEY = $91
	SFDX = $cb
	COLOR = $0286
	HIBASE = $0288
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	SPRPTR0 = $07f8
	SPRPTR1 = $07f9
	SPRPTR2 = $07fa
	SPRPTR3 = $07fb
	SPRPTR4 = $07fc
	SPRPTR5 = $07fd
	SPRPTR6 = $07fe
	SPRPTR7 = $07ff
	SPRPTR = $07f8
	SP0X = $d000
	SP0Y = $d001
	SP1X = $d002
	SP1Y = $d003
	SP2X = $d004
	SP2Y = $d005
	SP3X = $d006
	SP3Y = $d007
	SP4X = $d008
	SP4Y = $d009
	SP5X = $d00a
	SP5Y = $d00b
	SP6X = $d00c
	SP6Y = $d00d
	SP7X = $d00e
	SP7Y = $d00f
	SPXY = $d000
	SPXYW = $d000
	MSIGX = $d010
	SCROLY = $d011
	RASTER = $d012
	LPENX = $d013
	LPENY = $d014
	SPENA = $d015
	SCROLX = $d016
	YXPAND = $d017
	VMCSB = $d018
	VICIRQ = $d019
	IREQMASK = $d01a
	SPBGPR = $d01b
	SPMC = $d01c
	XXPAND = $d01d
	SPSPCL = $d01e
	SPBGCL = $d01f
	EXTCOL = $d020
	BGCOL0 = $d021
	BGCOL1 = $d022
	BGCOL2 = $d023
	BGCOL4 = $d024
	SPMC0 = $d025
	SPMC1 = $d026
	SP0COL = $d027
	SP1COL = $d028
	SP2COL = $d029
	SP3COL = $d02a
	SP4COL = $d02b
	SP5COL = $d02c
	SP6COL = $d02d
	SP7COL = $d02e
	SPCOL = $d027
	CIA1PRA = $dc00
	CIA1PRB = $dc01
	CIA1DDRA = $dc02
	CIA1DDRB = $dc03
	CIA1TAL = $dc04
	CIA1TAH = $dc05
	CIA1TBL = $dc06
	CIA1TBH = $dc07
	CIA1TOD10 = $dc08
	CIA1TODSEC = $dc09
	CIA1TODMMIN = $dc0a
	CIA1TODHR = $dc0b
	CIA1SDR = $dc0c
	CIA1ICR = $dc0d
	CIA1CRA = $dc0e
	CIA1CRB = $dc0f
	CIA2PRA = $dd00
	CIA2PRB = $dd01
	CIA2DDRA = $dd02
	CIA2DDRB = $dd03
	CIA2TAL = $dd04
	CIA2TAH = $dd05
	CIA2TBL = $dd06
	CIA2TBH = $dd07
	CIA2TOD10 = $dd08
	CIA2TODSEC = $dd09
	CIA2TODMIN = $dd0a
	CIA2TODHR = $dd0b
	CIA2SDR = $dd0c
	CIA2ICR = $dd0d
	CIA2CRA = $dd0e
	CIA2CRB = $dd0f
	FREQLO1 = $d400
	FREQHI1 = $d401
	FREQ1 = $d400
	PWLO1 = $d402
	PWHI1 = $d403
	PW1 = $d402
	CR1 = $d404
	AD1 = $d405
	SR1 = $d406
	FREQLO2 = $d407
	FREQHI2 = $d408
	FREQ2 = $d407
	PWLO2 = $d409
	PWHI2 = $d40a
	PW2 = $d409
	CR2 = $d40b
	AD2 = $d40c
	SR2 = $d40d
	FREQLO3 = $d40e
	FREQHI3 = $d40f
	FREQ3 = $d40e
	PWLO3 = $d410
	PWHI3 = $d411
	PW3 = $d410
	CR3 = $d412
	AD3 = $d413
	SR3 = $d414
	FCLO = $d415
	FCHI = $d416
	FC = $d415
	RESFILT = $d417
	MVOL = $d418
	POTX = $d419
	POTY = $d41a
	OSC3 = $d41b
	ENV3 = $d41c
	Screen = $0400
	Colors = $d800

; non-zeropage variables
	STROUT = $ab1e
	CLEARSCR = $e544
	HOMECRSR = $e566
	IRQDFRT = $ea31
	IRQDFEND = $ea81
	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3

; subroutines in this block
 

	;	src line: library:/prog8lib/c64/syslib.p8:220

	;	src line: library:/prog8lib/c64/syslib.p8:226

STOP2	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:228
        txa
        pha
        jsr  c64.STOP
        beq  +
        pla
        tax
        lda  #0
        rts
+       pla
        tax
        lda  #1
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:244

RDTIM16	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:246
        stx  zpx
        jsr  c64.RDTIM
        pha
        txa
        tay
        pla
        ldx  zpx
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:262

init_system	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:269
        sei
        cld
        lda  #%00101111
        sta  $00
        lda  #%00100111
        sta  $01
        jsr  c64.IOINIT
        jsr  c64.RESTOR
        jsr  c64.CINT
        lda  #6
        sta  c64.EXTCOL
        lda  #7
        sta  c64.COLOR
        lda  #0
        sta  c64.BGCOL0
        jsr  disable_runstop_and_charsetswitch
        clc
        clv
        cli
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:293

init_system_phase2	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:294
        rts     ; no phase 2 steps on the C64
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:299

cleanup_at_exit	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:301
        jmp  c64.enable_runstop_and_charsetswitch
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:306

disable_runstop_and_charsetswitch	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:307
        lda  #$80
        sta  657    ; disable charset switching
        lda  #239
        sta  808    ; disable run/stop key
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:316

enable_runstop_and_charsetswitch	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:317
        lda  #0
        sta  657    ; enable charset switching
        lda  #237
        sta  808    ; enable run/stop key
        rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:326

set_irq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:327
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        adc  #0
	        sta  _use_kernal
		sei
		lda  #<_irq_handler
		sta  c64.CINV
		lda  #>_irq_handler
		sta  c64.CINV+1
		cli
		rts
_irq_handler    jsr  _irq_handler_init
_modified	jsr  $ffff                      ; modified
		jsr  _irq_handler_end
		lda  _use_kernal
		bne  +
		lda  #$ff
		sta  c64.VICIRQ			; acknowledge raster irq
		lda  c64.CIA1ICR		; acknowledge CIA1 interrupt
		; end irq processing - don't use kernal's irq handling
		pla
		tay
		pla
		tax
		pla
		rti
+		jmp  c64.IRQDFRT		; continue with normal kernal irq routine

_use_kernal     .byte  0

_irq_handler_init
		; save all zp scratch registers and the X register as these might be clobbered by the irq routine
		stx  IRQ_X_REG
		lda  zpa
		sta  IRQ_SCRATCH_ZPB1
		lda  zpx
		sta  IRQ_SCRATCH_ZPREG
		lda  zpWord1
		sta  IRQ_SCRATCH_ZPWORD1
		lda  zpWord1+1
		sta  IRQ_SCRATCH_ZPWORD1+1
		lda  zpWord0
		sta  IRQ_SCRATCH_ZPWORD2
		lda  zpWord0+1
		sta  IRQ_SCRATCH_ZPWORD2+1
		; stack protector; make sure we don't clobber the top of the evaluation stack
		dex
		dex
		dex
		dex
		dex
		dex
		cld
		rts

_irq_handler_end
		; restore all zp scratch registers and the X register
		lda  IRQ_SCRATCH_ZPB1
		sta  zpa
		lda  IRQ_SCRATCH_ZPREG
		sta  zpx
		lda  IRQ_SCRATCH_ZPWORD1
		sta  zpWord1
		lda  IRQ_SCRATCH_ZPWORD1+1
		sta  zpWord1+1
		lda  IRQ_SCRATCH_ZPWORD2
		sta  zpWord0
		lda  IRQ_SCRATCH_ZPWORD2+1
		sta  zpWord0+1
		ldx  IRQ_X_REG
		rts

IRQ_X_REG		.byte  0
IRQ_SCRATCH_ZPB1	.byte  0
IRQ_SCRATCH_ZPREG	.byte  0
IRQ_SCRATCH_ZPWORD1	.word  0
IRQ_SCRATCH_ZPWORD2	.word  0
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:410

restore_irq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:411
		sei
		lda  #<c64.IRQDFRT
		sta  c64.CINV
		lda  #>c64.IRQDFRT
		sta  c64.CINV+1
		lda  #0
		sta  c64.IREQMASK	; disable raster irq
		lda  #%10000001
		sta  c64.CIA1ICR	; restore CIA1 irq
		cli
		rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:426

set_rasterirq	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:427
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        adc  #0
	        sta  set_irq._use_kernal
		lda  cx16.r0
		ldy  cx16.r0+1
		sei
		jsr  _setup_raster_irq
		lda  #<_raster_irq_handler
		sta  c64.CINV
		lda  #>_raster_irq_handler
		sta  c64.CINV+1
		cli
		rts

_raster_irq_handler
		jsr  set_irq._irq_handler_init
_modified	jsr  $ffff              ; modified
		jsr  set_irq._irq_handler_end
                lda  #$ff
                sta  c64.VICIRQ			; acknowledge raster irq
		lda  set_irq._use_kernal
		bne  +
		; end irq processing - don't use kernal's irq handling
		pla
		tay
		pla
		tax
		pla
		rti
+		jmp  c64.IRQDFRT                ; continue with kernal irq routine

_setup_raster_irq
		pha
		lda  #%01111111
		sta  c64.CIA1ICR    ; "switch off" interrupts signals from cia-1
		sta  c64.CIA2ICR    ; "switch off" interrupts signals from cia-2
		and  c64.SCROLY
		sta  c64.SCROLY     ; clear most significant bit of raster position
		lda  c64.CIA1ICR    ; ack previous irq
		lda  c64.CIA2ICR    ; ack previous irq
		pla
		sta  c64.RASTER     ; set the raster line number where interrupt should occur
		cpy  #0
		beq  +
		lda  c64.SCROLY
		ora  #%10000000
		sta  c64.SCROLY     ; set most significant bit of raster position
+		lda  #%00000001
		sta  c64.IREQMASK   ;enable raster interrupt signals from vic
		rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:487
	target = $40

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/c64/syslib.p8:490
	;	src line: library:/prog8lib/c64/syslib.p8:493

reset_system	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:495
            sei
            lda  #14
            sta  $01        ; bank the kernal in
            jmp  (c64.RESET_VEC)
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:514

waitvsync	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:517
-           bit  c64.SCROLY
            bpl  -
-           bit  c64.SCROLY
            bmi  -
            rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:526
	;	src line: library:/prog8lib/c64/syslib.p8:535

internal_stringcopy	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:537
		sta  zpWord1
		sty  zpWord1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:546

memcopy	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:549
            ldx  cx16.r0
            stx  zpWord1        ; source in ZP
            ldx  cx16.r0+1
            stx  zpWord1+1
            ldx  cx16.r1
            stx  zpWord0        ; target in ZP
            ldx  cx16.r1+1
            stx  zpWord0+1
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            ; decrease source and target pointers so we can simply index by Y
            lda  zpWord1
            bne  +
            dec  zpWord1+1
+           dec  zpWord1
            lda  zpWord0
            bne  +
            dec  zpWord0+1
+           dec  zpWord0

-           lda  (zpWord1),y
            sta  (zpWord0),y
            dey
            bne  -
            rts

_longcopy
            sta  zpa        ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (zpWord1),y
            sta  (zpWord0),y
            iny
            bne  -
            inc  zpWord1+1
            inc  zpWord0+1
            dex
            bne  -
            ldy  zpa
            bne  _copyshort
            rts
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:602

memset	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:603
            ldy  cx16.r0
            sty  zpWord1
            ldy  cx16.r0+1
            sty  zpWord1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:614

memsetw	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:615
            ldx  cx16.r0
            stx  zpWord1
            ldx  cx16.r0+1
            stx  zpWord1+1
            ldx  cx16.r1
            stx  zpWord0
            ldx  cx16.r1+1
            stx  zpWord0+1
            jmp  prog8_lib.memsetw
	.pend
	;	src line: library:/prog8lib/c64/syslib.p8:628
	;	src line: library:/prog8lib/c64/syslib.p8:635
	;	src line: library:/prog8lib/c64/syslib.p8:641
	;	src line: library:/prog8lib/c64/syslib.p8:647
	;	src line: library:/prog8lib/c64/syslib.p8:653
	;	src line: library:/prog8lib/c64/syslib.p8:659
	;	src line: library:/prog8lib/c64/syslib.p8:672
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	;	src line: library:/prog8lib/c64/syslib.p8:681
	r0 = $cf00
	r1 = $cf02
	r2 = $cf04
	r3 = $cf06
	r4 = $cf08
	r5 = $cf0a
	r6 = $cf0c
	r7 = $cf0e
	r8 = $cf10
	r9 = $cf12
	r10 = $cf14
	r11 = $cf16
	r12 = $cf18
	r13 = $cf1a
	r14 = $cf1c
	r15 = $cf1e
	r0s = $cf00
	r1s = $cf02
	r2s = $cf04
	r3s = $cf06
	r4s = $cf08
	r5s = $cf0a
	r6s = $cf0c
	r7s = $cf0e
	r8s = $cf10
	r9s = $cf12
	r10s = $cf14
	r11s = $cf16
	r12s = $cf18
	r13s = $cf1a
	r14s = $cf1c
	r15s = $cf1e
	r0L = $cf00
	r1L = $cf02
	r2L = $cf04
	r3L = $cf06
	r4L = $cf08
	r5L = $cf0a
	r6L = $cf0c
	r7L = $cf0e
	r8L = $cf10
	r9L = $cf12
	r10L = $cf14
	r11L = $cf16
	r12L = $cf18
	r13L = $cf1a
	r14L = $cf1c
	r15L = $cf1e
	r0H = $cf01
	r1H = $cf03
	r2H = $cf05
	r3H = $cf07
	r4H = $cf09
	r5H = $cf0b
	r6H = $cf0d
	r7H = $cf0f
	r8H = $cf11
	r9H = $cf13
	r10H = $cf15
	r11H = $cf17
	r12H = $cf19
	r13H = $cf1b
	r14H = $cf1d
	r15H = $cf1f
	r0sL = $cf00
	r1sL = $cf02
	r2sL = $cf04
	r3sL = $cf06
	r4sL = $cf08
	r5sL = $cf0a
	r6sL = $cf0c
	r7sL = $cf0e
	r8sL = $cf10
	r9sL = $cf12
	r10sL = $cf14
	r11sL = $cf16
	r12sL = $cf18
	r13sL = $cf1a
	r14sL = $cf1c
	r15sL = $cf1e
	r0sH = $cf01
	r1sH = $cf03
	r2sH = $cf05
	r3sH = $cf07
	r4sH = $cf09
	r5sH = $cf0b
	r6sH = $cf0d
	r7sH = $cf0f
	r8sH = $cf11
	r9sH = $cf13
	r10sH = $cf15
	r11sH = $cf17
	r12sH = $cf19
	r13sH = $cf1b
	r14sH = $cf1d
	r15sH = $cf1f

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/c64/syslib.p8:689
	;	src line: library:/prog8lib/c64/syslib.p8:690
	;	src line: library:/prog8lib/c64/syslib.p8:691
	;	src line: library:/prog8lib/c64/syslib.p8:692
	;	src line: library:/prog8lib/c64/syslib.p8:693
	;	src line: library:/prog8lib/c64/syslib.p8:694
	;	src line: library:/prog8lib/c64/syslib.p8:695
	;	src line: library:/prog8lib/c64/syslib.p8:696
	;	src line: library:/prog8lib/c64/syslib.p8:697
	;	src line: library:/prog8lib/c64/syslib.p8:698
	;	src line: library:/prog8lib/c64/syslib.p8:699
	;	src line: library:/prog8lib/c64/syslib.p8:700
	;	src line: library:/prog8lib/c64/syslib.p8:701
	;	src line: library:/prog8lib/c64/syslib.p8:702
	;	src line: library:/prog8lib/c64/syslib.p8:703
	;	src line: library:/prog8lib/c64/syslib.p8:704
	;	src line: library:/prog8lib/c64/syslib.p8:706
	;	src line: library:/prog8lib/c64/syslib.p8:707
	;	src line: library:/prog8lib/c64/syslib.p8:708
	;	src line: library:/prog8lib/c64/syslib.p8:709
	;	src line: library:/prog8lib/c64/syslib.p8:710
	;	src line: library:/prog8lib/c64/syslib.p8:711
	;	src line: library:/prog8lib/c64/syslib.p8:712
	;	src line: library:/prog8lib/c64/syslib.p8:713
	;	src line: library:/prog8lib/c64/syslib.p8:714
	;	src line: library:/prog8lib/c64/syslib.p8:715
	;	src line: library:/prog8lib/c64/syslib.p8:716
	;	src line: library:/prog8lib/c64/syslib.p8:717
	;	src line: library:/prog8lib/c64/syslib.p8:718
	;	src line: library:/prog8lib/c64/syslib.p8:719
	;	src line: library:/prog8lib/c64/syslib.p8:720
	;	src line: library:/prog8lib/c64/syslib.p8:721
	;	src line: library:/prog8lib/c64/syslib.p8:723
	;	src line: library:/prog8lib/c64/syslib.p8:724
	;	src line: library:/prog8lib/c64/syslib.p8:725
	;	src line: library:/prog8lib/c64/syslib.p8:726
	;	src line: library:/prog8lib/c64/syslib.p8:727
	;	src line: library:/prog8lib/c64/syslib.p8:728
	;	src line: library:/prog8lib/c64/syslib.p8:729
	;	src line: library:/prog8lib/c64/syslib.p8:730
	;	src line: library:/prog8lib/c64/syslib.p8:731
	;	src line: library:/prog8lib/c64/syslib.p8:732
	;	src line: library:/prog8lib/c64/syslib.p8:733
	;	src line: library:/prog8lib/c64/syslib.p8:734
	;	src line: library:/prog8lib/c64/syslib.p8:735
	;	src line: library:/prog8lib/c64/syslib.p8:736
	;	src line: library:/prog8lib/c64/syslib.p8:737
	;	src line: library:/prog8lib/c64/syslib.p8:738
	;	src line: library:/prog8lib/c64/syslib.p8:740
	;	src line: library:/prog8lib/c64/syslib.p8:741
	;	src line: library:/prog8lib/c64/syslib.p8:742
	;	src line: library:/prog8lib/c64/syslib.p8:743
	;	src line: library:/prog8lib/c64/syslib.p8:744
	;	src line: library:/prog8lib/c64/syslib.p8:745
	;	src line: library:/prog8lib/c64/syslib.p8:746
	;	src line: library:/prog8lib/c64/syslib.p8:747
	;	src line: library:/prog8lib/c64/syslib.p8:748
	;	src line: library:/prog8lib/c64/syslib.p8:749
	;	src line: library:/prog8lib/c64/syslib.p8:750
	;	src line: library:/prog8lib/c64/syslib.p8:751
	;	src line: library:/prog8lib/c64/syslib.p8:752
	;	src line: library:/prog8lib/c64/syslib.p8:753
	;	src line: library:/prog8lib/c64/syslib.p8:754
	;	src line: library:/prog8lib/c64/syslib.p8:755
	;	src line: library:/prog8lib/c64/syslib.p8:757
	;	src line: library:/prog8lib/c64/syslib.p8:758
	;	src line: library:/prog8lib/c64/syslib.p8:759
	;	src line: library:/prog8lib/c64/syslib.p8:760
	;	src line: library:/prog8lib/c64/syslib.p8:761
	;	src line: library:/prog8lib/c64/syslib.p8:762
	;	src line: library:/prog8lib/c64/syslib.p8:763
	;	src line: library:/prog8lib/c64/syslib.p8:764
	;	src line: library:/prog8lib/c64/syslib.p8:765
	;	src line: library:/prog8lib/c64/syslib.p8:766
	;	src line: library:/prog8lib/c64/syslib.p8:767
	;	src line: library:/prog8lib/c64/syslib.p8:768
	;	src line: library:/prog8lib/c64/syslib.p8:769
	;	src line: library:/prog8lib/c64/syslib.p8:770
	;	src line: library:/prog8lib/c64/syslib.p8:771
	;	src line: library:/prog8lib/c64/syslib.p8:772
	;	src line: library:/prog8lib/c64/syslib.p8:774
	;	src line: library:/prog8lib/c64/syslib.p8:775
	;	src line: library:/prog8lib/c64/syslib.p8:776
	;	src line: library:/prog8lib/c64/syslib.p8:777
	;	src line: library:/prog8lib/c64/syslib.p8:778
	;	src line: library:/prog8lib/c64/syslib.p8:779
	;	src line: library:/prog8lib/c64/syslib.p8:780
	;	src line: library:/prog8lib/c64/syslib.p8:781
	;	src line: library:/prog8lib/c64/syslib.p8:782
	;	src line: library:/prog8lib/c64/syslib.p8:783
	;	src line: library:/prog8lib/c64/syslib.p8:784
	;	src line: library:/prog8lib/c64/syslib.p8:785
	;	src line: library:/prog8lib/c64/syslib.p8:786
	;	src line: library:/prog8lib/c64/syslib.p8:787
	;	src line: library:/prog8lib/c64/syslib.p8:788
	;	src line: library:/prog8lib/c64/syslib.p8:789
	.pend

; ---- block: 'conv' ----
conv	.proc
	;	src line: library:/prog8lib/conv.p8:3

; non-zeropage variables
string_out	; PETSCII:"????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00

; subroutines in this block
	;	src line: library:/prog8lib/conv.p8:7
	;	src line: library:/prog8lib/conv.p8:9

str_ub0	.proc
	;	src line: library:/prog8lib/conv.p8:11
            stx  zpx
            jsr  conv.ubyte2decimal
            sty  string_out
            sta  string_out+1
            stx  string_out+2
            lda  #0
            sta  string_out+3
            ldx  zpx
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:24

str_ub	.proc
	;	src line: library:/prog8lib/conv.p8:26
		stx  zpx
		ldy  #0
		sty  zpa
		jsr  conv.ubyte2decimal
_output_byte_digits
                ; hundreds?
		cpy  #'0'
		beq  +
		pha
		tya
		ldy  zpa
		sta  string_out,y
		pla
		inc  zpa
		; tens?
+		ldy  zpa
                cmp  #'0'
		beq  +
		sta  string_out,y
		iny
+               ; ones.
                txa
                sta  string_out,y
                iny
                lda  #0
                sta  string_out,y
                ldx  zpx
                rts
	.pend
	;	src line: library:/prog8lib/conv.p8:58

str_b	.proc
	;	src line: library:/prog8lib/conv.p8:60
            stx  zpx
            ldy  #0
            sty  zpa
            cmp  #0
            bpl  +
            pha
            lda  #'-'
            sta  string_out
            inc  zpa
            pla
+	    jsr  conv.byte2decimal
            bra  str_ub._output_byte_digits
	.pend
	;	src line: library:/prog8lib/conv.p8:76

str_ubhex	.proc
	;	src line: library:/prog8lib/conv.p8:78
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            lda  #0
            sta  string_out+2
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:88

str_ubbin	.proc
	;	src line: library:/prog8lib/conv.p8:90
	    sta  zpa
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  zpa
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:107

str_uwbin	.proc
	;	src line: library:/prog8lib/conv.p8:109
	    sta  zpx
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  zpx
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out+8,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:128

str_uwhex	.proc
	;	src line: library:/prog8lib/conv.p8:130
            pha
            tya
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            pla
            jsr  conv.ubyte2hex
            sta  string_out+2
            sty  string_out+3
            lda  #0
            sta  string_out+4
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:146

str_uw0	.proc
	;	src line: library:/prog8lib/conv.p8:148
	    stx  zpx
	    jsr  conv.uword2decimal
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            sta  string_out,y
            beq  +
            iny
            bne  -
+           ldx  zpx
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:162

str_uw	.proc
	;	src line: library:/prog8lib/conv.p8:164
	    stx  zpx
	    jsr  conv.uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   sta  string_out,x
            inx
            iny
            lda  conv.uword2decimal.decTenThousands,y
            bne  _gotdigit
_end        lda  #0
            sta  string_out,x
            ldx  zpx
            rts

_allzero    lda  #'0'
            sta  string_out,x
            inx
            bne  _end
	.pend
	;	src line: library:/prog8lib/conv.p8:193

str_w	.proc
	;	src line: library:/prog8lib/conv.p8:195
	    cpy  #0
	    bpl  str_uw
	    stx  zpx
	    pha
	    lda  #'-'
	    sta  string_out
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+	    jsr  conv.uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	;	src line: ~dummy~:0
  rts
	.pend
	;	src line: library:/prog8lib/conv.p8:220

any2uword	.proc
	;	src line: library:/prog8lib/conv.p8:226
	pha
	sta  zpWord1
	sty  zpWord1+1
	ldy  #0
	lda  (zpWord1),y
	ldy  zpWord1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        pha
        lda  cx16.r15
        sta  zpa        ; result value
        pla
        sta  cx16.r15
        sty  cx16.r15+1
        lda  zpa
        rts
	.pend
	;	src line: library:/prog8lib/conv.p8:257
	;	src line: library:/prog8lib/conv.p8:267
	;	src line: library:/prog8lib/conv.p8:277

str2uword	.proc
	;	src line: library:/prog8lib/conv.p8:282
_result = zpWord1
        	sta  zpWord0
        	sty  zpWord0+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (zpWord0),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  zpx
		lda  _result
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  _result
		sta  _result
		lda  zpx
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend
	;	src line: library:/prog8lib/conv.p8:336

str2word	.proc
	;	src line: library:/prog8lib/conv.p8:341
_result = zpWord1
		sta  zpWord0
		sty  zpWord0+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (zpWord0),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (zpWord0),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
_negative	.byte  0
	.pend
	;	src line: library:/prog8lib/conv.p8:395

hex2uword	.proc
	;	src line: library:/prog8lib/conv.p8:400
	sta  zpWord0
	sty  zpWord0+1
	ldy  #0
	sty  zpWord1
	sty  zpWord1+1
	sty  cx16.r15+1
	lda  (zpWord0),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  zpa
	lda  (zpWord0),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  zpWord1
	rol  zpWord1+1
	asl  zpWord1
	rol  zpWord1+1
	asl  zpWord1
	rol  zpWord1+1
	asl  zpWord1
	rol  zpWord1+1
	and  #$0f
	clc
	adc  zpa
	ora  zpWord1
	sta  zpWord1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  zpWord1
	ldy  zpWord1+1
	rts
_add_letter
	pha
	lda  #9
	sta  zpa
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
	.pend
	;	src line: library:/prog8lib/conv.p8:465

bin2uword	.proc
	;	src line: library:/prog8lib/conv.p8:469
	sta  zpWord0
	sty  zpWord0+1
	ldy  #0
	sty  zpWord1
	sty  zpWord1+1
	sty  cx16.r15+1
	lda  (zpWord0),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (zpWord0),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  zpWord1
	rol  zpWord1+1
	and  #1
	ora  zpWord1
	sta  zpWord1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  zpWord1
	ldy  zpWord1+1
	rts
	.pend
	;	src line: library:/prog8lib/conv.p8:505

ubyte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:507
		ldy  #uword2decimal.ASCII_0_OFFSET
		bne  uword2decimal.hex_try200
		rts
	.pend
	;	src line: library:/prog8lib/conv.p8:514

uword2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:520
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?f=2&t=11341&start=15

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = zpa	; byte in zeropage
hexHigh      	= zpWord1	; byte in zeropage
hexLow       	= zpWord1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2³ @110/111
    beq    _useZero               ;2³ @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2³ @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2³ @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2³ @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

decTenThousands   	.byte  0
decThousands    	.byte  0
decHundreds		.byte  0
decTens			.byte  0
decOnes   		.byte  0
			.byte  0		; zero-terminate the decimal output string
	.pend
	;	src line: library:/prog8lib/conv.p8:689

byte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:692
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  ubyte2decimal
	.pend
	;	src line: library:/prog8lib/conv.p8:702

ubyte2hex	.proc
	;	src line: library:/prog8lib/conv.p8:704
		stx  zpx
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		ldx  zpx
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
	.pend
	;	src line: library:/prog8lib/conv.p8:724

uword2hex	.proc
	;	src line: library:/prog8lib/conv.p8:726
		sta  zpx
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  zpx
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
output		.text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
	.pend
	.pend

; ---- block: 'string' ----
string	.proc
	;	src line: library:/prog8lib/string.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/string.p8:5

length	.proc
	;	src line: library:/prog8lib/string.p8:10
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
-		lda  (zpWord1),y
		beq  +
		iny
		bne  -
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:22

left	.proc
	;	src line: library:/prog8lib/string.p8:27
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		ldy  cx16.r0
		sty  zpWord1
		ldy  cx16.r0+1
		sty  zpWord1+1
		ldy  cx16.r1
		sty  zpWord0
		ldy  cx16.r1+1
		sty  zpWord0+1
		tay
		lda  #0
		sta  (zpWord0),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (zpWord1),y
		sta  (zpWord0),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:53

right	.proc
	;	src line: library:/prog8lib/string.p8:58
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
                sta  zpa
                lda  cx16.r0
                ldy  cx16.r0+1
                jsr  string.length
                tya
                sec
                sbc  zpa
                clc
                adc  cx16.r0
		sta  zpWord1
		lda  cx16.r0+1
		adc  #0
		sta  zpWord1+1
		ldy  cx16.r1
		sty  zpWord0
		ldy  cx16.r1+1
		sty  zpWord0+1
		ldy  zpa
		lda  #0
		sta  (zpWord0),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (zpWord1),y
		sta  (zpWord0),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	;	src line: library:/prog8lib/string.p8:92

slice	.proc
	;	src line: library:/prog8lib/string.p8:98
                ; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  zpa
		lda  cx16.r0
		sta  zpWord1
		lda  cx16.r0+1
		sta  zpWord1+1
		lda  cx16.r1
		sta  zpWord0
		lda  cx16.r1+1
		sta  zpWord0+1

		; adjust src location
		clc
		lda  zpWord1
		adc  zpa
		sta  zpWord1
		bcc  +
		inc  zpWord1+1
+		lda  #0
		sta  (zpWord0),y
		beq  _startloop
-		lda  (zpWord1),y
		sta  (zpWord0),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend
	;	src line: library:/prog8lib/string.p8:130

find	.proc
	;	src line: library:/prog8lib/string.p8:133
                ; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
                sta  zpa
		lda  cx16.r0
		ldy  cx16.r0+1
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
-		lda  (zpWord1),y
		beq  _notfound
		cmp  zpa
		beq  _found
		iny
		bne  -
_notfound	lda  #0
                clc
		rts
_found		tya
                sec
                rts
	.pend
	;	src line: library:/prog8lib/string.p8:156

copy	.proc
	;	src line: library:/prog8lib/string.p8:161
		sta  zpWord1
		sty  zpWord1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	;	src line: library:/prog8lib/string.p8:170

compare	.proc
	;	src line: library:/prog8lib/string.p8:175
		sta  zpWord0
		sty  zpWord0+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend
	;	src line: library:/prog8lib/string.p8:184

lower	.proc
	;	src line: library:/prog8lib/string.p8:188
            sta  zpWord1
            sty  zpWord1+1
            ldy  #0
-           lda  (zpWord1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (zpWord1),y
            iny
            bne  -
_done       rts
	.pend
	;	src line: library:/prog8lib/string.p8:207

upper	.proc
	;	src line: library:/prog8lib/string.p8:209
            sta  zpWord1
            sty  zpWord1+1
            ldy  #0
-           lda  (zpWord1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (zpWord1),y
            iny
            bne  -
_done       rts
	.pend
	;	src line: library:/prog8lib/string.p8:247

pattern_match	.proc
	;	src line: library:/prog8lib/string.p8:248
; pattern matching of a string.
; Input:  cx16.r0:  A NUL-terminated, <255-length pattern
;              AY:  A NUL-terminated, <255-length string
;
; Output: A = 1 if the string matches the pattern, A = 0 if not.
;
; Notes:  Clobbers A, X, Y. Each * in the pattern uses 4 bytes of stack.
;
; see http://6502.org/source/strings/patmatch.htm

str = zpWord1

	stx  zpx
	sta  str
	sty  str+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	adc  #0
	ldx  zpx
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (str),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (str),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (str),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend
	.pend

1234567

; ---- block: 'floats' ----
floats	.proc
                                    ;	src line: library:/prog8lib/c64/floats.p8:6
                                    AYINT_facmo = $64
                                    PI = 3.141592653589793
                                    TWOPI = 6.283185307179586

                                ; non-zeropage variables
                                                            MOVFM = $bba2
                                                            FREADMEM = $bba6
                                                            CONUPK = $ba8c
                                                            FAREADMEM = $ba90
                                                            MOVFA = $bbfc
                                                            MOVAF = $bc0c
                                                            MOVEF = $bc0f
                                                            MOVMF = $bbd4
                                                            FTOSWORDYA = $b1aa
                                                            GETADR = $b7f7
                                                            QINT = $bc9b
                                                            AYINT = $b1bf
                                                            GIVAYF = $b391
                                                            FREADUY = $b3a2
                                                            FREADSA = $bc3c
                                                            FREADSTR = $b7b5
                                                            FPRINTLN = $aabc
                                                            FOUT = $bddd
                                                            FADDH = $b849
                                                            MUL10 = $bae2
                                                            DIV10 = $bafe
                                                            FCOMP = $bc5b
                                                            FADDT = $b86a
                                                            FADD = $b867
                                                            FSUBT = $b853
                                                            FSUB = $b850
                                                            FMULTT = $ba2b
                                                            FMULT = $ba28
                                                            FDIVT = $bb12
                                                            FDIV = $bb0f
                                                            FPWRT = $bf7b
                                                            FPWR = $bf78
                                                            FINLOG = $bd7e
                                                            NOTOP = $aed4
                                                            INT = $bccc
                                                            LOG = $b9ea
                                                            SGN = $bc39
                                                            SIGN = $bc2b
                                                            ABS = $bc58
                                                            SQR = $bf71
                                                            SQRA = $bf74
                                                            EXP = $bfed
                            NEGOP = $bfb4
                                    
                            RND = $e097
                                                
                                                COS = $e264
                                                SIN = $e26b
                                                TAN = $e2b4
                                                ATN = $e30e

; subroutines in this block

; --- low level floating point assembly routines for the C64

                    FL_ONE_const	.byte  129     			; 1.0
                    FL_ZERO_const	.byte  0,0,0,0,0		; 0.0
                    FL_LOG2_const	.byte  $80, $31, $72, $17, $f8	; log(2)


zpx	.byte  0		; temp storage


1234567

            ub2float	.proc
                    ; -- convert ubyte in zpx to float at address A/Y
                    ;    clobbers A, Y
                    stx  zpx
                    sta  zpWord0
                    sty  zpWord0+1
                    ldy  zpa
                    lda  #0
                    jsr  GIVAYF
            _fac_to_mem	
                    ldx  zpWord0
                    ldy  zpWord0+1
                    jsr  MOVMF
                    ldx  zpx
                    rts
                    .pend

            b2float		.proc
                    ; -- convert byte in zpx to float at address A/Y
                    ;    clobbers A, Y
                    stx  zpx
                    sta  zpWord0
                    sty  zpWord0+1
                    lda  zpa
                    jsr  FREADSA
                    jmp  ub2float._fac_to_mem
                    .pend

            uw2float	.proc
                    ; -- convert uword in SCRATCH_ZPWORD1 to float at address A/Y
                    stx  zpx
                    ;sta  zpWord0
                    ;sty  zpWord0+1
                    lda  zpWord0
                    ldy  zpWord0+1
                    jsr  GIVUAYFAY
                    jmp  ub2float._fac_to_mem
                    .pend

            w2float		.proc
                    ; -- convert word in SCRATCH_ZPWORD1 to float at address A/Y
                    stx  zpx
                    sta  zpWord0
                    sty  zpWord0+1
                    ldy  zpWord1
                    lda  zpWord1+1
                    jsr  GIVAYF
                    jmp  ub2float._fac_to_mem
                    .pend


            cast_from_uw	.proc
                    ; -- uword in A/Y into float var at (zpWord0)
                    stx  zpx
                    jsr  GIVUAYFAY
                    jmp  ub2float._fac_to_mem
                    .pend


            cast_from_w	.proc
                    ; -- word in A/Y into float var at (zpWord0)
                    stx  zpx
                    jsr  GIVAYFAY
                    jmp  ub2float._fac_to_mem
                    .pend


            cast_from_ub	.proc
                    ; -- ubyte in Y into float var at (zpWord0)
                    stx  zpx
                    jsr  FREADUY
                    jmp  ub2float._fac_to_mem
                    .pend


            cast_from_b	.proc
                    ; -- byte in A into float var at (zpWord0)
                    stx  zpx
                    jsr  FREADSA
                    jmp  ub2float._fac_to_mem
                    .pend

            cast_as_uw_into_ya	.proc               ; also used for float 2 ub
                    ; -- cast float at A/Y to uword into Y/A
                    jsr  MOVFM
                    jmp  cast_FAC1_as_uw_into_ya
                    .pend

            cast_as_w_into_ay	.proc               ; also used for float 2 b
                    ; -- cast float at A/Y to word into A/Y
                    jsr  MOVFM
                    jmp  cast_FAC1_as_w_into_ay
                    .pend

            cast_FAC1_as_uw_into_ya	.proc               ; also used for float 2 ub
                    ; -- cast fac1 to uword into Y/A
                    stx  zpx
                    jsr  GETADR     ; into Y/A
                    ldx  zpx
                    rts
                    .pend

            cast_FAC1_as_w_into_ay	.proc               ; also used for float 2 b
                    ; -- cast fac1 to word into A/Y
                    stx  zpx
                    jsr  AYINT
                    ldy  floats.AYINT_facmo
                    lda  floats.AYINT_facmo+1
                    ldx  zpx
                    rts
                    .pend


            stack_b2float	.proc
                    ; -- b2float operating on the stack
                    inx
                    lda  stack.lo,x
                    stx  zpx
                    jsr  FREADSA
                    jmp  push_fac1._internal
                    .pend

            stack_w2float	.proc
                    ; -- w2float operating on the stack
                    inx
                    ldy  stack.lo,x
                    lda  stack.hi,x
                    stx  zpx
                    jsr  GIVAYF
                    jmp  push_fac1._internal
                    .pend

                stack_ub2float	.proc
                        ; -- ub2float operating on the stack
                        inx
                        lda  stack.lo,x
                        stx  zpx
                        tay
                        lda  #0
                        jsr  GIVAYF
                        jmp  push_fac1._internal
                        .pend

                        stack_uw2float	.proc
                                ; -- uw2float operating on the stack
                                inx
                                lda  stack.lo,x
                                ldy  stack.hi,x
                                stx  zpx
                                jsr  GIVUAYFAY
                                jmp  push_fac1._internal
                                .pend

                            stack_float2w	.proc               ; also used for float2b
                                    jsr  pop_float_fac1
                                    stx  zpx
                                    jsr  AYINT
                                    ldx  zpx
                                    lda  floats.AYINT_facmo
                                    sta  stack.hi,x
                                    lda  floats.AYINT_facmo+1
                                    sta  stack.lo,x
                                    dex
                                    rts
                                    .pend

                        stack_float2uw	.proc               ; also used for float2ub
                                jsr  pop_float_fac1
                                stx  zpx
                                jsr  GETADR
                                ldx  zpx
                                sta  stack.hi,x
                                tya
                                sta  stack.lo,x
                                dex
                                rts
                                .pend

                        push_float	.proc
                                ; ---- push mflpt5 in A/Y onto stack
                                ; (taking 3 stack positions = 6 bytes of which 1 is padding)
                                sta  zpWord1
                                sty  zpWord1+1
                                
                                ldy  #0
                                lda  (zpWord1),y
                                
                                sta  stack.lo,x
                                iny
                                
                                lda  (zpWord1),y
                                sta  stack.hi,x
                                
                                dex
                                iny
                                lda  (zpWord1),y
                                sta  stack.lo,x
                                
                                iny
                                lda  (zpWord1),y
                                sta  stack.hi,x
                                dex
                                
                                iny
                                lda  (zpWord1),y
                                sta  stack.lo,x
                                dex
                                
                                rts
                                .pend

                                pop_float	.proc
                                        ; ---- pops mflpt5 from stack to memory A/Y
                                        ; (frees 3 stack positions = 6 bytes of which 1 is padding)
                                        sta  zpWord1
                                        sty  zpWord1+1
                                        ldy  #4
                                        inx
                                        lda  stack.lo,x
                                        sta  (zpWord1),y
                                        dey
                                        inx
                                        lda  stack.hi,x
                                        sta  (zpWord1),y
                                        dey
                                        lda  stack.lo,x
                                        sta  (zpWord1),y
                                        dey
                                        inx
                                        lda  stack.hi,x
                                        sta  (zpWord1),y
                                        dey
                                        lda  stack.lo,x
                                        sta  (zpWord1),y
                                        rts
                                        .pend

                                    pop_float_fac1	.proc
                                            ; -- pops float from stack into FAC1
                                            lda  #<fmath_float1
                                            ldy  #>fmath_float1
                                            jsr  pop_float
                                            lda  #<fmath_float1
                                            ldy  #>fmath_float1
                                            jmp  MOVFM
                                            .pend

                                    copy_float	.proc
                                            ; -- copies the 5 bytes of the mflt value pointed to by zpWord1,
                                            ;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
                                            sta  zpWord0
                                            sty  zpWord0+1
                                            ldy  #0
                                            lda  (zpWord1),y
                                            sta  (zpWord0),y
                                            iny
                                            lda  (zpWord1),y
                                            sta  (zpWord0),y
                                            iny
                                            lda  (zpWord1),y
                                            sta  (zpWord0),y
                                            iny
                                            lda  (zpWord1),y
                                            sta  (zpWord0),y
                                            iny
                                            lda  (zpWord1),y
                                            sta  (zpWord0),y
                                            rts
                                            .pend

                                        inc_var_f	.proc
                                        ; -- add 1 to float pointed to by A/Y
                                        sta  zpWord1
                                        sty  zpWord1+1
                                        stx  zpx
                                        jsr  MOVFM
                                        lda  #<FL_ONE_const
                                        ldy  #>FL_ONE_const
                                        jsr  FADD
                                        ldx  zpWord1
                                        ldy  zpWord1+1
                                        jsr  MOVMF
                                        ldx  zpx
                                        rts
                                        .pend

                                        dec_var_f	.proc
                                        ; -- subtract 1 from float pointed to by A/Y
                                        sta  zpWord1
                                        sty  zpWord1+1
                                        stx  zpx
                                        lda  #<FL_ONE_const
                                        ldy  #>FL_ONE_const
                                        jsr  MOVFM
                                        lda  zpWord1
                                        ldy  zpWord1+1
                                        jsr  FSUB
                                        ldx  zpWord1
                                        ldy  zpWord1+1
                                        jsr  MOVMF
                                        ldx  zpx
                                        rts
                                        .pend


                                    pop_2_floats_f2_in_fac1	.proc
                                            ; -- pop 2 floats from stack, load the second one in FAC1 as well
                                            lda  #<fmath_float2
                                            ldy  #>fmath_float2
                                            jsr  pop_float
                                            lda  #<fmath_float1
                                            ldy  #>fmath_float1
                                            jsr  pop_float
                                            lda  #<fmath_float2
                                            ldy  #>fmath_float2
                                            jmp  MOVFM
                                            .pend


                                    fmath_float1	.byte 0,0,0,0,0	; storage for a mflpt5 value
                                    fmath_float2	.byte 0,0,0,0,0	; storage for a mflpt5 value


                                        push_fac1	.proc
                                                ; -- push the float in FAC1 onto the stack
                                                stx  zpx
                                        _internal	
                                                ldx  #<fmath_float1
                                                ldy  #>fmath_float1
                                                jsr  MOVMF
                                                lda  #<fmath_float1
                                                ldy  #>fmath_float1
                                                ldx  zpx
                                                jmp  push_float
                                                .pend

                                div_f		.proc
                                        ; -- push f1/f2 on stack
                                        jsr  pop_2_floats_f2_in_fac1
                                        stx  zpx
                                        lda  #<fmath_float1
                                        ldy  #>fmath_float1
                                        jsr  FDIV
                                        jmp  push_fac1._internal
                                        .pend

                                        add_f		.proc
                                                ; -- push f1+f2 on stack
                                                jsr  pop_2_floats_f2_in_fac1
                                                stx  zpx
                                                lda  #<fmath_float1
                                                ldy  #>fmath_float1
                                                jsr  FADD
                                                jmp  push_fac1._internal
                                                .pend

                                            sub_f		.proc
                                                    ; -- push f1-f2 on stack
                                                    jsr  pop_2_floats_f2_in_fac1
                                                    stx  zpx
                                                    lda  #<fmath_float1
                                                    ldy  #>fmath_float1
                                                    jsr  FSUB
                                                    jmp  push_fac1._internal
                                                    .pend

                                            mul_f		.proc
                                                    ; -- push f1*f2 on stack
                                                    jsr  pop_2_floats_f2_in_fac1
                                                    stx  zpx
                                                    lda  #<fmath_float1
                                                    ldy  #>fmath_float1
                                                    jsr  FMULT
                                                    jmp  push_fac1._internal
		.pend

neg_f		.proc
		; -- toggle the sign bit on the stack
		lda  stack.hi+3,x
		eor  #$80
		sta  stack.hi+3,x
		rts
		.pend

                    var_fac1_less_f	.proc
                            ; -- is the float in FAC1 < the variable AY?
                            stx  zpx
                            jsr  FCOMP
                            ldx  zpx
                            cmp  #255
                            beq  +
                            lda  #0
                            rts
                    +		lda  #1
                            rts
                            .pend

                        var_fac1_lesseq_f	.proc
                                ; -- is the float in FAC1 <= the variable AY?
                                stx  zpx
                                jsr  FCOMP
                                ldx  zpx
                                cmp  #0
                                beq  +
                                cmp  #255
                                beq  +
                                lda  #0
                                rts
                        +		lda  #1
                                rts
                                .pend

                            var_fac1_greater_f	.proc
                                    ; -- is the float in FAC1 > the variable AY?
                                    stx  zpx
                                    jsr  FCOMP
                                    ldx  zpx
                                    cmp  #1
                                    beq  +
                                    lda  #0
                                    rts
                            +		lda  #1
                                    rts
                                    .pend

                            var_fac1_greatereq_f	.proc
                                    ; -- is the float in FAC1 >= the variable AY?
                                    stx  zpx
                                    jsr  FCOMP
                                    ldx  zpx
                                    cmp  #0
                                    beq  +
                                    cmp  #1
                                    beq  +
                                    lda  #0
                                    rts
                            +		lda  #1
                                    rts
                                    .pend

var_fac1_notequal_f	.proc
		; -- are the floats numbers in FAC1 and the variable AY *not* identical?
		stx  zpx
		jsr  FCOMP
		ldx  zpx
		and  #1
		rts
		.pend

                        vars_equal_f	.proc
                                ; -- are the mflpt5 numbers in zpWord1 and AY identical?
                                sta  zpWord0
                                sty  zpWord0+1
                                ldy  #0
                                lda  (zpWord1),y
                                cmp  (zpWord0),y
                                bne  _false
                                iny
                                lda  (zpWord1),y
                                cmp  (zpWord0),y
                                bne  _false
                                iny
                                lda  (zpWord1),y
                                cmp  (zpWord0),y
                                bne  _false
                                iny
                                lda  (zpWord1),y
                                cmp  (zpWord0),y
                                bne  _false
                                iny
                                lda  (zpWord1),y
                                cmp  (zpWord0),y
                                bne  _false
                                lda  #1
                                rts
                        _false		lda  #0
                                rts
                                .pend

                                equal_f		.proc
                                        ; -- are the two mflpt5 numbers on the stack identical?
                                        inx
                                        inx
                                        inx
                                        inx
                                        lda  stack.lo-3,x
                                        cmp  stack.lo,x
                                        bne  _equals_false
                                        lda  stack.lo-2,x
                                        cmp  stack.lo+1,x
                                        bne  _equals_false
                                        lda  stack.lo-1,x
                                        cmp  stack.lo+2,x
                                        bne  _equals_false
                                        lda  stack.hi-2,x
                                        cmp  stack.hi+1,x
                                        bne  _equals_false
                                        lda  stack.hi-1,x
                                        cmp  stack.hi+2,x
                                        bne  _equals_false
                                _equals_true	lda  #1
                                _equals_store	inx
                                        sta  stack.lo+1,x
                                        rts
                                _equals_false	lda  #0
                                        beq  _equals_store
                                        .pend

                                notequal_f	.proc
                                        ; -- are the two mflpt5 numbers on the stack different?
                                        jsr  equal_f
                                        eor  #1		; invert the result
                                        sta  stack.lo+1,x
                                        rts
                                        .pend

                                    vars_less_f	.proc
                                            ; -- is float in AY < float in zpWord0 ?
                                            jsr  MOVFM
                                            lda  zpWord0
                                            ldy  zpWord0+1
                                            stx  zpx
                                            jsr  FCOMP
                                            ldx  zpx
                                            cmp  #255
                                            bne  +
                                            lda  #1
                                            rts
                                    +		lda  #0
                                            rts
                                            .pend

                                    vars_lesseq_f	.proc
                                            ; -- is float in AY <= float in zpWord0 ?
                                            jsr  MOVFM
                                            lda  zpWord0
                                            ldy  zpWord0+1
                                            stx  zpx
                                            jsr  FCOMP
                                            ldx  zpx
                                            cmp  #255
                                            bne  +
                                    -		lda  #1
                                            rts
                                    +		cmp  #0
                                            beq  -
                                            lda  #0
                                            rts
                                            .pend

                                    less_f		.proc
                                            ; -- is f1 < f2?
                                            jsr  compare_floats
                                            cmp  #255
                                            beq  compare_floats._return_true
                                            bne  compare_floats._return_false
                                            .pend


                                    lesseq_f	.proc
                                            ; -- is f1 <= f2?
                                            jsr  compare_floats
                                            cmp  #255
                                            beq  compare_floats._return_true
                                            cmp  #0
                                            beq  compare_floats._return_true
                                            bne  compare_floats._return_false
                                            .pend

                                    greater_f	.proc
                                            ; -- is f1 > f2?
                                            jsr  compare_floats
                                            cmp  #1
                                            beq  compare_floats._return_true
                                            bne  compare_floats._return_false
                                            .pend

                                    greatereq_f	.proc
                                            ; -- is f1 >= f2?
                                            jsr  compare_floats
                                            cmp  #1
                                            beq  compare_floats._return_true
                                            cmp  #0
                                            beq  compare_floats._return_true
                                            bne  compare_floats._return_false
                                            .pend

                                            compare_floats	.proc
                                                    lda  #<fmath_float2
                                                    ldy  #>fmath_float2
                                                    jsr  pop_float
                                                    lda  #<fmath_float1
                                                    ldy  #>fmath_float1
                                                    jsr  pop_float
                                                    lda  #<fmath_float1
                                                    ldy  #>fmath_float1
                                                    jsr  MOVFM		; fac1 = flt1
                                                    lda  #<fmath_float2
                                                    ldy  #>fmath_float2
                                                    stx  zpx
                                                    jsr  FCOMP		; A = flt1 compared with flt2 (0=equal, 1=flt1>flt2, 255=flt1<flt2)
                                                    ldx  zpx
                                                    rts
                                            _return_false	lda  #0
                                            _return_result  sta  stack.lo,x
                                                    dex
                                                    rts
                                            _return_true	lda  #1
                                                    bne  _return_result
                                                    .pend

set_array_float_from_fac1	.proc
		; -- set the float in FAC1 in the array (index in A, array in zpWord1)
		sta  zpa
		asl  a
		asl  a
		clc
		adc  zpa
		ldy  zpWord1+1
		clc
		adc  zpWord1
		bcc  +
		iny
+		stx  zpx
		tax
		jsr  MOVMF
		ldx  zpx
		rts
		.pend


set_0_array_float	.proc
		; -- set a float in an array to zero (index in A, array in zpWord1)
		sta  zpa
		asl  a
		asl  a
		clc
		adc  zpa
		tay
		lda  #0
		sta  (zpWord1),y
		iny
		sta  (zpWord1),y
		iny
		sta  (zpWord1),y
		iny
		sta  (zpWord1),y
		iny
		sta  (zpWord1),y
		rts
		.pend


set_array_float		.proc
		; -- set a float in an array to a value (index in A, float in zpWord1, array in zpWord0)
		sta  zpa
		asl  a
		asl  a
		clc
		adc  zpa
		adc  zpWord0
		ldy  zpWord0+1
		bcc  +
		iny
+		jmp  copy_float
			; -- copies the 5 bytes of the mflt value pointed to by SCRATCH_ZPWORD1,
			;    into the 5 bytes pointed to by A/Y.  Clobbers A,Y.
		.pend


                    equal_zero	.proc
                            jsr  floats.pop_float_fac1
                            jsr  floats.SIGN
                            beq  _true
                            bne  _false
                    _true		
                            lda  #1
                            sta  stack.lo,x
                            dex
                            rts
                    _false		
                            lda  #0
                            sta  stack.lo,x
                            dex
                            rts
                            .pend

                        notequal_zero	.proc
                                jsr  floats.pop_float_fac1
                                jsr  floats.SIGN
                                bne  equal_zero._true
                                beq  equal_zero._false
                                .pend

                        greater_zero	.proc
                                jsr  floats.pop_float_fac1
                                jsr  floats.SIGN
                                beq  equal_zero._false
                                bpl  equal_zero._true
                                jmp  equal_zero._false
                                .pend

                        less_zero	.proc
                                jsr  floats.pop_float_fac1
                                jsr  floats.SIGN
                                bmi  equal_zero._true
                                jmp  equal_zero._false
                                .pend

                        greaterequal_zero	.proc
                                jsr  floats.pop_float_fac1
                                jsr  floats.SIGN
                                bpl  equal_zero._true
                                jmp  equal_zero._false
                                .pend

                        lessequal_zero	.proc
                                jsr  floats.pop_float_fac1
                                jsr  floats.SIGN
                                beq  equal_zero._true
                                bmi  equal_zero._true
                                jmp  equal_zero._false
                                .pend

                                ; --- floating point builtin functions


                                func_sign_f_stack	.proc
                                        jsr  func_sign_f_into_A
                                        sta  stack.lo,x
                                        dex
                                        rts
                                        .pend

                                func_sign_f_into_A	.proc
                                        jsr  MOVFM
                                        jmp  SIGN
                                        .pend

                                    func_swap_f	.proc
                                            ; -- swap floats pointed to by SCRATCH_ZPWORD1, SCRATCH_ZPWORD2
                                            ldy  #4
                                    -               
                                            lda  (zpWord1),y
                                            pha
                                            lda  (zpWord0),y
                                            sta  (zpWord1),y
                                            pla
                                            sta  (zpWord0),y
                                            dey
                                            bpl  -
                                            rts
                                            .pend

12345678

func_reverse_f	.proc
		; --- reverse an array of floats (array in zpWord1, num elements in A)
_left_index = zpWord0
_right_index = zpWord0+1
_loop_count = zpx
		pha
		jsr  a_times_5
		sec
		sbc  #5
		sta  _right_index
		lda  #0
		sta  _left_index
		pla
		lsr  a
		sta  _loop_count
_loop		; push the left indexed float on the stack
		ldy  _left_index
		lda  (zpWord1),y
		pha
		iny
		lda  (zpWord1),y
		pha
		iny
		lda  (zpWord1),y
		pha
		iny
		lda  (zpWord1),y
		pha
		iny
		lda  (zpWord1),y
		pha
		; copy right index float to left index float
		ldy  _right_index
		lda  (zpWord1),y
		ldy  _left_index
		sta  (zpWord1),y
		inc  _left_index
		inc  _right_index
		ldy  _right_index
		lda  (zpWord1),y
		ldy  _left_index
		sta  (zpWord1),y
		inc  _left_index
		inc  _right_index
		ldy  _right_index
		lda  (zpWord1),y
		ldy  _left_index
		sta  (zpWord1),y
		inc  _left_index
		inc  _right_index
		ldy  _right_index
		lda  (zpWord1),y
		ldy  _left_index
		sta  (zpWord1),y
		inc  _left_index
		inc  _right_index
		ldy  _right_index
		lda  (zpWord1),y
		ldy  _left_index
		sta  (zpWord1),y
		; pop the float off the stack into the right index float
		ldy  _right_index
		pla
		sta  (zpWord1),y
		dey
		pla
		sta  (zpWord1),y
		dey
		pla
		sta  (zpWord1),y
		dey
		pla
		sta  (zpWord1),y
		dey
		pla
		sta  (zpWord1),y
		inc  _left_index
		lda  _right_index
		sec
		sbc  #9
		sta  _right_index
		dec  _loop_count
		bne  _loop
		rts

		.pend



                                a_times_5	.proc
                                        sta  zpa
                                        asl  a
                                        asl  a
                                        clc
                                        adc  zpa
                                        rts
                                        .pend

                                func_any_f_into_A	.proc
                                        jsr  a_times_5
                                        jmp  prog8_lib.func_any_b_into_A
                                        .pend

                                func_all_f_into_A	.proc
                                        jsr  a_times_5
                                        jmp  prog8_lib.func_all_b_into_A
                                        .pend

                                func_any_f_stack	.proc
                                        jsr  a_times_5
                                        jmp  prog8_lib.func_any_b_stack
                                        .pend

                                func_all_f_stack	.proc
                                        jsr  a_times_5
                                        jmp  prog8_lib.func_all_b_stack
                                        .pend
 

FREADS32	.proc
 
		lda  $62
		eor  #$ff
		asl  a
		lda  #0
		ldx  #$a0
		jmp  $bc4f		; internal BASIC routine
	.pend
 

FREADUS32	.proc
 
		sec
		lda  #0
		ldx  #$a0
		jmp  $bc4f		; internal BASIC routine
	.pend
 

FREADS24AXY	.proc
 
		sty  $62
		stx  $63
		sta  $64
		lda  $62
		eor  #$FF
		asl  a
		lda  #0
		sta  $65
		ldx  #$98
		jmp  $bc4f		; internal BASIC routine
	.pend
 

                GIVUAYFAY	.proc
                 
                        sty  $62
                        sta  $63
                        ldx  #$90
                        sec
                        jmp  $bc49		; internal BASIC routine
                    .pend
 

GIVAYFAY	.proc
 
		sta  zpx
		tya
		ldy  zpx
		jmp  GIVAYF		; this uses the inverse order, Y/A
	.pend
 
FTOSWRDAY	.proc
 
		jsr  FTOSWORDYA	; note the inverse Y/A order
		sta  zpx
		tya
		ldy  zpx
		rts
	.pend
 

GETADRAY	.proc
 
		jsr  GETADR		; this uses the inverse order, Y/A
		sta  zpa
		tya
		ldy  zpa
		rts
	.pend

                            print_f	.proc
                            ; statements
                                ;	src line: library:/prog8lib/floats_functions.p8:5
                                ;	src line: library:/prog8lib/floats_functions.p8:7
                                    stx  zpx
                                    lda  #<value
                                    ldy  #>value
                                    jsr  MOVFM		; load float into fac1
                                    jsr  FOUT		; fac1 to string in A/Y
                                    sta  zpWord1
                                    sty  zpWord1+1
                                    ldy  #0
                            -		lda  (zpWord1),y
                                    beq  +
                                    jsr  c64.CHROUT
                                    iny
                                    bne  -
                            +		ldx  zpx
                                    rts
                            ; variables

                            ; non-zeropage variables
                            value	.byte  0,0,0,0,0  ; float
                                .pend
 

sin	.proc


        lda  #<angle
        ldy  #>angle
        jsr  MOVFM
        stx  zpx
        jsr  SIN
        ldx  zpx
        rts

angle	.byte  0,0,0,0,0  ; float
	.pend


rad	.proc

        lda  #<angle
        ldy  #>angle
        jsr  MOVFM
        stx  zpx
        lda  #<_pi_div_180
        ldy  #>_pi_div_180
        jsr  FMULT
        ldx  zpx
        rts
_pi_div_180	.byte 123, 14, 250, 53, 18		; pi / 180

angle	.byte  0,0,0,0,0  ; float
	.pend
    
    
    
	.pend





























; ---- block: 'math' ----
math	.proc
	;	src line: library:/prog8lib/math.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/math.p8:4
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	http://codebase64.org/doku.php?id=base:6502_6510_maths
;


math_store_reg	.byte  0		; temporary storage


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
		sta  zpa         ; num1
		sty  zpx        ; num2
		lda  #0
		beq  _enterloop
_doAdd		clc
		adc  zpa
_loop		asl  zpa
_enterloop	lsr  zpx
		bcs  _doAdd
		bne  _loop
		rts
		.pend


multiply_bytes_into_word	.proc
	; -- multiply 2 bytes A and Y, result as word in A/Y (unsigned)
		sta  zpa
		sty  zpx
		stx  math_store_reg
		lda  #0
		ldx  #8
		lsr  zpa
-		bcc  +
		clc
		adc  zpx
+		ror  a
		ror  zpa
		dex
		bne  -
		tay
		lda  zpa
		ldx  math_store_reg
		rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
	;      input: A/Y = first 16-bit number, zpWord1 in ZP = second 16-bit number
	;      output: multiply_words.result  4-bytes/32-bits product, LSB order (low-to-high)
	;      clobbers: A

		sta  zpWord0
		sty  zpWord0+1
		stx  zpx

mult16		lda  #0
		sta  result+2	; clear upper bits of product
		sta  result+3
		ldx  #16			; for all 16 bits...
-	 	lsr  zpWord1+1	; divide multiplier by 2
		ror  zpWord1
		bcc  +
		lda  result+2	; get upper half of product and add multiplicand
		clc
		adc  zpWord0
		sta  result+2
		lda  result+3
		adc  zpWord0+1
+ 		ror  a				; rotate partial product
		sta  result+3
		ror  result+2
		ror  result+1
		ror  result
		dex
		bne  -
		ldx  zpx
		rts

result		.byte  0,0,0,0
		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  zpa
		tya
		eor  zpa
		php			; save sign
		lda  zpa
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
_remainder	.byte  0
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  zpx
		sta  zpa
		stx  math_store_reg

		lda  #0
		ldx  #8
		asl  zpa
-		rol  a
		cmp  zpx
		bcc  +
		sbc  zpx
+		rol  zpa
		dex
		bne  -
		ldy  zpa
		ldx  math_store_reg
		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  zpWord0
		sty  zpWord0+1
		lda  zpWord1+1
		eor  zpWord0+1
		php			; save sign
		lda  zpWord1+1
		bpl  +
		lda  #0
		sec
		sbc  zpWord1
		sta  zpWord1
		lda  #0
		sbc  zpWord1+1
		sta  zpWord1+1
+		lda  zpWord0+1
		bpl  +
		lda  #0
		sec
		sbc  zpWord0
		sta  zpWord0
		lda  #0
		sbc  zpWord0+1
		sta  zpWord0+1
+		tay
		lda  zpWord0
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  zpWord0
		sty  zpWord0+1
		lda  #0
		sec
		sbc  zpWord0
		pha
		lda  #0
		sbc  zpWord0+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  zpWord1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: zpWord0 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident


dividend = zpWord1
remainder = zpWord0
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		stx  zpx
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		ldx  zpx
		rts
_divisor	.word 0
		.pend


randseed	.proc
	; -- reset the random seeds for the byte and word random generators
	;    arguments: uword seed in A/Y   clobbers A
	;    (default starting values are:  A=$2c Y=$9e)
		sta  randword._seed
		sty  randword._seed+1
		clc
		adc  #14
		sta  randbyte._seed
		rts
		.pend


randbyte        .proc
	; -- 8 bit pseudo random number generator into A (by just reusing randword)
		jmp  randword
		.pend

randword	.proc
	; -- 16 bit pseudo random number generator into AY

		; rand64k       ;Factors of 65535: 3 5 17 257
		lda sr1+1
		asl a
		asl a
		eor sr1+1
		asl a
		eor sr1+1
		asl a
		asl a
		eor sr1+1
		asl a
		rol sr1         ;shift this left, "random" bit comes from low
		rol sr1+1
		; rand32k       ;Factors of 32767: 7 31 151 are independent and can be combined
		lda sr2+1
		asl a
		eor sr2+1
		asl a
		asl a
		ror sr2         ;shift this right, random bit comes from high - nicer when eor with sr1
		rol sr2+1
		lda sr1+1         ;can be left out
		eor sr2+1         ;if you dont use
		tay               ;y as suggested
		lda sr1           ;mix up lowbytes of SR1
		eor sr2           ;and SR2 to combine both
		rts

sr1     	.word $a55a
sr2     	.word $7653

		.pend


; ----------- optimized multiplications (stack) : ---------
stack_mul_byte_3	.proc
		; X + X*2
		lda  stack.lo+1,x
		asl  a
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_3	.proc
		; W*2 + W
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend


stack_mul_byte_5	.proc
		; X*4 + X
		lda  stack.lo+1,x
		asl  a
		asl  a
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_5	.proc
		; W*4 + W
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend


stack_mul_byte_6	.proc
		; (X*2 + X)*2
		lda  stack.lo+1,x
		asl  a
                clc
		adc  stack.lo+1,x
		asl  a
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_6	.proc
		; (W*2 + W)*2
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		asl  stack.lo+1,x
                rol  a
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_7	.proc
		; X*8 - X
		lda  stack.lo+1,x
		asl  a
		asl  a
		asl  a
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_7	.proc
		; W*8 - W
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		sbc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_9	.proc
		; X*8 + X
		lda  stack.lo+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_9	.proc
		; W*8 + W
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_10	.proc
		; (X*4 + X)*2
		lda  stack.lo+1,x
		asl  a
		asl  a
		clc
		adc  stack.lo+1,x
		asl  a
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_10	.proc
		; (W*4 + W)*2
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		asl  stack.lo+1,x
                rol  a
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_11	.proc
		; (X*2 + X)*4 - X
		lda  stack.lo+1,x
		asl  a
		clc
		adc  stack.lo+1,x
		asl  a
		asl  a
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

; mul_word_11 is skipped (too much code)

stack_mul_byte_12	.proc
		; (X*2 + X)*4
		lda  stack.lo+1,x
		asl  a
		clc
		adc  stack.lo+1,x
		asl  a
		asl  a
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_12	.proc
		; (W*2 + W)*4
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		asl  stack.lo+1,x
                rol  a
		asl  stack.lo+1,x
                rol  a
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_13	.proc
		; (X*2 + X)*4 + X
		lda  stack.lo+1,x
		asl  a
                clc
		adc  stack.lo+1,x
		asl  a
		asl  a
                clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

; mul_word_13 is skipped (too much code)

stack_mul_byte_14	.proc
		; (X*8 - X)*2
		lda  stack.lo+1,x
		asl  a
		asl  a
		asl  a
                sec
		sbc  stack.lo+1,x
                asl  a
		sta  stack.lo+1,x
		rts
		.pend

; mul_word_14 is skipped (too much code)

stack_mul_byte_15	.proc
		; X*16 - X
		lda  stack.lo+1,x
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_15	.proc
		; W*16 - W
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		sbc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_20	.proc
		; (X*4 + X)*4
		lda  stack.lo+1,x
		asl  a
		asl  a
		clc
		adc  stack.lo+1,x
		asl  a
		asl  a
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_20	.proc
		; (W*4 + W)*4
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		asl  stack.lo+1,x
                rol  a
		asl  stack.lo+1,x
                rol  a
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_25	.proc
		; (X*2 + X)*8 + X
		lda  stack.lo+1,x
		asl  a
		clc
		adc  stack.lo+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_25	.proc
		; W = (W*2 + W) *8 + W
		lda  stack.hi+1,x
		sta  zpWord1+1
		lda  stack.lo+1,x
		asl  a
		rol  zpWord1+1
		clc
		adc  stack.lo+1,x
		sta  zpWord1
		lda  zpWord1+1
		adc  stack.hi+1,x
		sta  zpWord1+1
		lda  zpWord1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpWord1+1
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_40	.proc
		lda  stack.lo+1,x
		and  #7
		tay
		lda  mul_byte_40._forties,y
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_40	.proc
		; (W*4 + W)*8
		lda  stack.hi+1,x
		sta  zpx
		lda  stack.lo+1,x
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		clc
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  zpx
		adc  stack.hi+1,x
		asl  stack.lo+1,x
                rol  a
		asl  stack.lo+1,x
                rol  a
		asl  stack.lo+1,x
                rol  a
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_byte_50	.proc
		lda  stack.lo+1,x
		and  #7
		tay
		lda  mul_byte_50._fifties, y
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_50	.proc
		; W = W * 25 * 2
		jsr  stack_mul_word_25
		asl  stack.lo+1,x
		rol  stack.hi+1,x
		rts
		.pend

stack_mul_byte_80	.proc
		lda  stack.lo+1,x
		and  #3
		tay
		lda  mul_byte_80._eighties, y
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_80	.proc
		; W = W * 40 * 2
		jsr  stack_mul_word_40
		asl  stack.lo+1,x
		rol  stack.hi+1,x
		rts
		.pend

stack_mul_byte_100	.proc
		lda  stack.lo+1,x
		and  #3
		tay
		lda  mul_byte_100._hundreds, y
		sta  stack.lo+1,x
		rts
		.pend

stack_mul_word_100	.proc
		; W = W * 25 * 4
		jsr  stack_mul_word_25
		asl  stack.lo+1,x
		rol  stack.hi+1,x
		asl  stack.lo+1,x
		rol  stack.hi+1,x
		rts
		.pend

stack_mul_word_320	.proc
		; stackW = stackLo * 256 + stackLo * 64	 (stackHi doesn't matter)
		ldy  stack.lo+1,x
		lda  #0
		sta  stack.hi+1,x
		tya
		asl  a
		rol  stack.hi+1,x
		asl  a
		rol  stack.hi+1,x
		asl  a
		rol  stack.hi+1,x
		asl  a
		rol  stack.hi+1,x
		asl  a
		rol  stack.hi+1,x
		asl  a
		rol  stack.hi+1,x
		sta  stack.lo+1,x
		tya
		clc
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

stack_mul_word_640	.proc
		; stackW = (stackLo * 2 * 320)    (stackHi doesn't matter)
		asl  stack.lo+1,x
		jmp  stack_mul_word_320
		.pend


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  zpx
		asl  a
		clc
		adc  zpx
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		tay
		lda  zpWord1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  zpx
		asl  a
		asl  a
		clc
		adc  zpx
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		tay
		lda  zpWord1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  zpx
		asl  a
                clc
                adc  zpx
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		tay
		lda  zpWord1+1
		adc  zpWord0+1
		sta  zpWord1+1
		tya
		asl  a
		rol  zpWord1+1
		ldy  zpWord1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  zpx
		asl  a
		asl  a
		asl  a
		sec
		sbc  zpx
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		sec
		sbc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		sbc  zpWord0+1
		tay
		lda  zpWord1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  zpx
		asl  a
		asl  a
		asl  a
		clc
		adc  zpx
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		tay
		lda  zpWord1
		rts
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  zpx
		asl  a
		asl  a
		clc
		adc  zpx
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		sta  zpWord1+1
		lda  zpWord1
		asl  a
		rol  zpWord1+1
		ldy  zpWord1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  zpx
		asl  a
		clc
		adc  zpx
		asl  a
		asl  a
		sec
		sbc  zpx
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  zpx
		asl  a
		clc
		adc  zpx
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		sta  zpWord1+1
		lda  zpWord1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		ldy  zpWord1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  zpx
		asl  a
                clc
		adc  zpx
		asl  a
		asl  a
                clc
		adc  zpx
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  zpx
		asl  a
		asl  a
		asl  a
                sec
		sbc  zpx
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  zpx
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  zpx
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		sec
		sbc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		sbc  zpWord0+1
		tay
		lda  zpWord1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  zpx
		asl  a
		asl  a
		clc
		adc  zpx
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  zpx
		asl  a
		rol  zpx
		ldy  zpx
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  zpx
		asl  a
		clc
		adc  zpx
		asl  a
		asl  a
		asl  a
		clc
		adc  zpx
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		sta  zpWord1+1
		lda  zpWord1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		tay
		lda  zpWord1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  zpWord1
		sty  zpWord1+1
		sta  zpWord0
		sty  zpWord0+1
		asl  a
		rol  zpWord1+1
		asl  a
		rol  zpWord1+1
		clc
		adc  zpWord0
		sta  zpWord1
		lda  zpWord1+1
		adc  zpWord0+1
		asl  zpWord1
		rol  a
		asl  zpWord1
		rol  a
		asl  zpWord1
		rol  a
		tay
		lda  zpWord1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  zpx
		asl  a
		rol  zpx
		ldy  zpx
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  zpx
		asl  a
		rol  zpx
		ldy  zpx
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		ldy  zpx
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  zpa
		ldy  #0
		sty  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		asl  a
		rol  zpx
		pha
		clc
		lda  zpa
		adc  zpx
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; bit shifts.
; anything below 3 is done inline. anything above 7 is done via other optimizations.

shift_left_w_7	.proc
		lda  stack.hi+1,x
		sta  zpa
		lda  stack.lo+1,x

		asl  a
		rol  zpa
_shift6		asl  a
		rol  zpa
_shift5		asl  a
		rol  zpa
_shift4		asl  a
		rol  zpa
_shift3		asl  a
		rol  zpa
		asl  a
		rol  zpa
		asl  a
		rol  zpa

		sta  stack.lo+1,x
		lda  zpa
		sta  stack.hi+1,x
		rts
		.pend

shift_left_w_6	.proc
		lda  stack.hi+1,x
		sta  zpa
		lda  stack.lo+1,x
		jmp  shift_left_w_7._shift6
		.pend

shift_left_w_5	.proc
		lda  stack.hi+1,x
		sta  zpa
		lda  stack.lo+1,x
		jmp  shift_left_w_7._shift5
		.pend

shift_left_w_4	.proc
		lda  stack.hi+1,x
		sta  zpa
		lda  stack.lo+1,x
		jmp  shift_left_w_7._shift4
		.pend

shift_left_w_3	.proc
		lda  stack.hi+1,x
		sta  zpa
		lda  stack.lo+1,x
		jmp  shift_left_w_7._shift3
		.pend


shift_left_w	.proc
		; -- variable number of shifts left
		inx
		ldy  stack.lo,x
		bne  _shift
		rts
_shift		asl  stack.lo+1,x
		rol  stack.hi+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw	.proc
		; -- uword variable number of shifts right
		inx
		ldy  stack.lo,x
		bne  _shift
		rts
_shift		lsr  stack.hi+1,x
		ror  stack.lo+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw_7	.proc
		lda  stack.lo+1,x
		sta  zpa
		lda  stack.hi+1,x

		lsr  a
		ror  zpa
_shift6		lsr  a
		ror  zpa
_shift5		lsr  a
		ror  zpa
_shift4		lsr  a
		ror  zpa
_shift3		lsr  a
		ror  zpa
		lsr  a
		ror  zpa
		lsr  a
		ror  zpa

		sta  stack.hi+1,x
		lda  zpa
		sta  stack.lo+1,x
		rts
		.pend

shift_right_uw_6	.proc
		lda  stack.lo+1,x
		sta  zpa
		lda  stack.hi+1,x
		jmp  shift_right_uw_7._shift6
		.pend

shift_right_uw_5	.proc
		lda  stack.lo+1,x
		sta  zpa
		lda  stack.hi+1,x
		jmp  shift_right_uw_7._shift5
		.pend

shift_right_uw_4	.proc
		lda  stack.lo+1,x
		sta  zpa
		lda  stack.hi+1,x
		jmp  shift_right_uw_7._shift4
		.pend

shift_right_uw_3	.proc
		lda  stack.lo+1,x
		sta  zpa
		lda  stack.hi+1,x
		jmp  shift_right_uw_7._shift3
		.pend


shift_right_w_7		.proc
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1

		asl  a
		ror  zpWord1+1
		ror  zpWord1

		lda  zpWord1+1
_shift6		asl  a
		ror  zpWord1+1
		ror  zpWord1
		lda  zpWord1+1
_shift5		asl  a
		ror  zpWord1+1
		ror  zpWord1
		lda  zpWord1+1
_shift4		asl  a
		ror  zpWord1+1
		ror  zpWord1
		lda  zpWord1+1
_shift3		asl  a
		ror  zpWord1+1
		ror  zpWord1
		lda  zpWord1+1
		asl  a
		ror  zpWord1+1
		ror  zpWord1
		lda  zpWord1+1
		asl  a
		ror  zpWord1+1
		ror  zpWord1

		lda  zpWord1
		sta  stack.lo+1,x
		lda  zpWord1+1
		sta  stack.hi+1,x
		rts
		.pend

shift_right_w_6	.proc
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		jmp  shift_right_w_7._shift6
		.pend

shift_right_w_5	.proc
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		jmp  shift_right_w_7._shift5
		.pend

shift_right_w_4	.proc
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		jmp  shift_right_w_7._shift4
		.pend

shift_right_w_3	.proc
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		jmp  shift_right_w_7._shift3
		.pend


shift_right_w	.proc
		; -- signed word variable number of shifts right
		inx
		ldy  stack.lo,x
		bne  _shift
		rts
_shift		lda  stack.hi+1,x
		asl  a
		ror  stack.hi+1,x
		ror  stack.lo+1,x
		dey
		bne  _shift
		rts
		.pend


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y (assume >0)
		cmp  #0
		bmi  _negative
-		lsr  a
		dey
		bne  -
		rts
_negative	lsr  a
		ora  #$80
		dey
		bne  _negative
		rts
		.pend


                    square          .proc
                    ; -- calculate square root of signed word in AY, result in AY
                    ; routine by Lee Davsion, source: http://6502.org/source/integers/square.htm
                    ; using this routine is about twice as fast as doing a regular multiplication.
                    ;
                    ; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
                    ; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
                    ; Squarel/Squareh
                    ;
                    ; The maximum input range is only +/-255 and no checking is done to ensure that
                    ; this is so.
                    ;
                    ; This routine is useful if you are trying to draw circles as for any circle
                    ;
                    ; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
                    ; r is the circle radius

                    numberl = zpWord1       ; number to square low byte
                    numberh = zpWord1+1     ; number to square high byte
                    squarel = zpWord0       ; square low byte
                    squareh = zpWord0+1     ; square high byte
                    tempsq = zpa        ; temp byte for intermediate result

                        sta  numberl
                        sty  numberh
                        stx  zpx

                            lda     #$00        ; clear a
                            sta     squarel     ; clear square low byte
                                                ; (no need to clear the high byte, it gets shifted out)
                            lda	numberl     ; get number low byte
                        ldx	numberh     ; get number high  byte
                        bpl	_nonneg      ; if +ve don't negate it
                                                ; else do a two's complement
                        eor	#$ff        ; invert
                            sec	            ; +1
                        adc	#$00        ; and add it

                    _nonneg:
                        sta	tempsq      ; save abs(number)
                        ldx	#$08        ; set bit count

                    _nextr2bit:
                        asl	squarel     ; low byte *2
                        rol	squareh     ; high byte *2+carry from low
                        asl	a           ; shift number byte
                        bcc	_nosqadd     ; don't do add if c = 0
                        tay                 ; save a
                        clc                 ; clear carry for add
                        lda	tempsq      ; get number
                        adc	squarel     ; add number^2 low byte
                        sta	squarel     ; save number^2 low byte
                        lda	#$00        ; clear a
                        adc	squareh     ; add number^2 high byte
                        sta	squareh     ; save number^2 high byte
                        tya                 ; get a back

                    _nosqadd:
                        dex                 ; decrement bit count
                        bne	_nextr2bit   ; go do next bit

                        lda  squarel
                        ldy  squareh
                        ldx  zpx
                        rts

		.pend
                                 
                                sin8u	.proc
                                 
                                        tay
                                        lda  _sinecos8u,y
                                        rts
                                _sinecos8u	.byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
                                    .pend
                                 

                                cos8u	.proc
                                 
                                        tay
                                        lda  sin8u._sinecos8u+64,y
                                        rts
                                    .pend
                                 

                                sin8	.proc
                                 
                                        tay
                                        lda  _sinecos8,y
                                        rts
                                _sinecos8	.char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
                                    .pend
                                 

                                cos8	.proc
                                 
                                        tay
                                        lda  sin8._sinecos8+64,y
                                        rts
                                    .pend
                                 

                                sinr8u	.proc
                                    ;	src line: library:/prog8lib/math.p8:41
                                        tay
                                        lda  _sinecosR8u,y
                                        rts
                                _sinecosR8u	.byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
                                    .pend
                                    ;	src line: library:/prog8lib/math.p8:49

                                cosr8u	.proc
                                    ;	src line: library:/prog8lib/math.p8:50
                                        tay
                                        lda  sinr8u._sinecosR8u+45,y
                                        rts
                                    .pend
                                    ;	src line: library:/prog8lib/math.p8:57

                                sinr8	.proc
                                    ;	src line: library:/prog8lib/math.p8:58
                                        tay
                                        lda  _sinecosR8,y
                                        rts
                                _sinecosR8	.char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
                                    .pend
                                    ;	src line: library:/prog8lib/math.p8:66

                                cosr8	.proc
                                    ;	src line: library:/prog8lib/math.p8:67
                                        tay
                                        lda  sinr8._sinecosR8+45,y
                                        rts
                                    .pend
                                    .pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	;	src line: library:/prog8lib/prog8_lib.p8:3

; non-zeropage variables

; subroutines in this block
	;	src line: library:/prog8lib/prog8_lib.p8:4
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.


orig_stackpointer	.byte  0	; stores the Stack pointer register at program start

read_byte_from_address_on_stack	.proc
	; -- read the byte from the memory address on the top of the stack, return in A (stack remains unchanged)
		lda  stack.lo+1,x
		ldy  stack.hi+1,x
		sta  zpWord0
		sty  zpWord0+1
		ldy  #0
		lda  (zpWord0),y
		rts
		.pend


write_byte_to_address_on_stack	.proc
	; -- write the byte in A to the memory address on the top of the stack (stack remains unchanged)
		ldy  stack.lo+1,x
		sty  zpWord0
		ldy  stack.hi+1,x
		sty  zpWord0+1
		ldy  #0
		sta  (zpWord0),y
		rts
		.pend



neg_b		.proc
		lda  #0
		sec
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		rts
		.pend

neg_w		.proc
		sec
		lda  #0
		sbc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  #0
		sbc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

inv_word	.proc
		lda  stack.lo+1,x
		eor  #255
		sta  stack.lo+1,x
		lda  stack.hi+1,x
		eor  #255
		sta  stack.hi+1,x
		rts
		.pend

bitand_b	.proc
		; -- bitwise and (of 2 bytes)
		lda  stack.lo+2,x
		and  stack.lo+1,x
		inx
		sta  stack.lo+1,x
		rts
		.pend

bitor_b		.proc
		; -- bitwise or (of 2 bytes)
		lda  stack.lo+2,x
		ora  stack.lo+1,x
		inx
		sta  stack.lo+1,x
		rts
		.pend

bitxor_b	.proc
		; -- bitwise xor (of 2 bytes)
		lda  stack.lo+2,x
		eor  stack.lo+1,x
		inx
		sta  stack.lo+1,x
		rts
		.pend

bitand_w	.proc
		; -- bitwise and (of 2 words)
		lda  stack.lo+2,x
		and  stack.lo+1,x
		sta  stack.lo+2,x
		lda  stack.hi+2,x
		and  stack.hi+1,x
		sta  stack.hi+2,x
		inx
		rts
		.pend

bitor_w		.proc
		; -- bitwise or (of 2 words)
		lda  stack.lo+2,x
		ora  stack.lo+1,x
		sta  stack.lo+2,x
		lda  stack.hi+2,x
		ora  stack.hi+1,x
		sta  stack.hi+2,x
		inx
		rts
		.pend

bitxor_w	.proc
		; -- bitwise xor (of 2 bytes)
		lda  stack.lo+2,x
		eor  stack.lo+1,x
		sta  stack.lo+2,x
		lda  stack.hi+2,x
		eor  stack.hi+1,x
		sta  stack.hi+2,x
		inx
		rts
		.pend


add_w		.proc
	; -- push word+word / uword+uword
		inx
		clc
		lda  stack.lo,x
		adc  stack.lo+1,x
		sta  stack.lo+1,x
		lda  stack.hi,x
		adc  stack.hi+1,x
		sta  stack.hi+1,x
		rts
		.pend

sub_w		.proc
	; -- push word-word
		inx
		sec
		lda  stack.lo+1,x
		sbc  stack.lo,x
		sta  stack.lo+1,x
		lda  stack.hi+1,x
		sbc  stack.hi,x
		sta  stack.hi+1,x
		rts
		.pend

mul_byte	.proc
	; -- b*b->b (signed and unsigned)
		inx
		lda  stack.lo,x
		ldy  stack.lo+1,x
		jsr  math.multiply_bytes
		sta  stack.lo+1,x
		rts
		.pend

mul_word	.proc
		inx
		lda  stack.lo,x
		sta  zpWord1
		lda  stack.hi,x
		sta  zpWord1+1
		lda  stack.lo+1,x
		ldy  stack.hi+1,x
		jsr  math.multiply_words
		lda  math.multiply_words.result
		sta  stack.lo+1,x
		lda  math.multiply_words.result+1
		sta  stack.hi+1,x
		rts
		.pend

idiv_b		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		inx
		lda  stack.lo,x
		eor  stack.lo+1,x
		php			; save sign of result
		lda  stack.lo,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num1 positive
+		tay
		inx
		lda  stack.lo,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num2 positive
+		jsr  math.divmod_ub_asm
		sta  _remainder
		tya
		plp			; get sign of result
		bpl  +
		eor  #$ff
		sec
		adc  #0			; negate result
+		sta  stack.lo,x
		dex
		rts
_remainder	.byte  0
		.pend

idiv_ub		.proc
		inx
		ldy  stack.lo,x
		lda  stack.lo+1,x
		jsr  math.divmod_ub_asm
		tya
		sta  stack.lo+1,x
		rts
		.pend

idiv_w		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		lda  stack.hi+2,x
		eor  stack.hi+1,x
		php				; save sign of result
		lda  stack.hi+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		inx
		lda  stack.hi+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		lda  stack.lo,x
		ldy  stack.hi,x
		jsr  math.divmod_uw_asm
		sta  stack.lo+1,x
		tya
		sta  stack.hi+1,x
		plp
		bpl  +
		jmp  neg_w		; negate result
+		rts
		.pend

idiv_uw		.proc
		inx
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		lda  stack.lo,x
		ldy  stack.hi,x
		jsr  math.divmod_uw_asm
		sta  stack.lo+1,x
		tya
		sta  stack.hi+1,x
		rts
		.pend

remainder_ub	.proc
		inx
		ldy  stack.lo,x	; right operand
		lda  stack.lo+1,x  ; left operand
		jsr  math.divmod_ub_asm
		sta  stack.lo+1,x
		rts
		.pend

remainder_uw	.proc
		inx
		lda  stack.lo+1,x
		sta  zpWord1
		lda  stack.hi+1,x
		sta  zpWord1+1
		lda  stack.lo,x
		ldy  stack.hi,x
		jsr  math.divmod_uw_asm
		lda  zpWord0
		sta  stack.lo+1,x
		lda  zpWord0+1
		sta  stack.hi+1,x
		rts
		.pend

equal_w		.proc
	; -- are the two words on the stack identical?
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		bne  equal_b._equal_b_false
		lda  stack.hi+1,x
		cmp  stack.hi+2,x
		bne  equal_b._equal_b_false
		beq  equal_b._equal_b_true
		.pend

notequal_b	.proc
	; -- are the two bytes on the stack different?
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		beq  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		.pend

notequal_w	.proc
	; -- are the two words on the stack different?
		lda  stack.hi+1,x
		cmp  stack.hi+2,x
		beq  notequal_b
		bne  equal_b._equal_b_true
		.pend

less_ub		.proc
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

less_b		.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  stack.lo+2,x
		sec
		sbc  stack.lo+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_less_uw	.proc
		;  AY < zpWord0?
		cpy  zpWord0+1
		bcc  _true
		bne  _false
		cmp  zpWord0
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_uw		.proc
		lda  stack.hi+2,x
		cmp  stack.hi+1,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

reg_less_w	.proc
		; -- AY < zpWord0?
		cmp  zpWord0
		tya
		sbc  zpWord0+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_w		.proc
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		lda  stack.hi+2,x
		sbc  stack.hi+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

equal_b		.proc
	; -- are the two bytes on the stack identical?
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		bne  _equal_b_false
_equal_b_true	lda  #1
_equal_b_store	inx
		sta  stack.lo+1,x
		rts
_equal_b_false	lda  #0
		beq  _equal_b_store
		.pend

lesseq_ub	.proc
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

lesseq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  stack.lo+2,x
		clc
		sbc  stack.lo+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_lesseq_uw	.proc
		; AY <= zpWord0?
		cpy  zpWord0+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  zpWord0
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

lesseq_uw	.proc
		lda  stack.hi+1,x
		cmp  stack.hi+2,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

reg_lesseq_w	.proc
		; -- zpWord0 <= AY ?   (note: order different from other routines)
		cmp  zpWord0
		tya
		sbc  zpWord0+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

lesseq_w	.proc
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		lda  stack.hi+1,x
		sbc  stack.hi+2,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_ub	.proc
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		beq  equal_b._equal_b_false
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greater_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  stack.lo+2,x
		clc
		sbc  stack.lo+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_uw	.proc
		lda  stack.hi+1,x
		cmp  stack.hi+2,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

greater_w	.proc
		lda  stack.lo+1,x
		cmp  stack.lo+2,x
		lda  stack.hi+1,x
		sbc  stack.hi+2,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

greatereq_ub	.proc
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  stack.lo+2,x
		sec
		sbc  stack.lo+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greatereq_uw	.proc
		lda  stack.hi+2,x
		cmp  stack.hi+1,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_w	.proc
		lda  stack.lo+2,x
		cmp  stack.lo+1,x
		lda  stack.hi+2,x
		sbc  stack.hi+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_false
		bpl  equal_b._equal_b_true
		.pend


shiftleft_b	.proc
		inx
		ldy  stack.lo,x
		bne  +
		rts
+		lda  stack.lo+1,x
-		asl  a
		dey
		bne  -
		sta  stack.lo+1,x
		rts
		.pend

shiftright_b	.proc
		inx
		ldy  stack.lo,x
		bne  +
		rts
+		lda  stack.lo+1,x
-		lsr  a
		dey
		bne  -
		sta  stack.lo+1,x
		rts
		.pend


equalzero_b	.proc
		lda  stack.lo+1,x
		beq  _true
		bne  _false
_true		lda  #1
		sta  stack.lo+1,x
		rts
_false		lda  #0
		sta  stack.lo+1,x
		rts
		.pend

equalzero_w	.proc
		lda  stack.lo+1,x
		ora  stack.hi+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

notequalzero_b	.proc
		lda  stack.lo+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

notequalzero_w	.proc
		lda  stack.lo+1,x
		ora  stack.hi+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lesszero_b	.proc
		lda  stack.lo+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

lesszero_w	.proc
		lda  stack.hi+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

greaterzero_ub	.proc
		lda  stack.lo+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sb	.proc
		lda  stack.lo+1,x
		beq  equalzero_b._false
		bpl  equalzero_b._true
		bmi  equalzero_b._false
		.pend

greaterzero_uw	.proc
		lda  stack.lo+1,x
		ora  stack.hi+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sw	.proc
		lda  stack.hi+1,x
		bmi  equalzero_b._false
		ora  stack.lo+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lessequalzero_sb	.proc
		lda  stack.lo+1,x
		bmi  equalzero_b._true
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

lessequalzero_sw	.proc
		lda  stack.hi+1,x
		bmi  equalzero_b._true
		ora  stack.lo+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

greaterequalzero_sb	.proc
		lda  stack.lo+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

greaterequalzero_sw	.proc
		lda  stack.hi+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

memcopy16_up	.proc
	; -- copy memory UP from (zpWord1) to (zpWord0) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = zpWord1
		dest = zpWord0
		length = zpa   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (zpWord1), length XY, with value in A.
	;    clobbers X, Y
		stx  zpa
		sty  _save_reg
		ldy  #0
		ldx  _save_reg
		beq  _lastpage

_fullpage	sta  (zpWord1),y
		iny
		bne  _fullpage
		inc  zpWord1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  zpa
		beq  +
-         	dey
		sta  (zpWord1),y
		bne  -

+           	rts
_save_reg	.byte  0
		.pend


memsetw		.proc
	; -- fill memory from (zpWord1) number of words in zpWord0, with word value in AY.
	;    clobbers A, X, Y
		sta  _mod1+1                    ; self-modify
		sty  _mod1b+1                   ; self-modify
		sta  _mod2+1                    ; self-modify
		sty  _mod2b+1                   ; self-modify
		ldx  zpWord1
		stx  zpa
		ldx  zpWord1+1
		inx
		stx  zpx                ; second page

		ldy  #0
		ldx  zpWord0+1
		beq  _lastpage

_fullpage
_mod1           lda  #0                         ; self-modified
		sta  (zpWord1),y        ; first page
		sta  (zpa),y            ; second page
		iny
_mod1b		lda  #0                         ; self-modified
		sta  (zpWord1),y        ; first page
		sta  (zpa),y            ; second page
		iny
		bne  _fullpage
		inc  zpWord1+1          ; next page pair
		inc  zpWord1+1          ; next page pair
		inc  zpa+1              ; next page pair
		inc  zpa+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  zpWord0
		beq  _done

		ldy  #0
-
_mod2           lda  #0                         ; self-modified
                sta  (zpWord1), y
		inc  zpWord1
		bne  _mod2b
		inc  zpWord1+1
_mod2b          lda  #0                         ; self-modified
		sta  (zpWord1), y
		inc  zpWord1
		bne  +
		inc  zpWord1+1
+               dex
		bne  -
_done		rts
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
		lda  (zpWord1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (zpWord1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
		lda  (zpWord1),y
		cmp  #$80
		rol  a
		sta  (zpWord1),y
		rts
		.pend

rol_array_ub	.proc
		; -- rol a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		ldy  _arg_index
		lda  (zpWord1),y
		rol  a
		sta  (zpWord1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend


ror_array_ub	.proc
		; -- ror a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		ldy  _arg_index
		lda  (zpWord1),y
		ror  a
		sta  (zpWord1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror2_array_ub	.proc
		; -- ror2 (8-bit ror) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		ldy  _arg_index
		lda  (zpWord1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (zpWord1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

rol2_array_ub	.proc
		; -- rol2 (8-bit rol) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		ldy  _arg_index
		lda  (zpWord1),y
		cmp  #$80
		rol  a
		sta  (zpWord1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror_array_uw	.proc
		; -- ror a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (zpWord1),y
		plp
		ror  a
		sta  (zpWord1),y
		dey
		lda  (zpWord1),y
		ror  a
		sta  (zpWord1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol_array_uw	.proc
		; -- rol a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		lda  _arg_index
		asl  a
		tay
		lda  (zpWord1),y
		plp
		rol  a
		sta  (zpWord1),y
		iny
		lda  (zpWord1),y
		rol  a
		sta  (zpWord1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol2_array_uw	.proc
		; -- rol2 (16-bit rol) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		lda  _arg_index
		asl  a
		tay
		lda  (zpWord1),y
		asl  a
		sta  (zpWord1),y
		iny
		lda  (zpWord1),y
		rol  a
		sta  (zpWord1),y
		bcc  +
		dey
		lda  (zpWord1),y
		adc  #0
		sta  (zpWord1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

ror2_array_uw	.proc
		; -- ror2 (16-bit ror) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  zpWord1
		sty  zpWord1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (zpWord1),y
		lsr  a
		sta  (zpWord1),y
		dey
		lda  (zpWord1),y
		ror  a
		sta  (zpWord1),y
		bcc  +
		iny
		lda  (zpWord1),y
		ora  #$80
		sta  (zpWord1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (zpWord1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  zpWord0
		sty  zpWord0+1
		ldy  #$ff
-		iny
		lda  (zpWord0),y
		sta  (zpWord1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  zpWord0
		sty  zpWord0+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
_arg_s1		.word  0
_arg_s2		.word  0
		.pend


strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (zpWord0).
		;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
_loop		lda  (zpWord1),y
		bne  +
		lda  (zpWord0),y
		bne  _return_minusone
		beq  _return
+		cmp  (zpWord0),y
		bcc  _return_minusone
		bne  _return_one
		inc  zpWord1
		bne  +
		inc  zpWord1+1
+		inc  zpWord0
		bne  _loop
		inc  zpWord0+1
		bne  _loop
_return_one
		lda  #1
_return		rts
_return_minusone
		lda  #-1
		rts
		.pend


sign_extend_stack_byte	.proc
	; -- sign extend the (signed) byte on the stack to full 16 bits
		lda  stack.lo+1,x
		ora  #$7f
		bmi  +
		lda  #0
+		sta  stack.hi+1,x
		rts
		.pend

strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y.
		sta  zpWord1
		sty  zpWord1+1
		ldy  #0
-		lda  (zpWord1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: zpWord1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (zpWord1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_wordarray	.proc
	; -- check if a value exists in a word array.
	;    parameters: zpWord1: value to check, zpWord0: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  zpWord1
		cmp  (zpWord0),y
		bne  +
		lda  zpWord1+1
		iny
		cmp  (zpWord0),y
		beq  _found
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend
	;	src line: library:/prog8lib/prog8_lib.p8:5
; ---- builtin functions


func_any_b_stack	.proc
		jsr  func_any_b_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_all_b_stack	.proc
		jsr  func_all_b_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_any_b_into_A	.proc
		; -- any(array),  array in zpWord1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (zpWord1),y
		bne  _got_any
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #0
		rts
_got_any	lda  #1
		rts
		.pend


func_all_b_into_A	.proc
		; -- all(array),  array in zpWord1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (zpWord1),y
		beq  _got_not_all
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
_got_not_all	rts
		.pend

func_any_w_into_A	.proc
		asl  a
		jmp  func_any_b_into_A
		.pend

func_any_w_stack	.proc
		asl  a
		jsr  func_any_b_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_all_w_into_A	.proc
		; -- all(warray),  array in zpWord1, num bytes in A
		asl  a			; times 2 because of word
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (zpWord1),y
		bne  +
		iny
		lda  (zpWord1),y
		bne  ++
		lda  #0
		rts
+		iny
+		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
		rts
		.pend

func_all_w_stack	.proc
		jsr  func_all_w_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

abs_b_stack	.proc
	; -- push abs(A) on stack (as unsigned word)
		jsr  abs_b_into_AY
		sta  stack.lo,x
		stz  stack.hi,x
		dex
		rts
		.pend

abs_b_into_AY	.proc
	; -- AY = abs(A)  (abs always returns unsigned word)
		ldy  #0
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_stack	.proc
	; -- push abs(AY) on stack (as word)
		jsr  abs_w_into_AY
		sta  stack.lo,x
		tya
		sta  stack.hi,x
		dex
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_b_stack	.proc
		jsr  func_sign_b_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_ub_stack	.proc
		jsr  func_sign_ub_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_uw_stack	.proc
		jsr  func_sign_uw_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		beq  _possibly_zero
		bmi  _neg
_pos		lda  #1
		rts
_neg		lda  #-1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend


func_sign_w_stack	.proc
		jsr  func_sign_w_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_sqrt16_stack	.proc
		jsr  func_sqrt16_into_A
		sta  stack.lo,x
		dex
		rts
		.pend

func_sqrt16_into_A	.proc
		; integer square root from  http://6502org.wikidot.com/software-math-sqrt
		sta  zpWord1
		sty  zpWord1+1
		txa
		pha
		lda  #0
		sta  zpa
		sta  zpx
		ldx  #8
-		sec
		lda  zpWord1+1
		sbc  #$40
		tay
		lda  zpx
		sbc  zpa
		bcc  +
		sty  zpWord1+1
		sta  zpx
+		rol  zpa
		asl  zpWord1
		rol  zpWord1+1
		rol  zpx
		asl  zpWord1
		rol  zpWord1+1
		rol  zpx
		dex
		bne  -
		pla
		tax
		lda  zpa
		rts
		.pend

func_rnd_stack	.proc
	; -- put a random ubyte on the estack
		jsr  math.randbyte
		sta  stack.lo,x
		dex
		rts
		.pend

func_rndw_stack	.proc
	; -- put a random uword on the estack
		jsr  math.randword
		sta  stack.lo,x
		tya
		sta  stack.hi,x
		dex
		rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in zpWord1, length in S
		; first, put pointer BEFORE array
		sta  zpa
		lda  zpWord1
		bne  +
		dec  zpWord1+1
+		dec  zpWord1
_sortloop	ldy  zpa		;start of subroutine sort
		lda  (zpWord1),y	;last value in (what is left of) sequence to be sorted
		sta  zpx		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (zpWord1),y
		cmp  zpWord0+1
		bcc  _l1
_l2		sty  zpWord0	;index of potentially largest value
		sta  zpWord0+1	;potentially largest value
		jmp  _l1
_l3		ldy  zpa		;where the largest value shall be put
		lda  zpWord0+1	;the largest value
		sta  (zpWord1),y	;put largest value in place
		ldy  zpWord0	;index of free space
		lda  zpx		;the over-written value
		sta  (zpWord1),y	;put the over-written value in the free space
		dec  zpa		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in zpWord1, length in A
		; first, put pointer BEFORE array
		sta  zpa
		lda  zpWord1
		bne  +
		dec  zpWord1+1
+		dec  zpWord1
_sortloop	ldy  zpa		;start of subroutine sort
		lda  (zpWord1),y	;last value in (what is left of) sequence to be sorted
		sta  zpx		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (zpWord1),y
		cmp  zpWord0+1
		bmi  _l1
_l2		sty  zpWord0	;index of potentially largest value
		sta  zpWord0+1	;potentially largest value
		jmp  _l1
_l3		ldy  zpa		;where the largest value shall be put
		lda  zpWord0+1	;the largest value
		sta  (zpWord1),y	;put largest value in place
		ldy  zpWord0	;index of free space
		lda  zpx		;the over-written value
		sta  (zpWord1),y	;put the over-written value in the free space
		dec  zpa		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in zpWord1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  zpa
		lda  zpWord1
		sec
		sbc  #2
		sta  zpWord1
		bcs  _sort_loop
		dec  zpWord1+1
_sort_loop	ldy  zpa    	;start of subroutine sort
		lda  (zpWord1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (zpWord1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (zpWord1),y
		dey
		cmp  zpWord0+1
		bne  +
		lda  (zpWord1),y
		cmp  zpWord0
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (zpWord1),y
		sta  zpWord0          ;potentially largest value
		iny
		lda  (zpWord1),y
		sta  zpWord0+1
		dey
		jmp  _l1
_l3		ldy  zpa           ;where the largest value shall be put
		lda  zpWord0          ;the largest value
		sta  (zpWord1),y      ;put largest value in place
		iny
		lda  zpWord0+1
		sta  (zpWord1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (zpWord1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (zpWord1),y
		dey
		dec  zpa           ;end of the shorter sequence still left
		dec  zpa
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in zpWord1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  zpa
		lda  zpWord1
		sec
		sbc  #2
		sta  zpWord1
		bcs  _sort_loop
		dec  zpWord1+1
_sort_loop	ldy  zpa    	;start of subroutine sort
		lda  (zpWord1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (zpWord1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (zpWord1),y
		cmp  zpWord0
		iny
		lda  (zpWord1),y
		dey
		sbc  zpWord0+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (zpWord1),y
		sta  zpWord0          ;potentially largest value
		iny
		lda  (zpWord1),y
		sta  zpWord0+1
		dey
		jmp  _l1
_l3		ldy  zpa           ;where the largest value shall be put
		lda  zpWord0          ;the largest value
		sta  (zpWord1),y      ;put largest value in place
		iny
		lda  zpWord0+1
		sta  (zpWord1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (zpWord1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (zpWord1),y
		dey
		dec  zpa           ;end of the shorter sequence still left
		dec  zpa
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in zpWord1, length in A
_index_right = zpWord0
_index_left = zpWord0+1
_loop_count = zpx
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (zpWord1),y
		pha
		ldy  _index_left
		lda  (zpWord1),y
		ldy  _index_right
		sta  (zpWord1),y
		pla
		ldy  _index_left
		sta  (zpWord1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in zpWord1, length in A
_index_first = zpWord0
_index_second = zpWord0+1
_loop_count = zpx
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (zpWord1),y
		pha
		ldy  _index_second
		lda  (zpWord1),y
		ldy  _index_first
		sta  (zpWord1),y
		pla
		ldy  _index_second
		sta  (zpWord1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (zpWord1),y
		pha
		ldy  _index_second
		lda  (zpWord1),y
		ldy  _index_first
		sta  (zpWord1),y
		pla
		ldy  _index_second
		sta  (zpWord1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peekw   .proc
	; -- read the word value on the address in AY
	sta  zpWord1
	sty  zpWord1+1
	ldy  #0
	lda  (zpWord1),y
	pha
	iny
	lda  (zpWord1),y
	tay
	pla
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in zpWord1
	sty  zpx
	ldy  #0
	sta  (zpWord1),y
	iny
	lda  zpx
	sta  (zpWord1),y
	rts
	.pend
	.pend
; global float constants
prog8_float_const_0	.byte  $87, $76, $e9, $78, $d4  ; float 123.456
; memory slabs
prog8_slabs	.block
	.bend
prog8_program_end	; end of program label for progend()
