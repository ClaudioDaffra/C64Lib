
###########
    math
###########

;............................................... 

;   every logical compare, return always 0/1 Carry set or Not
;   if_true / if_false check carry

;...............................................    useful macro

    u16_add_1   (word)
    u16_sub_1   (word)
    if_u16_gt_0 (word),(jump)

;...............................................    types 

    .byte   unsigned byte   u8
    .char   signed   byte   s8
    .word   unsigned word   u16
    .sint   signed   word   s16

;...............................................    math (c) zpWord0    / zpWord1

    #   math.u8_cmp_eq      ?=
    #   math.u8_cmp_gt      >    
    #   math.u8_cmp_lt      <  
    #   math.u8_cmp_ge      >=
    #   math.u8_cmp_le      <= 
    
    #   math.s8_cmp_eq      ?=
    #   math.s8_cmp_gt      >
    #   math.s8_cmp_lt      <
    #   math.s8_cmp_ge      >=
    #   math.s8_cmp_le      <=
    
    #   math.u16_cmp_eq     ?=
    #   math.u16_cmp_gt     > 
    #   math.u16_cmp_lt     <
    #   math.u16_cmp_gt     >=
    #   math.u16_cmp_lt     <=
    
    #   math.s16_cmp_eq     ?=
    #   math.s16_cmp_gt     >
    #   math.s16_cmp_lt     <
    #   math.s16_cmp_gt     >=
    #   math.s16_cmp_lt     <=

    ; ---------------------------------------------------------------   mul_bytes
    ;
    ;   multiply 2 bytes A and Y, result as byte in A  
    ;   (signed or unsigned)
    ;
    ;   input   :   a,y
    ;   output  :   a
    
    #   mul_bytes

    ; --------------------------------------------------------------- mul_bytes_into_u16
    ;
    ;   multiply 2 bytes A and Y, result as word in A/Y (unsigned)
    ;
    ;   input   :   a,y
    ;   output  :   a:y
    ;
    
    mul_bytes_into_u16
    
;;;
;;
;



 